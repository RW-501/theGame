<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>
<link rel="icon" type="image/png" href="https://img.icons8.com/external-wanicon-lineal-color-wanicon/64/external-bank-stock-market-wanicon-lineal-color-wanicon.png">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }



#game-container {
  position: relative;

  margin: 5rem;

    min-width: 100svw;
    height: 100%;
  /*
 background: #222;
  box-shadow: 0 0 15px #333;
  */

  canvas {
    margin-bottom: 20rem;
    /*
    width: 100vw;
    width: 100dvw;
    width: 100lvw;
    */
    min-width: 100svw;
    height: 100%;
}
}


    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      user-select: none;

    }

    .stats-row {
  margin-bottom: 6px;
  line-height: 1.4;
}

.stats-row:last-child {
  margin-bottom: 0;
  font-weight: bold;
  color: #ffd700; /* Gold color for zone */
}

.info-box span {
  font-weight: 600;
  color: #90caf9;
  padding: 0 3px;
}
    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }

    .damage-popup {
  position: absolute;
  color: red;
  font-weight: bold;
  animation: floatUp 1.2s ease-out;
}

@keyframes floatUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}

:root {
  --accent: #28a745;
  --accent-hover: #218838;
  --bg-dark: #fff;
  --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

#userTool {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-end;
}

#userTool button {
  background-color: var(--accent);
  color: var(--bg-dark);
  padding: 10px 14px;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: var(--shadow);
  transition: background-color 0.3s ease, transform 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
  
    background: rgba(20, 20, 30, 0.95);
    border: 2px solid #4caf50;
    border-radius: 12px;
    box-shadow: 0 0 12px #4caf50cc;
    font-family: 'Orbitron', sans-serif;
    color: #e0e0e0;
}

#userTool button:hover {
  background-color: var(--accent-hover);
  transform: translateY(-2px);
}

#notifBellBtn {
  position: relative;
  background-color: var(--accent);
}

/*
#notifBadge {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: #dc3545;
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 50%;
  display: none;
}

#openChatBtn {
  position: fixed;
  bottom: 90px; 
  right: 20px;
  z-index: 2000;
  padding: 12px 16px;
  border-radius: 50%;
  background: var(--accent);
  color: var(--bg-dark);
  border: none;
  cursor: pointer;
  box-shadow: var(--shadow);
  font-size: 20px;
}

*/


.tile-highlight {
  outline: 3px solid gold;
  z-index: 999;
}



.blink {
  animation: blink-glow 1.2s infinite alternate;
}

@keyframes blink-glow {
  from {
    box-shadow: 0 0 0px transparent;
  }
  to {
    box-shadow: 0 0 8px 3px lime;
  }
}


/* Shared Modal Styles for TileAction and Message Modals */
#manageHomeModal .modal-content,
#tileActionModal .modal-content,
#messageModal .modal-content, 
.gameMode .modal-content {

  background: rgba(20, 20, 30, 0.95);
  border: 2px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 0 12px #4caf50cc;
  font-family: 'Orbitron', sans-serif;
  color: #e0e0e0;
}

/* Modal Header */
.gameMode .modal-header,
#manageHomeModal .modal-header,
#tileActionModal .modal-header,
#messageModal .modal-header {
  border-bottom: 1px solid #555;
  background-color: rgba(0, 0, 0, 0.3);
  color: #fff;
}

/* Card inside modal */
.gameMode .card,
#manageHomeModal .card,
#tileActionModal .card,
#messageModal .card {
  background-color: #1f1f2b;
  border: 1px solid #333;
  border-radius: 10px;
  color: #ddd;
}

/* Card Title */
.gameMode .card-title,
#manageHomeModal .card-title,
#tileActionModal .card-title,
#messageModal .card-title {
  color: #4caf50;
  font-weight: bold;
  font-size: 1.2rem;
}

/* Row Labels */
.gameMode .row strong,
#manageHomeModal .row strong,
#tileActionModal .row strong,
#messageModal .row strong {
  color: #90caf9;
}

/* Modal Footer Buttons */
.gameMode .modal-footer .btn,
#manageHomeModal .modal-footer .btn,
#tileActionModal .modal-footer .btn,
#messageModal .modal-footer .btn {
  border-radius: 8px;
  font-size: 1rem;
  padding: 10px 18px;
  font-weight: 600;
  transition: 0.3s ease;
}

/* Success Button */
.gameMode .btn-success,
#manageHomeModal .btn-success,
#tileActionModal .btn-success,
#messageModal .btn-success {
  background-color: #4caf50;
  border-color: #4caf50;
}

.gameMode .btn-success:hover,
#manageHomeModal .btn-success:hover,
#tileActionModal .btn-success:hover,
#messageModal .btn-success:hover {
  background-color: #66bb6a;
}

/* Text Colors */
.gameMode .text-danger,
#manageHomeModal .text-danger,
#tileActionModal .text-danger,
#messageModal .text-danger {
  color: #e53935 !important;
}

.gameMode .text-success,
#manageHomeModal .text-success,
#tileActionModal .text-success,
#messageModal .text-success {
  color: #66bb6a !important;
}

@keyframes tileZoomIn {
  0% { transform: scale(1); z-index: 2; }
  50% { transform: scale(1.25); z-index: 5; }
  100% { transform: scale(1); z-index: 2; }
}

@keyframes electricShock {
  0% { box-shadow: 0 0 8px 4px #00f6ff; background-color: rgba(0,255,255,0.2); }
  50% { box-shadow: 0 0 12px 6px #00f6ff; background-color: rgba(0,255,255,0.4); }
  100% { box-shadow: 0 0 8px 4px #00f6ff; background-color: rgba(0,255,255,0.2); }
}

  @keyframes zapEffect {
    0% {
      opacity: 0;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.2);
    }
    100% {
      opacity: 0;
      transform: scale(1);
    }
  }
  .hack-overlay {
    position: absolute;
    width: 64px;
    height: 64px;
    z-index: 1000;
    pointer-events: none;
    animation: zapEffect 0.6s ease-out;
   /* background: url('/assets/electric-shock.gif') center center no-repeat; */
    background-size: cover;
      animation: tileZoomIn 0.6s ease-in-out;
        animation: electricShock 1.2s ease-in-out;


  }


.fade-out {
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.fade-out.hide {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.avatar-wrapper {
  padding: 6px;
  border: 2px solid transparent;
  border-radius: 50%;
  display: inline-block;
  transition: border 0.3s ease;
      width: 100px;
    height: 100px;

    .text-muted {
    margin-top: 20px !important;
    color: #4caf50 !important;

    }
}

.avatar-wrapper img {
  width: 70px;
  height: 70px;
  border-radius: 50%;
}

.selected-avatar {
  border: 3px solid #4caf50;
  background-color: #4caf50;
}

    .animated-number {
  transition: all 0.3s ease;
  font-variant-numeric: tabular-nums;
}

.stats-row small, .stats-row strong {
    margin-bottom: 0;
    font-weight: bold;
    color:  #4caf50;
}

 .stats-row span {
    color:  #4caf50;
}

 

.custom-progress {
  background-color: #1d1d1e;
    background-color: #65867c;  border-radius: 8px;
  overflow: hidden;
    border: 3px solid #66bb6a;
    width: 100%;
    height: 20px;
text-indent: 5px;

  .bg-info {
    --bs-bg-opacity: 1;
  background-color: #4caf50;
}
}

.custom-progress-bar {
  height: 100%;
  transition: width 0.5s ease-in-out;
  font-size: 0.8rem;
    color: white;
    line-height: 16px;
    text-align: center;


}

.modal {
  z-index: 10000;
}
  </style>
</head>
<body>

  <main>
<div id="mainArea" class="d-flex justify-content-center align-items-center vh-100">
  <div id="game-container"></div>
</div>

<div class="card shadow-sm rounded info-box p-3 mb-3" id="statsBox">
  <div class="d-flex align-items-center mb-3">
    <img id="playerAvatar" src="" alt="Avatar" class="rounded-circle me-2" width="48" height="48" >
    <div>
      <h5 class="mb-0" id="playerName">Player Name</h5> üéñÔ∏è <strong>Level:</strong> <span id="level">1</span>
    </div>
  </div>

  <div class="stats-row mb-2">

    <div id="xpStats">
</div>

    üè¶ <strong>Bank:</strong> <span id="bank" class="animated-number">$74,340</span> |
     <strong>Crypto:</strong> <span id="crypto">5</span> 

  <div class="stats-row">

    <div id="heathStats">
    ‚ù§Ô∏è <small>Health:</small>
    <div class="custom-progress">
      <div id="healthBar" class="custom-progress-bar bg-danger" role="progressbar" style="width: 100%;" aria-valuemin="0" aria-valuemax="100">100%</div>
    </div>
</div>

    <div id="securityStats">
</div>

        <div id="techStats">
</div>
        <div id="tradeStats">
</div>

  </div>
</div>


<div id="tileTooltip"></div>


<div id="userTool" class="fade-out">
  <button id="returnToLocationBtn">üìç Return to My Location</button>
  <button id="goToPlatformBtn">üåê Go to Platform</button>
  <button id="openOwnedBtn">üì¶ Assets</button>

  <!-- Notification Bell Button -->
  <button id="notifBellBtn" style="box-shadow: none;">
    üîî
    <span id="notifBadge">!</span>
  </button>

  <button id="openChatBtn" title="Open Chat">üí¨</button>

<button id="toggleFullscreenBtn">üî≥ Toggle Fullscreen</button>

  <!-- Gear Toggle Button -->
  <button id="toggleToolsBtn" title="Toggle Tools" style="margin-top: 8px;">‚öôÔ∏è</button>
</div>



</main>




<!-- Tile Actions Modal -->
<div class="modal fade" id="tileActionModal" tabindex="-1" aria-labelledby="tileActionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="tileActionLabel">Tile Actions</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="tileActionBody">
        <!-- Dynamic content here -->
      </div>
      <div class="modal-footer" id="tileActionFooter">
        <!-- Buttons added dynamically -->
      </div>
    </div>
  </div>
</div>




<!-- Message Modal -->
<div class="modal fade" id="messageModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="messageModalTitle">Message</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="messageModalBody">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>


<!-- Asset Viewer Modal -->
<div class="modal fade gameMode" id="ownedModal" tabindex="-1" aria-labelledby="ownedModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="ownedModalLabel">Your Owned Land & Companies</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <div class="modal-body">
        <div class="mb-3">
          <label for="sortFilter" class="form-label">Sort By:</label>
          <select class="form-select" id="sortFilter">
            <option value="value">Value</option>
            <option value="taxRate">Tax Rate</option>
          </select>
        </div>

        <ul id="ownedList" class="list-group">
          <!-- Dynamically generated list items will be injected here -->
        </ul>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<div class="modal fade gameMode" id="startCompanyModal" tabindex="-1" aria-labelledby="startCompanyLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
    
      <div class="modal-header">
        <h5 class="modal-title" id="startCompanyLabel">Start a Company</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="modal-body">
        <label for="sectorSelect">Choose a Sector:</label>
        <select class="form-select mb-3" id="sectorSelect">
          <option value="tech">Tech</option>
          <option value="energy">Energy</option>
          <option value="healthcare">Healthcare</option>
          <option value="finance">Finance</option>
          <option value="transport">Transportation</option>
        </select>

        <label for="companyNameInput">Company Name:</label>
        <input type="text" id="companyNameInput" class="form-control mb-3" placeholder="e.g., NovaTech Inc.">

        <label for="stockSymbolInput">Stock Symbol (3‚Äì5 uppercase letters):</label>
        <input type="text" id="stockSymbolInput" class="form-control" maxlength="5" placeholder="e.g., NTV">
      </div>

      <div class="modal-footer">
        <button class="btn btn-success" id="confirmStartCompanyBtn">Confirm</button>
      </div>

    </div>
  </div>
</div>

<div id="employeesModal" class="modal fade gameMode" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Employees</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <!-- Content is dynamically inserted here -->
      </div>
            <div class="modal-footer">
        <button class="btn btn-success" id="workForCompanyBtn">Work For Company</button>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="manageHomeModal" tabindex="-1" aria-labelledby="manageHomeModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="manageHomeModalLabel">Manage Home Systems</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <!-- dynamically filled -->
      </div>
      <div class="modal-footer">
        <!-- dynamically filled -->
      </div>
    </div>
  </div>
</div>

<!-- Manage Company Modal -->
<div class="modal fade gameMode" id="manageCompanyModal" tabindex="-1" aria-labelledby="manageCompanyLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">

      <div class="modal-header">
        <h5 class="modal-title" id="manageCompanyLabel">Company</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <div class="modal-body">
        <div id="manageCompanyContent">
          <!-- Dynamic content goes here -->
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>

    </div>
  </div>
</div>


<!-- Player Info Modal -->
<div class="modal fade gameMode" id="playerInfoModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">üë§ Player Info</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="playerInfoContent">
        <!-- Filled by JS -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>



<!-- Power-Up Store Modal -->
<div class="modal fade gameMode" id="levelStoreModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">üõçÔ∏è Power-Up Store</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Select a boost to purchase with üí∞ bank money:</p>
        <ul class="list-group" id="boostList">
          <!-- Boosts will be injected here -->
        </ul>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>









<!-- Avatar Modal -->
<div class="modal fade gameMode" id="avatarModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Choose Your Avatar</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
 <hr>
      <div class="modal-body">
        <div id="avatarGallery" class="d-flex flex-wrap gap-3 justify-content-center">
          <!-- Dynamically loaded avatar options -->
        </div>

       

              </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<!-- Bank Ledger Modal -->
<div class="modal fade gameMode" id="bankModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header"><h5 class="modal-title">Bank Ledger</h5></div>
      <div class="modal-body" id="bankLedgerContent">
        <!-- Dynamic Ledger Info Here -->
      </div>
                <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>

  </div>
</div>

<!-- Trades / Stock Market Modal -->
<div class="modal fade gameMode" id="tradeModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header"><h5 class="modal-title">In-Game Stock Market</h5></div>
      <div class="modal-body" id="stockMarketContent">
        <!-- Stocks Table, Charts, Buy/Sell Actions -->
      </div>
              <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
        </div>

    
    </div>
  </div>
</div>

<!-- Strength/Stats Modal -->
<div class="modal fade gameMode" id="statModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header"><h5 class="modal-title" id="statModalTitle">Stat Detail</h5></div>
      <div class="modal-body" id="statModalContent">
        <!-- Dynamic Stat Info -->
      </div>
            <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>




<div id="customModal" class="modal fade gameMode" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="customModalTitle" class="modal-title"></h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div id="customModalBody" class="modal-body"></div>
      <div id="customModalFooter" class="modal-footer"></div>
    </div>
  </div>
</div>







<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<script type="module">
import {  auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import {   getFirestore,  query,
  where, limit, addDoc ,
  arrayRemove, increment, serverTimestamp, 
  arrayUnion, collection, doc, getDoc, getDocs, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { initLiveNotifications, sendNotification  } from 'https://rw-501.github.io/theGame/game/includes/notifications.js'; // Adjust path as needed
import {  } from 'https://rw-501.github.io/theGame/game/includes/chat.js'; // Adjust path as needed

document.addEventListener("DOMContentLoaded", () => {
  const notifBtn = document.getElementById("notifBellBtn");

  if (notifBtn) {
notifBtn.addEventListener("click", () => {
  // Just show modal
  new bootstrap.Modal(document.getElementById("notifModal")).show();
});
  }
});

document.getElementById("toggleToolsBtn").addEventListener("click", (e) => {
  const clickedInsideTools = userTool.contains(e.target);

  const toolButtons = document.querySelectorAll("#userTool button:not(#toggleToolsBtn)");
  const isHidden = toolButtons[0]?.style.display === "none";

toolButtons.forEach(btn => {
  if (isHidden) {
    btn.classList.remove("hide");
    btn.style.display = "inline-block";
  } else {
    btn.classList.add("hide");
    setTimeout(() => {
      btn.style.display = "none";
    }, 300); // match transition time
  }
});  

});
document.body.addEventListener("click", (e) => {
    e.stopPropagation(); // Prevent body click from firing right away

  const userTool = document.getElementById("userTool");
  const clickedInsideTools = userTool.contains(e.target);
    const toolButtons = userTool.querySelectorAll("button:not(#toggleToolsBtn)");


  if (!clickedInsideTools) {
toolButtons.forEach(btn => {
    btn.classList.add("hide");
    setTimeout(() => {
      btn.style.display = "none";
    }, 300); // match transition time
  
});  }
});






window.addEventListener("DOMContentLoaded", () => {
  const toolButtons = document.querySelectorAll("#userTool button:not(#toggleToolsBtn)");
  toolButtons.forEach(btn => btn.style.display = "none");
});



document.getElementById("toggleFullscreenBtn").addEventListener("click", () => {

  const main = document.querySelector("main");

  if (!document.fullscreenElement) {
    // Request fullscreen on main element
    if (main.requestFullscreen) {
      main.requestFullscreen();
    } else if (main.webkitRequestFullscreen) { // Safari
      main.webkitRequestFullscreen();
    } else if (main.msRequestFullscreen) { // IE11
      main.msRequestFullscreen();
    }
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) { // Safari
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE11
      document.msExitFullscreen();
    }
  }
});



// === Game Constants ===
const TILE_SIZE = 64; 
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;
let playerData = {};
let playerSprite;
let isMoving = false;
let playerX = 5, playerY = 5; // Default fallback
let graphics, cursors;
let mapData = [];
let otherPlayerSprites = new Map();


const playerState = new Map();

// === Zone Metadata ===
// === Zone Metadata ===
const zoneInfo = {
  empty: {
    color: 0xffffff,
    label: "Wilderness",
    type: "empty",
    icon: "üå≤",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/dk.png',//'https://rw-501.github.io/theGame/game/images/tile_images/trees/tree-small.png', // fixed slashes and removed extra quotes
    price: 1000,
    income: 0,
    taxRate: 0.8,
    value: 500,
    unlocked: true
  },
  playerHome: {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    icon: "üè†",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png', // fixed slashes and removed extra quotes
    price: 0,
    income: 1,
    taxRate: 0.5,
    value: 100,
    unlocked: true
  },
  company: {
    color: 0x90caf9,
    label: "Company",
    type: "company",
    icon: "üè¢",
    tileImage:'https://rw-501.github.io/theGame/game/images/tile_images/sk.png',// 'https://rw-501.github.io/theGame/game/images/tile_images/industrial/building-5.png', // fixed slashes and removed extra quotes
    price: 1500,
    income: 0,
    taxRate: 10,
    value: 500,
    unlocked: false
  },
  blocked: {
    color: 0x555555,
    label: "Blocked Area",
    type: "blocked",
    icon: "üöß",
    price: 0,
    income: 0,
    taxRate: 0,
    value: 0,
    unlocked: false
  },
  stockMarket: {
    color: 0xffd54f,
    label: "Stock Exchange",
    type: "stockMarket",
    icon: "üìà",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/building.png', // fixed slashes and removed extra quotes
    price: 50000000,
    income: 100000,
    taxRate: 0.25,
    value: 10000000,
    unlocked: false
  },
  // 12 Custom Zones with Incremental Pricing
  ...(() => {
    const zones = {};
    const basePrice = 5000;      // start price at 5000 for Zone 1
    const priceStep = -400;      // negative step to decrease price per zone (adjust as needed)

    const incomeStep = 25;
    const valueStep = 500;
    const baseTax = 0.1;

    const zoneColors = [
      0x9575cd, 0x4fc3f7, 0x4db6ac, 0x81c784, 0xffb74d,
      0xa1887f, 0xe57373, 0xba68c8, 0x64b5f6, 0x81c784,
      0xff8a65, 0xaed581
    ];

    const zoneIcons = [
      "üåÜ", "üèôÔ∏è", "üåÉ", "üèóÔ∏è", "üè¨",
      "üè¢", "üè†", "üèòÔ∏è", "üèöÔ∏è", "üèõÔ∏è",
      "üè®", "üïå"
    ];

    for (let i = 1; i <= 12; i++) {
      const price = basePrice + priceStep * (i - 1);  // decreases price for each subsequent zone
      zones[`zone${i}`] = {
        color: zoneColors[i - 1] || 0xcccccc,
        label: `Zone ${i} Company`,
        type: "company",
        icon: zoneIcons[i - 1] || "üèôÔ∏è",
        tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/dk.png', // fixed slashes and removed extra quotes
        price,
        level: 1,
        income: 50 + incomeStep * (i - 1),
        taxRate: parseFloat((baseTax + i * 0.01).toFixed(2)),
        value: price + valueStep * (i - 1),
        unlocked: i > 3 // unlock first 3 zones by default
      };
    }

    return zones;
  })()
};


async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

  const centerX = 12;
  const centerY = 12;
  mapData[centerY][centerX] = "stockMarket";

  for (let y = centerY - 6; y <= centerY + 6; y++) {
    for (let x = centerX - 6; x <= centerX + 6; x++) {
      if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) continue;
      if (x === centerX && y === centerY) continue;

      const dist = Math.max(Math.abs(x - centerX), Math.abs(y - centerY));
      if (dist >= 1 && dist <= 12) {
        mapData[y][x] = `zone${dist}`;
      }
    }
  }
}

let game;
let scene;
let cam;
let newZoom;
let isPointerDown = false;
let pointerDownTime = 0;
let initialPointer = null;
const allUsersMap = new Map();




const rules = {
  levels: {
    "1": {
      title: "Intern",
      xpToNext: 1000,
      securityStrengthXPToNext: 1000,
      techStrengthXPToNext: 1000,
      startingMoney: 1500,
      maxJobs: 2,
      payPercent: 0.01,
      internetUpdateInterval: 20,
          tradeLimit: 5,
    tradeCooldownMins: 20,
      canAttack: false,
      healthAboveToAttack: 0.3,
      canBeAttacked: true,
      educationRequiredForTierUpgrade: true,
      requires: {
        healthcare: true,
        transportation: true,
        crypto: false
      }
    },
    "2": {
      title: "Junior Analyst",
      xpToNext: 3000,
      securityStrengthXPToNext: 1000,
      techStrengthXPToNext: 1000,
      maxJobs: 3,
      payPercent: 0.03,
      internetUpdateInterval: 15,
      canAttack: true,
      healthAboveToAttack: 0.3,
          tradeLimit: 7,
    tradeCooldownMins: 20,
      canBeAttacked: true,
      requires: {
        healthcare: true,
        transportation: true,
        crypto: false
      }
    },
    "3": {
      title: "Senior Engineer",
      xpToNext: 6000,
      securityStrengthXPToNext: 1000,
      techStrengthXPToNext: 1000,
      maxJobs: 4,
      payPercent: 0.05,
      internetUpdateInterval: 10,
          tradeLimit: 9,
    tradeCooldownMins: 20,
      canAttack: true,
      healthAboveToAttack: 0.35,
      canBeAttacked: true,
      requires: {
        healthcare: true,
        transportation: true,
        crypto: false
      }
    },
    "4": {
      title: "Tech Lead",
      xpToNext: 12000,
      securityStrengthXPToNext: 1000,
      techStrengthXPToNext: 1000,
      maxJobs: 5,
      payPercent: 0.07,
      internetUpdateInterval: 5,
      canAttack: true,
      healthAboveToAttack: 0.4,
          tradeLimit: 12,
    tradeCooldownMins: 20,
      canBeAttacked: true,
      requires: {
        healthcare: true,
        transportation: true,
        crypto: true
      }
    }
  }
};

function checkRuleLimit(player, actionType, value) {
  const level = player.level?.toString() || "1";
  const levelRules = rules.levels[level];

  switch (actionType) {
    case "xpToLevelUp":
      return player.xp >= levelRules.xpToNext &&
             player.securityStrengthXP >= levelRules.securityStrengthXPToNext &&
             player.techStrengthXP >= levelRules.techStrengthXPToNext;

    case "jobCount":
      return value <= levelRules.maxJobs;

    case "payPercent":
      return value <= levelRules.payPercent;

    case "internetSpeed":
      return value >= levelRules.internetUpdateInterval;

    case "requiresHealthcare":
      return !levelRules.requires.healthcare || player.hasHealthcare;

    case "requiresTransportation":
      return !levelRules.requires.transportation || player.hasTransportation;

    case "requiresCrypto":
      return !levelRules.requires.crypto || player.hasCrypto;

    case "canUpgradeTier":
      return !levelRules.educationRequiredForTierUpgrade || player.educationLevel >= "mid";

    case "canAttack":
      return levelRules.canAttack && player.health >= levelRules.healthAboveToAttack;

    case "canBeAttacked":
      return levelRules.canBeAttacked && player.health >= levelRules.healthAboveToAttack;

    default:
      console.warn("Unknown rule:", actionType);
      return false;
  }
}


function refillTradesIfNeeded(player) {
  const levelRules = rules.levels[player.level.toString()];
  const maxTrades = levelRules.tradeLimit;
  const cooldown = levelRules.tradeCooldownMins * 60 * 1000;

  const now = Date.now();
  const elapsed = now - (player.lastTradeRefill || 0);

  const tradesToAdd = Math.floor(elapsed / cooldown);
  if (tradesToAdd > 0) {
    player.tradesAvailable = Math.min(maxTrades, player.tradesAvailable + tradesToAdd);
    player.lastTradeRefill = now;
    savePlayerData();
  }
}

function tryTrade(player) {
  refillTradesIfNeeded(player);

  if (player.tradesAvailable <= 0) {
    showMessageModal("Alert","Trade limit reached. Wait for cooldown.");
    return;
  }

  player.tradesAvailable--;
  savePlayerData();
  executeTrade(); // your custom trade logic
}

function getPlayerTitle(level) {
  return rules.levels[level?.toString()]?.title || "Unknown";
}


function updatePlayerName(newName) {
  if (newName.length > 20) {
    showMessageModal("Alert","Name too long! Max 20 characters.");
    return;
  }
  player.name = newName;
  savePlayerData();
}




/**
 * Persist key fields of playerData to Firestore
 */
async function savePlayerData() {
  if (!playerData?.playerUid) {
    console.warn("No player UID available ‚Äì cannot save data");
    return;
  }
  const docRef = doc(db, "players", playerData.playerUid);
  const payload = {
    xp: playerData.xp,
    level: playerData.level,
    tradesAvailable: playerData.tradesAvailable,
    lastTradeRefill: playerData.lastTradeRefill,
    techStrengthXP: playerData.techStrengthXP,
    securityStrengthXP: playerData.securityStrengthXP,
    bank: playerData.bank,
    health: playerData.health,
    securityStrength: playerData.securityStrength,
    techStrength: playerData.techStrength,
    playerName: playerData.playerName,
    avatarUrl: playerData.avatarUrl,
    avatarImage: playerData.avatarImage
    // Add other fields as needed
  };
  await updateDoc(docRef, payload);
}

/**
 * Call savePlayerData() and optionally refresh UI
 */
async function updateAndPersist(updates = {}) {
  Object.assign(playerData, updates);
  await savePlayerData();
  updateStatsUI();
}





// Example usage for leveling up:
async function tryLevelUp() {
  if (checkRuleLimit(playerData, "xpToLevelUp")) {
    playerData.level++;
    playerData.xp = 0;
    playerData.techStrengthXP = 0;
    playerData.securityStrengthXP = 0;
    playerData.tradesAvailable = rules.levels[playerData.level.toString()].tradeLimit;
    playerData.lastTradeRefill = Date.now();

    await updateAndPersist({
      level: playerData.level,
      xp: 0,
      techStrengthXP: 0,
      securityStrengthXP: 0,
      tradesAvailable: playerData.tradesAvailable,
      lastTradeRefill: playerData.lastTradeRefill
    });


setTimeout(() => {
  launchConfetti();
  showMessageModal("üéâ Level Up!", `You‚Äôre now a ${rules.levels[playerData.level].title}`);
}, 100);

}
}



function launchConfetti() {
  if (!document.getElementById("confettiCanvas")) {
    const confettiCanvas = document.createElement("createConfettiCanvas");
    confettiCanvas.id = "confettiCanvas";
    confettiCanvas.style.position = "fixed";
    confettiCanvas.style.top = "0";
    confettiCanvas.style.left = "0";
    confettiCanvas.style.width = "100%";
    confettiCanvas.style.height = "100%";
    confettiCanvas.style.pointerEvents = "none";
    confettiCanvas.style.zIndex = "9999999";
    document.body.appendChild(confettiCanvas);
  }

  const myConfetti = confetti.create(document.getElementById("confettiCanvas"), {
    resize: true,
    useWorker: true
  });

  myConfetti({
    particleCount: 320,
    spread: 90,
    origin: { y: 0.6 }
  });
}





function getRandomEmptyTile(mapData) {
  const emptyTiles = [];

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      if (mapData[y][x] === "empty") {
        emptyTiles.push([x, y]);
      }
    }
          //  console.log("emptyTiles   ", emptyTiles);

  }

  if (emptyTiles.length === 0) {
    console.warn("‚ö†Ô∏è No empty tiles found. Defaulting to [5, 5].");
    return [5, 5];
  }

  return emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
}


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// === Firebase Login Check ===
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = 'https://rw-501.github.io/theGame';
    return;
  }

let MapWidth = (TILE_SIZE * MAP_SIZE) / 2;


// === Game Setup ===
const config = {
  type: Phaser.AUTO,

width: MapWidth, // window.innerWidth,
height: MapWidth, //window.innerHeight,


  parent: "game-container",
  backgroundColor: "#222222",
  scene: { preload, create }
};

 game = new Phaser.Game(config);

  uid = user.uid;

    
 // Add a 200ms delay before continuing
  await sleep(200);

  try {
 
    setTimeout(async () => {
      /*
console.log("First row:", mapData[0]);         // Logs the first row (an array of 25)
console.log("First tile:", mapData[0][0]);     // Logs the first tile
console.table(mapData);                        // Displays a visual table
      */


      // ‚úÖ Get a random empty tile
  const randomLocation = getRandomEmptyTile(mapData);



  // Query the player with userID === uid and server === "main"
const q = query(
  collection(db, "players"),
  where("userID", "==", uid),
  where("server", "==", "main"),
  limit(1)
);

const querySnapshot = await getDocs(q);

if (!querySnapshot.empty) {
const docSnap = querySnapshot.docs[0];
playerData = docSnap.data();
playerData.id = docSnap.id; // store doc ID
playerData.isNew = false;

const [x, y] = playerData.location;
playerX = x;
playerY = y;

cam.setZoom(newZoom);

// ‚úÖ Center camera on player location
//const TILE_SIZE = 64; // or whatever your tile size is
cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);

  console.log("playerY   ", playerY);

  if (playerData.location === 'start') {

    playerData.location = randomLocation;
    
  const [x, y] =  randomLocation;
  playerX = x;
  playerY = y;
    // Update the location in Firestore
    const docRef = doc(db, "players", docSnap.id);
    await updateDoc(docRef, { location: randomLocation, playerX, playerY });
  }
 } else {
          // Initialize player location
  const [x, y] =  randomLocation;
    // No player found, create a new one
    const newPlayer = {
      playerUid: "", // will be updated below
      userID: uid,
      playerName: user.displayName || "Player" + Math.floor(Math.random() * 1000),
      avatarUrl: 'https://robohash.org/1?size=50x50',
      avatarImage: 'avatar1',
      status: "active",
      lastUpdate: serverTimestamp(),
      online: true,
      server: "main",

      location: randomLocation, // ‚úÖ Assigned here
      playerX: x,
      playerY: y,

      isNew: true,
      trainingMode: true,

      crypto: 5,
      xp: 0,
      level: 1,
      bank: 1000,
      vault: [],
      loans: [],
      health: 100,
      techStrength: 1,
      securityStrength: 1,

      securityStrengthXP: 0,
      techStrengthXP: 0,

      trades: 0,
      tradesTotal: 0,

      tradesAvailable: 5,
      lastTradeRefill: Date.now(), // timestamp in ms

      landOwned: [],
      jobs: [],
      companiesOwned: [],
      stocks: [],

      portfolio: [],
      inCombat: false,
      attacks: 0,
      attacked: 0,
      inventory: [],
      history: [],
      createdAt: serverTimestamp()
    };

    // Create new player document
    const docRef = await addDoc(collection(db, "players"), newPlayer);
    const newId = docRef.id;

    // Update the playerUid in Firestore
    await updateDoc(docRef, { playerUid: newId });

    // Set locally
    newPlayer.id = newId;
    newPlayer.playerUid = newId;
    playerData = newPlayer;
  }

           
const playerRef = doc(db, "players", playerData.playerUid);

// Define the tile ID based on player's current position
const tileId = `${playerX}_${playerY}`;
const tileRef = doc(db, "tiles", tileId);
const tileSnap = await getDoc(tileRef);

if (!tileSnap.exists()) {
  const defaultTileData = {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    level: 1,
    tileLevelXP: 0,
    icon: "üè†",
    tileImage: "https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png",
    price: 0,
    income: 100,
    taxRate: 10,
    value: 1000,
    unlocked: false,
    ownerID: playerData.playerUid,
    ownerName: playerData.playerName,
    createdAt: Date.now(),
  };

  await setDoc(tileRef, defaultTileData);
} else {
  /*
  // Optional: update existing tile with some info (if needed)
  await updateDoc(tileRef, {
    unlocked: true
  });
  */
}




// Example: Update player data if needed
await updateDoc(playerRef, {
  landOwned: [tileId]
});


  // Save player data locally
  localStorage.setItem("theGame_currentPlayerData", JSON.stringify(playerData));

  // Store in playerState map
  playerState.set(uid, playerData);

// On login or dashboard load
await processHourlyIncomeAndTax(playerData);

// OR run every X minutes in your app loop
setInterval(() => processHourlyIncomeAndTax(playerData), 15 * 60 * 1000); // every 15 min

  console.log("‚úÖ Player loaded:", playerData);

  initPlayerRealtimeSync(scene);

}, 1000);


  } catch (error) {
    console.error("‚ùå Error loading player:", error);
  }

});


export async function processHourlyIncomeAndTax(playerData) {
  if (!playerData?.playerUid) return;

  const now = Date.now();
  const lastPayout = playerData.lastPayoutTimestamp || 0;

  const oneHour = 60 * 60 * 1000;
  if (now - lastPayout < oneHour) {
    console.log("Not enough time passed. Skipping income/tax update.");
    return;
  }

  const q = query(collection(db, "tiles"), where("owner", "==", playerData.playerUid));
  const tilesSnap = await getDocs(q);

  let totalIncome = 0;
  let totalTax = 0;

  tilesSnap.forEach(docSnap => {
    const tile = docSnap.data();
    totalIncome += tile.income || 0;
    totalTax += tile.taxRate || 0;
  });

  const netChange = totalIncome - totalTax;
  const newBank = (playerData.bank || 0) + netChange;

  // Update player
  const playerRef = doc(db, "players", playerData.playerUid);
  await updateDoc(playerRef, {
    bank: newBank,
    lastPayoutTimestamp: now
  });

  // Notification
  const message = `
üí∞ Hourly Payout Summary:
+ Income: $${totalIncome.toLocaleString()}
- Taxes: $${totalTax.toLocaleString()}
= Net: $${netChange.toLocaleString()}
`;

  await sendNotification({
    toUid: playerData.playerUid,
    message,
    type: "earnings",
    fromDisplayName: "System",
    fromuserAvatar: "https://rw-501.github.io/theGame/game/images/adminAvatar.png"
  });

  console.log("‚úÖ Income and tax processed for", playerData.displayName || playerData.playerUid);
}



const tileTooltip = document.getElementById("tileTooltip");


function centerCameraOnPlayer() {
  cam.setZoom(newZoom);

cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);
}


async function initializeMap(scene) {
  // Assuming graphics and playerSprite are globals or declared elsewhere
  graphics = scene.add.graphics();
   cam = scene.cameras.main;

  // Await loading map data before drawing
  await loadMapFromFirebase();

  // Draw the map based on loaded data
  drawMap(scene);



  const mapWidth = MAP_SIZE * TILE_SIZE;
  const mapHeight = MAP_SIZE * TILE_SIZE;
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  // Calculate zoom to fit entire map inside screen
  const zoomX = screenWidth / mapWidth;
  const zoomY = screenHeight / mapHeight;
  const zoom = Math.min(zoomX, zoomY, 1); // Limit max zoom to 1 (optional)

  // Set camera bounds to map size
  cam.setBounds(0, 0, mapWidth, mapHeight);

  // Set camera zoom to fit map
  cam.setZoom(zoom);

  // Center camera on map
  // This centers by scrollX/Y, not centerOn (better control)
  cam.scrollX = (mapWidth / 2) - (screenWidth / (2 * zoom));
  cam.scrollY = (mapHeight / 2) - (screenHeight / (2 * zoom));

 // updateStatsUI();
}

function drawMap(scene) {
  graphics.clear();

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {

      // Skip the player‚Äôs tile

      const zoneType = mapData[y][x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;

      // Background fill
      graphics.fillStyle(info.color, 1);
      graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);



          // Draw base concrete if not empty
    if (zoneType != "empty") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "concrete").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }



        if (zoneType == "empty") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "dirt").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }


    // Retrieve and parse the player data from localStorage
const storedData = JSON.parse(localStorage.getItem("theGame_currentPlayerData"));

// Safely extract playerX and playerY
const playerX = storedData?.location?.[0]; // assuming location = [x, y]
const playerY = storedData?.location?.[1];

if (x === playerX && y === playerY) continue;
if (info.x === "home" ) continue;



            if (zoneType == "zone2" || zoneType == "zone4" || zoneType == "zone6") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "commercial").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }
                if (zoneType == "zone3" || zoneType == "zone5") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "industrial").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }

      // Draw image if available
      if (info.imageKey) {
        scene.add.image(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.imageKey
        ).setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
      } 
      
      if (!info.icon) {
        scene.add.text(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.icon,
          { font: `${TILE_SIZE * 0.3}px Arial`, align: 'center' }
        ).setOrigin(0.5);
      }


    }
  }

}

function returnToPlayerLocation(scene) {
  const cam = scene.cameras.main;
  const targetX = playerX * TILE_SIZE + TILE_SIZE / 2;
  const targetY = playerY * TILE_SIZE + TILE_SIZE / 2;

  cam.pan(targetX, targetY, 500, 'Sine.easeInOut');
}


document.getElementById("returnToLocationBtn").addEventListener("click", () => {
  returnToPlayerLocation(game.scene.scenes[0]); // or pass in your current scene reference
});

document.getElementById("goToPlatformBtn").addEventListener("click", () => {
    window.location.href = "https://rw-501.github.io/theGame/game/platform/";
});

 let loadingText;

// === Phaser Scene Methods ===
function preload() {
  // Add loading text or a bar
   loadingText = this.add.text(
    this.cameras.main.centerX,
    this.cameras.main.centerY,
    'Loading...',
    { font: '32px Arial', fill: '#ffffff' }
  ).setOrigin(0.5);

  const usedImages = new Set(); // avoid duplicate loads

this.load.image("concrete", "https://rw-501.github.io/theGame/game/images/tile_images/sk.png"); // or wherever the file is
this.load.image("dirt", "https://rw-501.github.io/theGame/game/images/tile_images/dk.png"); // or wherever the file is


this.load.image("commercial", "https://rw-501.github.io/theGame/game/images/tile_images/commercial/building-3.png"); // or wherever the file is
this.load.image("industrial", "https://rw-501.github.io/theGame/game/images/tile_images/industrial/building-5.png"); // or wherever the file is


this.load.image("house_Lv_1", "https://rw-501.github.io/theGame/game/images/tile_images/house/house-1.PNG");
this.load.image("house_Lv_2", "https://rw-501.github.io/theGame/game/images/tile_images/house/house-2.PNG");
this.load.image("house_Lv_3", "https://rw-501.github.io/theGame/game/images/tile_images/house/house-3.PNG");
this.load.image("house_Lv_4", "https://rw-501.github.io/theGame/game/images/tile_images/house/house-4.PNG");

this.load.image("building_Lv_1", "https://rw-501.github.io/theGame/game/images/tile_images/building/building-1.PNG");
this.load.image("building_Lv_2", "https://rw-501.github.io/theGame/game/images/tile_images/building/building-2.PNG");
this.load.image("building_Lv_3", "https://rw-501.github.io/theGame/game/images/tile_images/building/building-3.PNG");
this.load.image("building_Lv_4", "https://rw-501.github.io/theGame/game/images/tile_images/building/building-4.PNG");

this.load.image("apartment_Lv_1", "https://rw-501.github.io/theGame/game/images/tile_images/apartment/apartment-1.PNG");
this.load.image("apartment_Lv_2", "https://rw-501.github.io/theGame/game/images/tile_images/apartment/apartment-2.PNG");
this.load.image("apartment_Lv_3", "https://rw-501.github.io/theGame/game/images/tile_images/apartment/apartment-3.PNG");
this.load.image("apartment_Lv_4", "https://rw-501.github.io/theGame/game/images/tile_images/apartment/apartment-4.PNG");

  for (const zoneKey in zoneInfo) {
    const tileData = zoneInfo[zoneKey];
    if (tileData.tileImage && !usedImages.has(tileData.tileImage)) {

      const imageKey = zoneKey + "_" + tileData.type; // already correct, just confirm uniqueness
      this.load.image(imageKey, tileData.tileImage);
      tileData.imageKey = imageKey; // store it for drawMap()
      usedImages.add(tileData.tileImage);

      console.log("imageKey ",imageKey);
      console.log("zoneKey ",zoneKey);
      console.log("tileData ",tileData);
    }
  }
this.load.image('avatar1', "https://rw-501.github.io/theGame/game/images/avatars/avatar1.png");
this.load.image('avatar2', "https://rw-501.github.io/theGame/game/images/avatars/avatar2.png");
this.load.image('avatar3', "https://rw-501.github.io/theGame/game/images/avatars/avatar3.png");
this.load.image('avatar4', "https://rw-501.github.io/theGame/game/images/avatars/avatar4.png");
this.load.image('avatar5', "https://rw-501.github.io/theGame/game/images/avatars/avatar5.png");
this.load.image('avatar6', "https://rw-501.github.io/theGame/game/images/avatars/avatar6.png");
this.load.image('avatar7', "https://rw-501.github.io/theGame/game/images/avatars/avatar7.png");


  
  // Optional: Simulate longer loading for testing
  for (let i = 0; i < 100; i++) {
   // this.load.image(`dummy${i}`, 'path/to/dummy.png');
  }

  // Display loading progress
  this.load.on('progress', (value) => {
    loadingText.setText(`Loading... ${Math.round(value * 100)}%`);
  });
/*
  this.load.on('complete', () => {
    loadingText.setText('Loading Complete!');
  });

  */
}













function setupMapMovement(scene) {
  const cam = scene.cameras.main;

  // Drag to move camera

let pointer;


scene.input.on("pointermove", pointer => {
  if (pointer.isDown && isPointerDown) {
    cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
    cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;

  }
});

  // Mouse wheel zoom
  scene.input.on("wheel", (pointer, gameObjects, deltaX, deltaY) => {
     newZoom = Phaser.Math.Clamp(cam.zoom - deltaY * 0.001, 0.5, 2);
    cam.setZoom(newZoom);
  });

    cam.setZoom(newZoom);
}

let selectedTile = null;
let tileHighlightRect = null;


function clearTileSelection() {
  selectedTile = null;

  if (tileHighlightRect) {
    tileHighlightRect.destroy();
    tileHighlightRect = null;
  }

  scene.tweens.add({
    targets: scene.cameras.main,
    zoom: 1,
    scrollX: 0,
    scrollY: 0,
    duration: 300,
    ease: "Sine.easeInOut"
  });

  document.getElementById("statsBox").style.display = "block";
}





function setupMapInteraction(scene) {
  cursors = scene.input.keyboard.createCursorKeys();

  scene.input.keyboard.on("keydown", event => {
    if (isMoving) return;
    switch (event.code) {
      case "ArrowLeft": tryMove(-1, 0, scene); break;
      case "ArrowRight": tryMove(1, 0, scene); break;
      case "ArrowUp": tryMove(0, -1, scene); break;
      case "ArrowDown": tryMove(0, 1, scene); break;
    }
  });



scene.input.on("pointerdown", pointer => {
  isPointerDown = true;
  pointerDownTime = Date.now();
  initialPointer = { x: pointer.x, y: pointer.y };
});


scene.input.on("pointerup", pointer => {
  if (!isPointerDown) return;
  isPointerDown = false;

let clickedX = pointer.x;
let clickedY = pointer.y;

  // Clear any existing highlight
if (tileHighlightRect) {
  tileHighlightRect.destroy();
  tileHighlightRect = null;
}

// Store selected tile
selectedTile = { x: clickedX, y: clickedY };

// ‚úÖ 1. Zoom in slightly (animated)
scene.tweens.add({
  targets: scene.cameras.main,
  zoom: 2,
  scrollX: clickedX * TILE_SIZE - scene.cameras.main.width / 4,
  scrollY: clickedY * TILE_SIZE - scene.cameras.main.height / 4,
  duration: 300,
  ease: "Sine.easeInOut"
});

// ‚úÖ 2. Draw lime green tile highlight
// Add the green highlight rectangle
tileHighlightRect = scene.add.rectangle(
  clickedX * TILE_SIZE + TILE_SIZE / 2,
  clickedY * TILE_SIZE + TILE_SIZE / 2,
  TILE_SIZE, TILE_SIZE,
  0x00ff00, 0.25 // Light green fill
).setStrokeStyle(3, 0x00ff00).setDepth(999); // Make sure it's on top

// Pulse animation (tweening the fill alpha)
scene.tweens.add({
  targets: tileHighlightRect,
  alpha: { from: 0.25, to: 0.5 },
  strokeAlpha: { from: 0.5, to: 1 }, // not directly supported, but we can trick it with tint if needed
  duration: 600,
  ease: 'Sine.easeInOut',
  yoyo: true,
  repeat: -1
});

// Optional: pulse the stroke width using scale trick (visual effect only)
scene.tweens.add({
  targets: tileHighlightRect,
  scaleX: { from: 1, to: 1.05 },
  scaleY: { from: 1, to: 1.05 },
  duration: 600,
  ease: 'Sine.easeInOut',
  yoyo: true,
  repeat: -1
});

let greenShades = [0x00ff00, 0x66ff66, 0x99ff99];
let current = 0;

scene.time.addEvent({
  delay: 500,
  loop: true,
  callback: () => {
    tileHighlightRect.setFillStyle(greenShades[current], 0.3);
    current = (current + 1) % greenShades.length;
  }
});

  // Hide statsBox while moving
  document.getElementById("statsBox").style.display = "none";

  const timeHeld = Date.now() - pointerDownTime;
  const movedDistance = Phaser.Math.Distance.Between(pointer.x, pointer.y, initialPointer.x, initialPointer.y);

  const maxTapTime = 300;       // max press time in ms
  const maxMoveDistance = 10;   // max movement in px before cancel

  if (timeHeld <= maxTapTime && movedDistance <= maxMoveDistance) {
    const worldPoint = scene.cameras.main.getWorldPoint(pointer.x, pointer.y);
    const clickedX = Math.floor(worldPoint.x / TILE_SIZE);
    const clickedY = Math.floor(worldPoint.y / TILE_SIZE);

    if (clickedX < 0 || clickedX >= MAP_SIZE || clickedY < 0 || clickedY >= MAP_SIZE) return;

let otherPlayerId = null;

const entries = playerState instanceof Map
  ? Array.from(playerState.entries())
  : Object.entries(playerState);
/*
console.log("Entries to check:", entries);
console.log("Clicked position:", clickedX, clickedY);
*/
console.log("Current user:", playerData.playerUid);

for (const [pid, pos] of entries) {
  // Defensive checks
  if (!pos || typeof pos.x !== "number" || typeof pos.y !== "number") {
    console.warn(`Skipping invalid player data for ${pid}:`, pos);
    continue;
  }


  // Compare position and exclude current user
  if (
    pid !== playerData.playerUid &&
    Number(pos.x) === Number(clickedX) &&
    Number(pos.y) === Number(clickedY)
  ) {
    otherPlayerId = pid;
    console.log(`‚úÖ Found other player at this tile: ${otherPlayerId}`);
    break;
  }
}

    console.log(`clicked position: ${otherPlayerId}`);

    if (!isPointerDown) {
      const tileType = mapData[clickedY]?.[clickedX] || "empty";
      showTileActionModal(clickedX, clickedY, tileType, otherPlayerId);
    }
  }
});

scene.input.on("pointermove", pointer => {

  cam = scene.cameras.main;

  const worldPoint = cam.getWorldPoint(pointer.x, pointer.y);
  const x = Math.floor(worldPoint.x / TILE_SIZE);
  const y = Math.floor(worldPoint.y / TILE_SIZE);

  if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
    const zoneType = mapData[y]?.[x] || "empty";
    const info = zoneInfo[zoneType] || zoneInfo.empty;

    tileTooltip.style.left = pointer.event.clientX + 15 + "px";
    tileTooltip.style.top = pointer.event.clientY + 15 + "px";
    tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
    tileTooltip.style.display = "block";
  } else {
    tileTooltip.style.display = "none";
  }
});


  scene.input.on("pointerout", () => {
    tileTooltip.style.display = "none";
  });

}

async function showTileActionModal(x, y, tileTypeFromCaller, otherPlayerId) {


  const modalEl = document.getElementById("tileActionModal");
  const modalBody = document.getElementById("tileActionBody");
  const modalFooter = document.getElementById("tileActionFooter");

  if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return;

    const dbTileInfo = await getTileDataAt(x, y);

const tileInfo = mapData[y]?.[x] || "empty";
const info = dbTileInfo ? dbTileInfo : zoneInfo[tileInfo] || zoneInfo.empty;

const trueType = info.type;
const now = Date.now();
console.log("Check Tile info:", info);

// Optional checks
const isUnlocked = info.unlocked ?? true; // fallback to true if not specified
const level = info.level ?? 1;
const income = info.income ?? 0;
const value = info.value ?? info.price ?? 0;
const taxRate = info.taxRate ?? 0;

modalBody.innerHTML = `
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h5 class="card-title mb-3">üìç Tile Info</h5>
      <div class="row g-2">
        <div class="col-6"><strong>Coordinates:</strong><br>(${x}, ${y})</div>
        <div class="col-6"><strong>Tile Type:</strong><br>${info.label} ${info.icon ?? ''}</div>
        <div class="col-6"><strong>Price:</strong><br>$${info.price?.toLocaleString() ?? 'N/A'}</div>
        <div class="col-6"><strong>Value:</strong><br>$${value.toLocaleString()}</div>
        <div class="col-6"><strong>Income:</strong><br>$${income.toLocaleString()} / Weekly</div>
        <div class="col-6"><strong>Tax Rate:</strong><br>${taxRate}%</div>
        <div class="col-6"><strong>Level:</strong><br>${level}</div>
        <div class="col-6"><strong>Owner:</strong><br>${info.ownerName || "None"}</div>
        <div class="col-6">
          <strong>Status:</strong><br>
          ${isUnlocked ? `<span class="text-success">Unlocked</span>` : `<span class="text-danger">Locked</span>`}
        </div>
      </div>
    </div>
  </div>
`;


  modalFooter.innerHTML = "";

  if (trueType === "blocked") {
    modalBody.innerHTML += "<p>This area is blocked. No actions available.</p>";
    return new bootstrap.Modal(modalEl).show();
  }


  
  // === Player tile interaction ===
  if (otherPlayerId) {

const data = allUsersMap.get(otherPlayerId) || {};


    modalBody.innerHTML += `
      <p>Player <strong>${data.playerName}</strong> is here.</p>
      <p>Level: ${data.level}</p>
      <p>Bank: ${data.bank}</p>

      <p>Health: ${data.health}</p>
      <p>Tech Strength: ${data.techStrength}</p>
      <p>Security Strength: ${data.securityStrength}</p>
    `;

 const hackBtn = createButton({
  text: "Hack",
  className: "btn btn-danger",
  onClick: async () => {
    await handleHackPlayer(playerData, data);
    bootstrap.Modal.getInstance(modalEl)?.hide();
  },
  parent: modalFooter
});
hackBtn.disabled = data.isInCombat;

const talkBtn = createButton({
  text: "Talk",
  className: "btn btn-primary",
  onClick: () => {
    showMessageModal(`Talking to ${data.playerName}...`);
    bootstrap.Modal.getInstance(modalEl)?.hide();
  },
  parent: modalFooter
});
talkBtn.disabled = data.isInCombat;

  }



if (!otherPlayerId && trueType === "land" && info.ownerID == playerData.playerUid ) {
  let landType = level > 1 ? "Property" : "Land";

  createButton({
    text: `Upgrade ${landType}`,
    className: "btn btn-success",
    onClick: async () => {
      await upgradeLand(x, y, "land", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}


if (!otherPlayerId && trueType === "home" && info.ownerID == playerData.playerUid) {
  let homeType = level > 5 ? "House" : "Appartment";

  createButton({
    text: `Upgrade ${homeType}`,
    className: "btn btn-success",
    onClick: async () => {
      await upgradeHomeBase(x, y, "home", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });

  // üîß New Button: Open Upgrade/Repair Modal
  createButton({
    text: "Manage Home Systems",
    className: "btn btn-warning",
    onClick: () => {
      showManageHomeModal(x, y);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}


if (!otherPlayerId && isUnlocked && (trueType === "zone" || trueType === "empty")) {
  createButton({
    text: `Buy Land $${info.price}`,
    className: "btn btn-success",
    onClick: async () => {
      await purchaseTile(x, y, "land", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });

  const newValue = info.price + playerData.level * 500;
  createButton({
    text: `Move Here (Buy for $${newValue})`,
    className: "btn btn-primary",
    onClick: async () => {
      await purchaseTile(x, y, "home", true);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (!otherPlayerId && isUnlocked && trueType === "company") {
  createButton({
    text: `Buy Company $${info.price}`,
    className: "btn btn-warning",
    onClick: async () => {
      await purchaseTile(x, y, "company", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

const currentJobs = Array.isArray(playerData.jobs) ? playerData.jobs.length : 0;

  const alreadyWorkingHere = Array.isArray(playerData.jobs)
    ? playerData.jobs.some(job => job.companyCoords[0] === x && job.companyCoords[1] === y)
    : false;


if (trueType === "company" ) {
  createButton({
    text: "View Company Details",
    className: "btn btn-primary",
    onClick: async () => {
await viewCompanyDetailsModal(x, y);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (trueType === "company" && !alreadyWorkingHere ) {
  createButton({
    text: "View Employees",
    className: "btn btn-primary",
    onClick: async () => {
      await showEmployeesModal(`${x}_${y}`);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (
  info.ownerID &&
  isUnlocked &&
  info.ownerID === playerData.playerUid &&
  (trueType === "property" || trueType === "land")
) {
  createButton({
    text: `Start Company $${info.value}`,
    className: "btn btn-success",
    onClick: () => {
const confirmBtn = document.getElementById("confirmStartCompanyBtn");
confirmBtn.dataset.selectedTileX = x;
confirmBtn.dataset.selectedTileY = y;
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}


if (
  //info.ownerID &&
  isUnlocked &&
   info.ownerID != playerData.playerUid &&
  trueType === "company"  && !alreadyWorkingHere
) {
        const payPerDay = Math.floor(info.value / 20);

  createButton({
     text: `Work for company for $${payPerDay} /day`,
       className: "btn btn-success",
    onClick: () => {
 workForCompany(info, playerData, modalFooter, x, y);
      bootstrap.Modal.getInstance(modalEl)?.hide();
      new bootstrap.Modal(document.getElementById("startCompanyModal")).show();
    },
    parent: modalFooter
  });
}




  new bootstrap.Modal(modalEl).show();
}


async function viewCompanyDetailsModal(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const tileSnap = await getDoc(tileRef);

  if (!tileSnap.exists()) {
    showMessageModal(`${tileId}  `+"‚ùå Company not found at this location.", "danger");
    return;
  }

  const company = tileSnap.data();

  // Optional: fallback if some properties are missing
  const companyName = company.name || "Unknown Company";
  const sector = company.sector || "Unknown Sector";
  const ownerID = company.ownerID || "N/A";
  const employees = Array.isArray(company.employsIDs) ? company.employsIDs.length : 0;
  const price = company.price || company.value || 0;
  const stockPrice = company.stockPrice || 0;
  const startedAt = company.companyStartedAt
    ? new Date(company.companyStartedAt).toLocaleString()
    : "N/A";

  // Create modal content
  const modalBody = `
    <h5>${companyName}</h5>
    <p><strong>Sector:</strong> ${sector}</p>
    <p><strong>Owner:</strong> ${ownerID}</p>
    <p><strong>Location:</strong> (${x}, ${y})</p>
    <p><strong>Company Value:</strong> $${price.toLocaleString()}</p>
    <p><strong>Stock Price:</strong> $${stockPrice.toFixed(2)}</p>
    <p><strong>Employees:</strong> ${employees}</p>
    <p><strong>Founded:</strong> ${startedAt}</p>
  `;

  // Show it in your existing modal system
  showCustomModal({
    title: "üìä Company Details",
    body: modalBody,
    footerButtons: [
      {
        text: "Close",
        className: "btn btn-secondary",
        onClick: closeModal,
      },
    ],
  });
}

function showCustomModal({ title = "", body = "", footerButtons = [] }) {
  const modalEl = document.getElementById("customModal");
  const titleEl = document.getElementById("customModalTitle");
  const bodyEl = document.getElementById("customModalBody");
  const footerEl = document.getElementById("customModalFooter");

  titleEl.innerHTML = title;
  bodyEl.innerHTML = typeof body === "string" ? body : "";
  footerEl.innerHTML = "";

  // If body is a DOM node or element
  if (typeof body !== "string" && body instanceof HTMLElement) {
    bodyEl.innerHTML = "";
    bodyEl.appendChild(body);
  }

  // Build buttons
  footerButtons.forEach(({ text, className, onClick }) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = className || "btn btn-primary";
    btn.textContent = text;

    if (typeof onClick === "function") {
      btn.addEventListener("click", onClick);
    }

    footerEl.appendChild(btn);
  });

  const modal = new bootstrap.Modal(modalEl);
  modal.show();
}


const BASE_COST = 1000;
const XP_PER_LEVEL = 50;

function calculateUpgradeStats(currentLevel, statType = "default") {
  let costMultiplier = 1;
  let xpMultiplier = 1;

  // Optional: different stat types could have different multipliers
  switch (statType) {
    case "techStrengthXP":
      costMultiplier = 1.2;
      xpMultiplier = 1.5;
      break;
    case "securityStrengthXP":
      costMultiplier = 1.4;
      xpMultiplier = 1.3;
      break;
    case "health":
      costMultiplier = 1.1;
      xpMultiplier = 1.2;
      break;
    default:
      break;
  }

  const cost = Math.floor(BASE_COST * (currentLevel + 1) * costMultiplier);
  const xpGain = Math.floor(XP_PER_LEVEL * (currentLevel + 1) * xpMultiplier);

  return { cost, xpGain };
}


async function upgradeHomeStat(x, y, stat) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([getDoc(tileRef), getDoc(playerRef)]);
  if (!tileSnap.exists() || !playerSnap.exists()) {
    showMessageModal("Tile or player not found.");
    return;
  }

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData[`${stat}`] || 0;

  // üßÆ Use the new logic
  const { cost, xpGain } = calculateUpgradeStats(currentLevel, stat);

const statLabels = {
  techStrengthXP: "Tech Strength",
  securityStrengthXP: "Security Strength",
  health: "Health"
};



  if (player.bank < cost) {
    showMessageModal(`Not enough money to upgrade ${statLabels[stat] || stat}. Cost: $${cost}`);
    return;
  }


  const updates = {};
  updates[`${stat}`] = currentLevel + 1;

  await Promise.all([
    updateDoc(tileRef, updates),
    updateDoc(playerRef, {
      bank: player.bank - cost,
      xp: (player.xp || 0) + xpGain,
    }),
  ]);



showMessageModal(`‚úÖ Upgraded ${statLabels[stat] || stat} to level ${currentLevel + 1}. Spent $${cost}, gained ${xpGain} XP.`);
}




async function repairHomeHealth(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([getDoc(tileRef), getDoc(playerRef)]);
  if (!tileSnap.exists() || !playerSnap.exists()) {
    showMessageModal("Tile or player not found.");
    return;
  }

 // const tileData = getTileDataAt(x, y); 
  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const maxHealth = 100; // max health cap, adjust if you want
  const currentHealth = tileData.health;
  if (currentHealth >= maxHealth) {
    showMessageModal('info', "Health is already full.");
    return;
  }

  // Repair cost proportional to damage
  const healthToRepair = maxHealth - currentHealth;
  const costPerHealth = 100; // adjust cost per health point repaired
  const repairCost = healthToRepair * costPerHealth;

  if (player.bank < repairCost) {
    showMessageModal('info',`Not enough money to repair health. Cost: $${repairCost}`);
    return;
  }

  await Promise.all([
    updateDoc(tileRef, { health: maxHealth }),
    updateDoc(playerRef, {
      bank:   increment(player.bank - repairCost),
      xp:  increment((player.xp || 0) + healthToRepair / 10),
      securityStrengthXP: increment(healthToRepair / 10)
    }),
  ]);

  showMessageModal('info',`Repaired health to full for $${repairCost}.`);
}


function showManageHomeModal(x, y) {
  const modalEl = document.getElementById("manageHomeModal");
  const modalBody = modalEl.querySelector(".modal-body");
  const modalFooter = modalEl.querySelector(".modal-footer");
  
  modalBody.innerHTML = `
    <p>Upgrade different aspects of your home tile.</p>
    <ul>
      <li><strong>Tech Strength</strong>: Improves hacking defense.</li>
      <li><strong>Security Strength</strong>: Adds guard presence & alert systems.</li>
      <li><strong>Health Repair</strong>: Restores structural integrity.</li>
    </ul>
  `;

  modalFooter.innerHTML = ""; // clear previous buttons

const options = [
  {
    text: "Upgrade Tech Strength",
    onClick: async () => {
      await upgradeHomeStat(x, y, "techStrengthXP");
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  },
  {
    text: "Upgrade Security",
    onClick: async () => {
      await upgradeHomeStat(x, y, "securityStrengthXP");
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  },
  {
    text: "Repair Health",
    onClick: async () => {
      await repairHomeHealth(x, y, 'health');
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  }
];


  options.forEach(({ text, onClick }) => {
    createButton({
      text,
      className: "btn btn-outline-primary me-2",
      onClick,
      parent: modalFooter
    });
  });

  const modal = new bootstrap.Modal(modalEl);
  modal.show();
}

async function showEmployeesModal(tileId) {
  const modalEl = document.getElementById("employeesModal");
  const modalBody = modalEl.querySelector(".modal-body");
  const modalFooter = modalEl.querySelector(".modal-footer");
  modalBody.innerHTML = "Loading...";

  // Always try to show the modal
  const bsModal = new bootstrap.Modal(modalEl);
  bsModal.show();

  try {
    const tileRef = doc(db, "tiles", tileId);
    const tileSnap = await getDoc(tileRef);

    if (!tileSnap.exists()) {
      modalBody.innerHTML = "No data found for this tile.";
      return;
    }

    const tileData = tileSnap.data();
    const employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

    if (employsIDs.length === 0) {
      modalBody.innerHTML = "No employees yet.";
      return;
    }

    let html = `<ul class="list-group">`;

    for (const uid of employsIDs) {
      const empRef = doc(db, "players", uid);
      const empSnap = await getDoc(empRef);

      if (empSnap.exists()) {
        const empData = empSnap.data();
        const job = (empData.jobs || []).find(j => j.companyCoords?.join("_") === tileId);
        const startDate = job ? new Date(job.startedOn).toLocaleDateString() : "Unknown";

        html += `
          <li class="list-group-item d-flex align-items-center">
            <img src="${empData.avatarUrl || empData.avatarImage}" alt="Avatar"
                 class="rounded-circle me-3" style="width: 40px; height: 40px; object-fit: cover;">
            <div>
              <strong>${empData.playerName || 'Unnamed'}</strong><br>
              <small class="text-muted">Started: ${startDate}</small>
            </div>
          </li>
        `;
      }
    }

    html += `</ul>`;
    modalBody.innerHTML = html;
const viewBtn = createButton("üìÑ View Company Details", "btn btn-info", () => {
  viewCompanyDetailsModal(x, y);
});
modalFooter.appendChild(viewBtn);

  } catch (error) {
    modalBody.innerHTML = "An error occurred loading employees.";
    console.error("showEmployeesModal error:", error);
  }
}


async function upgradeLand(x, y, options = {}) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 500;

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 500;

  // Determine land type based on level
  let landType = "Plot";
  if (newLevel > 5) landType = "Farm";
  if (newLevel > 10) landType = "Estate";

  // Allow optional custom label override
  const customLabel = options.getLabel?.(newLevel, tileData) 
                    || `${landType} (Lv ${newLevel})`;

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: customLabel
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost,
      securityStrengthXP: increment(upgradeCost / 4),
      xp: increment(upgradeCost)
    })
  ]);

  showMessageModal(`Land upgraded to ${customLabel}.`);
}

async function upgradeHomeBase(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 500;

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 500;

  let homeType = "Apartment";
  if (newLevel > 5) homeType = "House";
  if (newLevel > 10) homeType = "Estate";

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: `${homeType} (Lv ${newLevel})`
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost,
      xp: increment(upgradeCost),
      securityStrengthXP: increment(upgradeCost / 4),


    })
  ]);

  showMessageModal(`Home upgraded to ${homeType} level ${newLevel}.`);
}

async function handleHackPlayer(attacker, defender) {
  console.log("üõ†Ô∏è Hacking...", attacker.playerName, "vs", defender.playerName);

  const [dx, dy] = defender.location || [];
  const tile = document.querySelector(`[data-x="${dx}"][data-y="${dy}"]`);
  if (tile) {
    const overlay = document.createElement("div");
    overlay.className = "hack-overlay";
    overlay.style.left = `${tile.offsetLeft}px`;
    overlay.style.top = `${tile.offsetTop}px`;
    overlay.style.position = "absolute";
    tile.parentNode.appendChild(overlay);
    setTimeout(() => overlay.remove(), 700);
  }

  const attackerStrength = (attacker.techStrength || 1) + (attacker.techStrengthXP || 0) / 100;
  const defenderSecurity = (defender.securityStrength || 1) + (defender.securityStrengthXP || 0) / 100;

  const attackerLevel = attacker.level || 1;
  const defenderLevel = defender.level || 1;
  const attackerBank = attacker.bank || 0;
  const defenderBank = defender.bank || 0;

  const damage = 10 + attackerLevel * 2;
  const xpGain = 5 + Math.abs(attackerLevel - defenderLevel);
  const stealAmount = Math.min(defenderBank, 100 + attackerLevel * 20);

  const attackerRef = doc(db, "players", attacker.playerUid);
  const defenderRef = doc(db, "players", defender.playerUid);

  const attackerWins = attackerStrength >= defenderSecurity;

  const tileSelector = `[data-x="${dx}"][data-y="${dy}"]`;
  const tileEl = document.querySelector(tileSelector);
  if (tileEl) {
    tileEl.classList.add("tile-zoom", "electric-shock");
    setTimeout(() => tileEl.classList.remove("tile-zoom", "electric-shock"), 1200);
  }

  const xpStealBonus = Math.floor((attacker.techStrengthXP || 0) / 50);
  const xpDefendBonus = Math.floor((defender.securityStrengthXP || 0) / 50);

  await Promise.all([
    updateDoc(attackerRef, {
      inCombat: true,
      xp: increment(xpGain + (attackerWins ? xpStealBonus : 0)),
      bank: increment(attackerWins ? stealAmount : -stealAmount / 2),
      attacks: increment(1),
      techStrengthXP: increment(attackerWins ? stealAmount : stealAmount / 4),
    }),
    updateDoc(defenderRef, {
      inCombat: true,
      health: increment(attackerWins ? -damage : -damage / 2),
      bank: increment(attackerWins ? -stealAmount : -stealAmount / 2),
      attacked: increment(1),
      techStrengthXP: increment(attackerWins ? -stealAmount / 2 : stealAmount / 2),
    })
  ]);

const title = attackerWins ? "üí• Success!" : "‚ùå Hack failed!";
const message = attackerWins
  ? `You hacked ${defender.playerName} and stole $${stealAmount}.`
  : `${defender.playerName} defended successfully.`;

showMessageModal(title, message);


}


async function workForCompany(info, playerData, modalFooter, x, y) {
  const trueType = info.type;
  const jobLimit = 3;

    const currentJobs = Array.isArray(playerData.jobs) ? playerData.jobs.length : 0;

    if (currentJobs < jobLimit) {
      const payPerDay = Math.floor(info.value / 20);


          // Prepare job object
          const job = {
            companyName: info.label || "Unknown Company",
            companyCoords: [x, y],
            pay: payPerDay,
            startedOn: Date.now()
          };

          // Ensure jobs array exists
          if (!Array.isArray(playerData.jobs)) playerData.jobs = [];
          playerData.jobs.push(job);

          // Update player document
          const playerRef = doc(db, "players", playerData.playerUid);
          await updateDoc(playerRef, { jobs: playerData.jobs,
            securityStrengthXP: increment(payPerDay * 2),
            techStrengthXP: increment(payPerDay * 2),
 });

          // Update tile's employsIDs array
          const tileId = `${x}_${y}`;
          const tileRef = doc(db, "tiles", tileId);
          const tileSnap = await getDoc(tileRef);

          if (tileSnap.exists()) {
            const tileData = tileSnap.data();
            let employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

            // Avoid duplicate entry
            if (!employsIDs.includes(playerData.playerUid)) {
              employsIDs.push(playerData.playerUid);
              await updateDoc(tileRef, { employsIDs, tileLevelXP: increment(payPerDay * 2), });
            }
          }

          showMessageModal(`üéâ You‚Äôre now working at ${job.companyName}!`, "success");
   
      

    } else {
          showMessageModal(`üíº Job limit reached`, "success");

    }
  
}


function createButton({ text, className, onClick, parent = document.body, styles = {} }) {
  if (!text) {
    console.trace("createButton called with no text");
    return;
  }

  const button = document.createElement("button");
  button.textContent = text;
  button.className = className;
  button.onclick = onClick;

  Object.assign(button.style, styles);
  parent.appendChild(button);
  return button;
}


async function startCompany(x, y, tileData, uid, sector, name, symbol) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);
  const info = getTileDataAt(x, y);
  const now = Date.now();

  const companyPrice = info.value * 2;
  const min = parseFloat((companyPrice * 0.7).toFixed(2));
  const max = parseFloat((companyPrice * 2).toFixed(2));
  const randomPrice = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  const updatedTile = {
    type: "company",
    name,
    x,
    y,
    stockSymbol: symbol,
    stockMarketListed: true,
    value: tileData.value * 2,
    level: tileData.level,
    sector,
    employsIDs: [],
    ownerID: uid,
    createdAt: now,
    event: "bigChange",
    eventTimestamp: now,
    stockLastPrice: randomPrice,
    price: companyPrice,
    stockPrice: companyPrice / 10,
    stockMinPrice: min,
    stockMaxPrice: max,
    stockMaxChangePercent: 0.05,
    stockPriceHistory: [companyPrice],
    companyStartedAt: now,
    tileLevelXP: increment(tileData.value),
  };

  const newBankValue = playerData.bank - tileData.value;

await Promise.all([
  updateDoc(tileRef, updatedTile),
  updateDoc(playerRef, {
    bank: newBankValue,
    companiesOwned: arrayUnion(tileId),
    xp: increment(tileData.value),
            securityStrengthXP: increment(tileData.value),
            techStrengthXP: increment(tileData.value),
  })
]);

  playerData.bank = newBankValue;
  playerData.companiesOwned = playerData.companiesOwned || [];
  playerData.companiesOwned.push(tileId);

  showMessageModal(`Company ${name}`,`${name} Symbol: (${symbol}) on the Stock Market in sector '${sector}'
  <br> invite players to work for you... () <br> Manage ${name} <br> ${createButton({
  text: "Manage Company",
  className: "btn manage-company-btn",
  onClick: () => openManageCompanyModal(updatedTile, x, y, playerData)
})} `);
}

async function openManageCompanyModal(company, x, y, playerData) {
  const modalElement = document.getElementById("manageCompanyModal");
  const content = document.getElementById("manageCompanyContent");
  const { name, stockSymbol, sector, level, employsIDs, ownerID, value } = company;

  // Fetch player info if you want to show usernames
  let employeesHtml = "<p>No employees.</p>";
  if (employsIDs && employsIDs.length > 0) {
    const employeeList = await Promise.all(
      employsIDs.map(async uid => {
        const snap = await getDoc(doc(db, "players", uid));
        const data = snap.exists() ? snap.data() : { name: "Unknown" };
        return `
          <li class="list-group-item d-flex justify-content-between align-items-center">
            <span>${data.name || "Unnamed"} (${uid.slice(0, 6)}...)</span>
            <button class="btn btn-sm btn-danger" onclick="fireEmployee('${company.name}', '${uid}')">Fire</button>
          </li>
        `;
      })
    );
    employeesHtml = `<ul class="list-group mb-3">${employeeList.join("")}</ul>`;
  }

  content.innerHTML = `
    <h5 class="mb-2">${name} <small>(${stockSymbol})</small></h5>
    <p><strong>Sector:</strong> ${sector}</p>
    <p><strong>Level:</strong> ${level}</p>
    <p><strong>Owner:</strong> ${ownerID}</p>
    <p><strong>Value:</strong> $${value.toLocaleString()}</p>
    <h6>Employees (${employsIDs.length}):</h6>
    ${employeesHtml}

    <div class="d-grid gap-2">
      <button hidden class="btn btn-primary" onclick="recruitEmployee('${name}')">Recruit</button>
      <button class="btn btn-warning" onclick="upgradeCompany('${x}, ${y}, ${name}')">Upgrade</button>
      <button hidden class="btn btn-info" onclick="inviteToCompany('${name}')">Invite Players</button>
      <button class="btn btn-danger" onclick="sellTile('${name}, ${x}, ${y}, ${playerData}')">Sell Company</button>
    </div>
  `;

  const modal = new bootstrap.Modal(modalElement);
  modal.show();
}



async function fireEmployee(companyName, uid) {
  if (!uid) return;

  const confirmFire = confirm(`Are you sure you want to fire this employee?`);
  if (!confirmFire) return;

  const companyTile = await findTileByCompanyName(companyName);
  if (!companyTile) return alert("Company not found.");

  const tileRef = doc(db, "tiles", companyTile.id);
  const tileSnap = await getDoc(tileRef);

  if (!tileSnap.exists()) return;

  const tileData = tileSnap.data();
  const updatedEmployees = tileData.employsIDs.filter(id => id !== uid);
  await updateDoc(tileRef, { employsIDs: updatedEmployees,  tileLevelXP: increment(100), });

  showMessageModal("Employee Removed", `Employee (${uid.slice(0, 6)}...) has been fired from ${companyName}.`);

  // Refresh modal
  openManageCompanyModal({ ...tileData, name: companyName });
}

async function findTileByCompanyName(name) {
  const q = query(collection(db, "tiles"), where("name", "==", name));
  const snap = await getDocs(q);
  return snap.empty ? null : { id: snap.docs[0].id, ...snap.docs[0].data() };
}

window.fireEmployee = fireEmployee;


async function upgradeCompany(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 1500; // Companies cost more

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade your company.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 2000;

  let companyType = "Startup";
  if (newLevel > 3) companyType = "Tech Firm";
  if (newLevel > 6) companyType = "Enterprise";
  if (newLevel > 10) companyType = "Conglomerate";

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: `${companyType} (Lv ${newLevel})`,
       tileLevelXP: increment(upgradeCost * 1.25),
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost,
      xp: increment(upgradeCost * 1.25), // Slight XP bonus for company upgrades
      securityStrengthXP: increment(upgradeCost * 1.25),
      techStrengthXP: increment(upgradeCost * 1.25),
    })
  ]);

  showMessageModal(`Company upgraded to ${companyType} level ${newLevel}.`);
}
window.upgradeCompany = upgradeCompany;


function initStartCompanyButton() {
  const confirmBtn = document.getElementById("confirmStartCompanyBtn");

  if (!confirmBtn) {
    console.error("‚ùå Button with ID 'confirmStartCompanyBtn' not found.");
    return;
  }

  confirmBtn.addEventListener("click", async () => {
    const sector = document.getElementById("sectorSelect").value;
    const name = document.getElementById("companyNameInput").value.trim();
    const symbol = document.getElementById("stockSymbolInput").value.trim().toUpperCase();

    if (!name || !symbol || symbol.length < 3 || symbol.length > 5 || !/^[A-Z]+$/.test(symbol)) {
      showMessageModal("Please enter a valid company name and a stock symbol (3‚Äì5 uppercase letters).");
      return;
    }

    const x = parseInt(confirmBtn.dataset.selectedTileX, 10);
    const y = parseInt(confirmBtn.dataset.selectedTileY, 10);

    const tileData = await getTileDataAt(x, y);
    const uid = auth.currentUser?.uid;

    if (!uid) {
      alert("User not logged in.");
      return;
    }

    await startCompany(x, y, tileData, uid, sector, name, symbol);

    // Hide the modal
    const modalEl = document.getElementById("startCompanyModal");
    const modalInstance = bootstrap.Modal.getInstance(modalEl);
    modalInstance?.hide();
  });
}
  initStartCompanyButton();



async function purchaseTile(x, y, overrideType = null, shouldMove = false) {
  try {
    const tileInfo = mapData[y]?.[x] || "empty";
    const info = zoneInfo[tileInfo] || zoneInfo.empty;
    const type = overrideType || info.type;

    const uid = auth.currentUser?.uid;
    if (!uid) throw new Error("User not logged in");

    const tileId = `${x}_${y}`;
    const tileRef = doc(db, "tiles", tileId);
    const tileSnap = await getDoc(tileRef);

    let tileData;
    if (tileSnap.exists()) {
      console.log(`üìÑ Loaded existing tile from Firestore at ${tileId}`);
      tileData = tileSnap.data();
    } else {
      console.log(`üÜï Creating new tile at ${tileId}`);
      tileData = info;
    }

    // Tile already owned by another player
    if (tileData.ownerID && tileData.ownerID !== playerData.playerUid) {
      return showMessageModal("Oops!", "Tile already owned by someone else.");
    }

    // Check if player can afford it
    const cost = tileData?.price ?? info.price;
    if (playerData.bank < cost) {
      return showMessageModal("Insufficient Funds", "You don't have enough funds.");
    }

    // Prepare new tile data
    const newValue = info.price + playerData.level * 500;
    const updatedBank = playerData.bank - cost;

    const newTile = {
      ownerID: playerData.userID,
      ownerName: playerData.playerName || 'Player',
      status: "owned",
      note: 'new',
      tileImage: '',
      color: info.color,
      label: info.label,
      type: type,
      icon: info.icon,
      price: shouldMove ? newValue : info.price,
      originalCost: shouldMove ? newValue : info.price,
      income: info.income,
      taxRate: info.taxRate,
      value: info.value,
      forSale: false,
      unlocked: true,
      level: 1,
      x,
      y,
      tileHistory: info,
      tileLevelXP: increment(info.value * 1.25),

    };

const updates = [
  updateDoc(doc(db, "players", playerData.playerUid), {
    bank: updatedBank,
    ...(shouldMove ? { location: [x, y] } : {}),
    ...(type === 'land' ? { landOwned: arrayUnion(tileId) } : {}),
    ...(type === 'company' ? { companiesOwned: arrayUnion(tileId) } : {}),
    xp: increment(info.value * 1.25),
   securityStrengthXP: increment(info.value * 1.25),
    techStrengthXP: increment(info.value * 1.25),
  }),
  setDoc(tileRef, newTile, { merge: true })
];


    await Promise.all(updates);

    // Update local memory/player state
    if (!playerData.landOwned) playerData.landOwned = [];
    if (!playerData.companiesOwned) playerData.companiesOwned = [];

    if (type === 'land' && !playerData.landOwned.includes(tileId)) {
      playerData.landOwned.push(tileId);
    }

    if (type === 'company' && !playerData.companiesOwned.includes(tileId)) {
      playerData.companiesOwned.push(tileId);
    }

    playerData.bank = updatedBank;

    if (shouldMove) {
      playerData.location = [x, y];
      playerX = x;
      playerY = y;
      movePlayerSmoothly(scene, x, y);
    }

    showMessageModal("Success", `You purchased a ${type} tile!`);

  } catch (err) {
    console.error("‚ùå Purchase failed:", err.message);
    showMessageModal("Error", err.message);
  }
}

window.purchaseTile = purchaseTile;



async function getTileDataAt(x, y) {
  try {
    // Get the tile type from mapData
    const tileType = mapData[y]?.[x] || "empty";

    // Get static zone info (default fallback data)
    const defaultInfo = zoneInfo[tileType] || zoneInfo.empty;

    // Get live data from Firestore (tiles collection)
    const tileRef = doc(db, "tiles", `${x}_${y}`);
    const tileSnap = await getDoc(tileRef);

    // If Firestore has data, merge it with static info
    if (tileSnap.exists()) {
      const firestoreData = tileSnap.data();
      return { ...defaultInfo, ...firestoreData, x, y };
    } else {
      // Use default zone info if no Firestore document exists
      return { ...defaultInfo, x, y };
    }

  } catch (error) {
    console.error("Error fetching tile data:", error);
    return { ...zoneInfo.empty, x, y };
  }
}



let ownedTiles = [];///  = [ playerData.companiesOwned playerData.landOwned]; // Loaded from player data

function openOwnedModal() {
        refreshOwnedTiles();

  renderOwnedList();
  console.log("Opening owned assets modal");

  const modalEl = document.getElementById("ownedModal");

  // Try to get existing instance
  let modalInstance = bootstrap.Modal.getInstance(modalEl);

  // If no instance, create one
  if (!modalInstance) {
    modalInstance = new bootstrap.Modal(modalEl);
  }

  modalInstance.show();
}

document.getElementById("openOwnedBtn").addEventListener("click", openOwnedModal);

// Expose to global if needed
window.openOwnedModal = openOwnedModal;



document.getElementById("sortFilter").addEventListener("change", renderOwnedList);

function renderOwnedList() {
  const listEl = document.getElementById("ownedList");
  const sortBy = document.getElementById("sortFilter").value;

  let sorted = [...ownedTiles];
  sorted.sort((a, b) => {
    if (sortBy === "value") return b.value - a.value;
    if (sortBy === "tax") return b.taxRate - a.taxRate;
    return 0;
  });

  listEl.innerHTML = "";

  if (sorted.length === 0) {
    listEl.innerHTML = `<div class="text-center text-muted p-3">
      üèöÔ∏è You don't own any properties yet.
    </div>`;
    return;
  }

  sorted.forEach(tile => {
    const li = document.createElement("li");
    li.innerHTML = `
<div class="d-flex align-items-center mb-3">
    <img id="propertyAvatar" src="${tile.tileImage}" alt="propertyAvatar" class="rounded-circle me-2" width="48" height="48">
    <div>
      <strong>${tile.label}</strong> (${tile.x}, ${tile.y})<br>
      üí∞ Value: $${tile.value} | üìä Tax: ${tile.taxRate}% | üîì ${tile.unlocked ? "Unlocked" : "Locked"}
      <br>
      </div>
      </div>

      <button class="view-btn" data-x="${tile.x}" data-y="${tile.y}">View</button>
      <button class="sell-btn" data-id="${tile.id}">Sell</button>
      <button class="upgrade-btn" data-id="${tile.id}">Upgrade</button>

      <details>
        <summary>More Details</summary>
        <ul style="margin-left:1rem;">
          <li><strong>Type:</strong> ${tile.type || "N/A"}</li>
          <li><strong>Original Cost:</strong> $${tile.originalCost || "N/A"}</li>
          <li><strong>For Sale:</strong> ${tile.forSale ? "Yes" : "No"}</li>
          <li><strong>Income:</strong> $${tile.income || 0}</li>
          <li><strong>Level:</strong> ${tile.level || 1}</li>
          <li><strong>Note:</strong> ${tile.note || ''}</li>

          <li><strong>History:</strong>
            <ul>
              ${(tile.tileHistory || []).map(h => `<li>${h}</li>`).join("") || "<li>No history</li>"}
            </ul>
          </li>
        </ul>
      </details>
    `;
    listEl.appendChild(li);
  });

  attachOwnedListeners();
}

function attachOwnedListeners() {
  document.querySelectorAll(".view-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const x = parseInt(e.target.dataset.x);
      const y = parseInt(e.target.dataset.y);
      centerCameraOnTile(x, y);
      openTileDetails(x, y);
      highlightTile(x, y);
    });
  });

  document.querySelectorAll(".sell-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await sellTile(tileId);
      showMessageModal("Success","Tile sold!");
      refreshOwnedTiles();
    });
  });

  document.querySelectorAll(".upgrade-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await upgradeTile(tileId);
      showMessageModal("Success","Tile upgraded!");
      refreshOwnedTiles();
    });
  });
}

function highlightTile(x, y) {
  // Optional: remove previous highlights
  document.querySelectorAll(".tile-highlight").forEach(el => el.classList.remove("tile-highlight"));

  const tileEl = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
  if (tileEl) tileEl.classList.add("tile-highlight");
}

function centerCameraOnTile(x, y) {
  playerX = x;
  playerY = y;
  drawBoard();
}

function openTileDetails(x, y) {
  const tile = getTileDataAt(x, y); // implement this based on your tile structure
  showTileModal(tile); // your modal function
}


async function upgradeTile(tileId) {
  // Firebase logic to apply upgrades
  const ref = doc(db, "tiles", tileId);
  await updateDoc(ref, { tileLevelXP: increment(100),  });
}

async function refreshOwnedTiles() {
  // Pull owned tiles again
  const snap = await getDocs(query(collection(db, "tiles"), where("ownerID", "==", playerData.playerUid)));
  ownedTiles = snap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
  renderOwnedList();
}


async function sellTile(x, y, playerData) {
  const tile = await getTileDataAt(x, y);
  const tileId = tile.tileId;
  const ref = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

   // Build update payload (merge style)
    const updatePayload = {
      ownerID: null,
      status: "available",
      note: "Sold",
      tileHistory: `${tile.tileHistory || ""} | Sold on ${new Date().toLocaleDateString()}`,
      type: tile.type || "empty",
      ...newData, // allow overrides or additions
    };


  try {
    // Determine which array to remove from
    const isCompany = tile.type === "market" || tile.type === "company"; // adjust types as needed
    const fieldToRemove = isCompany ? "companiesOwned" : "landOwned";

    // Remove from player data and update bank
    await updateDoc(playerRef, {
      [fieldToRemove]: arrayRemove(tileId),
      bank: increment(tile.value || 100), // Default fallback value
      xp: increment(tile.value * 1.2)

    });

   
    
 
    // Update Firestore
    await updateDoc(ref, updatePayload);
    console.log(`Tile ${x},${y} updated successfully.`);
    console.log(`Tile ${tileId} sold and removed from ${fieldToRemove}`);
  } catch (error) {
    console.error("Error selling tile:", error);
  }
}
window.sellTile = sellTile;





function initPlayerRealtimeSync(scene) {
  if (!playerData?.playerUid) {
    console.error("‚ùå playerData.playerUid is missing");
    return;
  }

  console.log("‚úÖ Realtime sync initialized for playerUid:", playerData.playerUid);

  // üîÅ Watch own player document
  const playerRef = doc(db, "players", playerData.playerUid);
  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();

      // Update position and move player sprite if changed
      const pos = data.location;
      if (pos && (pos.x !== playerX || pos.y !== playerY)) {
        playerX = pos.x;
        playerY = pos.y;
        movePlayerSmoothly(scene, playerX, playerY);
      }

      // Merge new data into playerData
      playerData = {
        ...playerData,
        ...data
      };

      // Update UI
      updateStatsUI(data);
    }
  });

  // üîÅ Watch all players collection
  const playersRef = collection(db, "players");
  onSnapshot(playersRef, (querySnapshot) => {
    console.log("üî• Received Firestore snapshot for all players");

    playerState.clear();
    allUsersMap.clear();

    querySnapshot.forEach(doc => {
      const data = doc.data();
      const id = doc.id;

      allUsersMap.set(id, data);

      if (Array.isArray(data.location) && data.location.length === 2) {
        playerState.set(id, {
          playerUid: data.playerUid,
          x: data.location[0],
          y: data.location[1],
          bank: data.bank ?? 0,
          crypto: data.crypto ?? 0,
          level: data.level ?? 0,
          xp: data.xp ?? 0,
          health: data.health ?? 100,
          techStrength: data.techStrength ?? 0,
          securityStrength: data.securityStrength ?? 0,
          ...data
        });

        // Optional: Update self again from collection (if desired)
        if (playerData.playerUid === data.playerUid) {
          updateStatsUI(data);
        }

        console.log("üß† Updated playerState:", Array.from(playerState.entries()));
        renderAllPlayers(scene);
      }
    });
  });
}




let moveTween;

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}
















// Generate a custom progress bar (reusable)
function createProgressBar(id, value, max, label = "", level = 1, symbol = "") {
  const percent = Math.min(100, (value / max) * 100).toFixed(1);
    animateStat(id+'xp', value);

  return `
    <div class="mb-2">
      <div class="d-flex justify-content-between mb-1">
        <small><strong>${symbol} ${label} Lv. ${level}</strong></small>
        <small id='${id}xp'>${value} / ${max}</small>
      </div>
      <div class="custom-progress" >
        <div class="custom-progress-bar bg-info text-white" style="width: ${percent}%;">
          ${percent}%
        </div>
      </div>
    </div>
  `;
}
let state;

function updateStatsUI(state) {
  if (!state) {
    state = playerData;
  }
  const level = state.level?.toString() || "1";
  const levelRules = rules.levels[level];

  document.getElementById("playerAvatar").src = state.avatarUrl || "https://via.placeholder.com/48";
  document.getElementById("playerName").textContent = state.playerName || "Unknown";
  document.getElementById("level").textContent = `${state.level ?? 0}`;
  animateStat("xp", state.xp ?? 0);
  animateStat("bank", state.bank ?? 0, formatCurrency);
  document.getElementById("crypto").textContent = `${state.crypto ?? 5}`;

  const health = Math.max(0, Math.min(100, state.health ?? 100));
  const healthBar = document.getElementById("healthBar");
  if (healthBar) {
    healthBar.style.width = `${health}%`;
    healthBar.textContent = `${health}%`;
    healthBar.classList.toggle("bg-danger", health < 40);
    healthBar.classList.toggle("bg-warning", health >= 40 && health < 70);
    healthBar.classList.toggle("bg-success", health >= 70);
  }

//  document.getElementById("zoneName").innerHTML = `üìç Zone: <span>${mapData[playerY]?.[playerX] || "Unknown"}</span>`;

  const xpStats = document.getElementById("xpStats");
  xpStats.innerHTML =
    createProgressBar("xpBar", state.xp, levelRules.xpToNext, "XP", state.level, "üí∞");

  const securityStats = document.getElementById("securityStats");
  securityStats.innerHTML =
    createProgressBar("securityXPBar", state.securityStrengthXP ?? 0, levelRules.securityStrengthXPToNext, "Security XP", state.securityStrength ?? 1, "üõ°Ô∏è");

  const techStats = document.getElementById("techStats");
  techStats.innerHTML =
    createProgressBar("techXPBar", state.techStrengthXP ?? 0, levelRules.techStrengthXPToNext, "Tech XP", state.techStrength ?? 1, "üß†");

  const tradeStats = document.getElementById("tradeStats");
  tradeStats.innerHTML =
    createProgressBar("tradeBar", state.trades ?? 0, levelRules.tradeLimit, "Trades", state.level ?? 1, "üîÅ");

  tryLevelUp();

  scene.load.on("complete", () => {
    loadingText.setText("Loading Complete!");
  });
}

function formatCurrency(amount) {
  return amount.toLocaleString('en-US', {
    style: 'currency',
    currency: 'USD',
    maximumFractionDigits: 0,
  });
}

function animateStat(id, newValue, formatter = val => val) {
  const el = document.getElementById(id);
  if (!el) return;
  const current = parseInt(el.dataset?.value || el.textContent.replace(/[^\d]/g, ''), 10);
  const target = parseInt(newValue, 10);
  if (current === target) return;

  const duration = 500;
  const stepTime = 30;
  let frame = 0;
  const frames = Math.ceil(duration / stepTime);
  const step = (target - current) / frames;

  const interval = setInterval(() => {
    frame++;
    const val = Math.round(current + step * frame);
    el.textContent = formatter(val);
    el.dataset.value = val;
    if (frame >= frames) {
      clearInterval(interval);
    }
  }, stepTime);
}


document.getElementById("bank").addEventListener("click", () => {
  renderBankLedger();
  new bootstrap.Modal(document.getElementById("bankModal")).show();
});

document.getElementById("tradeStats").addEventListener("click", () => {
  renderStockMarket();
  new bootstrap.Modal(document.getElementById("tradeModal")).show();
});

document.getElementById("heathStats").addEventListener("click", () => {
  openStatModal("Health", `You have ${playerData.health ?? 100}% health.`);
});
document.getElementById("securityStats").addEventListener("click", () => {
  openStatModal("Security Strength", `Security level: ${playerData.securityStrength ?? 1}`);
});
document.getElementById("techStats").addEventListener("click", () => {
  openStatModal("Tech Strength", `Tech power: ${playerData.techStrength ?? 1}`);
});


const predefinedAvatars = [
  { avatarImage: "avatar1", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar1.png" },
  { avatarImage: "avatar2", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar2.png" },
  { avatarImage: "avatar3", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar3.png" },
  { avatarImage: "avatar4", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar4.png" },
  { avatarImage: "avatar5", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar5.png" },
  { avatarImage: "avatar6", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar6.png" },
  { avatarImage: "avatar7", avatarUrl: "https://rw-501.github.io/theGame/game/images/avatars/avatar7.png" },
];


function loadAvatars() {
  const gallery = document.getElementById("avatarGallery");
  gallery.innerHTML = "";

  predefinedAvatars.forEach((avatar, i) => {
    const isSelected = playerData.avatarUrl === avatar.avatarUrl;

    const div = document.createElement("div");
    div.className = "avatar-option text-center";
    div.innerHTML = `
      <div class="avatar-wrapper ${isSelected ? 'selected-avatar' : ''}" onclick="selectAvatar('${avatar.avatarUrl}', '${avatar.avatarImage}', this)">
        <img src="${avatar.avatarUrl}" alt="Avatar ${i}">
        <div class="mt-1 small text-muted">${avatar.avatarImage}</div>
      </div>
    `;
    gallery.appendChild(div);
  });
}

function selectAvatar(url, image, wrapperEl) {
  playerData.avatarUrl = url;
  playerData.avatarImage = image;
  document.getElementById("playerAvatar").src = url;

  // Remove highlight from all
  document.querySelectorAll(".avatar-wrapper").forEach(wrap => {
    wrap.classList.remove("selected-avatar");
  });

  // Highlight selected
  wrapperEl.classList.add("selected-avatar");

  if (auth.currentUser) {
    const playerRef = doc(db, "players", playerData.playerUid);
    updateDoc(playerRef, { avatarUrl: url, avatarImage: image });
  }

  bootstrap.Modal.getInstance(document.getElementById("avatarModal")).hide();
}
window.selectAvatar = selectAvatar; 

// Open avatar modal and load avatars
document.getElementById("playerAvatar").addEventListener("click", () => {
  loadAvatars();
  new bootstrap.Modal(document.getElementById("avatarModal")).show();
});


function calculateTotalTaxes(ownerId) {
  let totalTax = 0;

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const tile = mapData[y][x];

      if (tile?.ownerID === ownerId) {
        const price = tile.value || 0;
        const value = tile.taxRate || 0; // Assume 0.05 for 5% if not set
        totalTax += value * taxRate;
      }
    }
  }

  return totalTax;
}

function calculateTotalIncome(ownerId) {
  let totalIncome = 0;

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const tile = mapData[y][x];

      if (tile?.ownerID === ownerId) {
        const income = tile.income || 0;
        totalIncome += income;
      }
    }
  }

  return totalIncome;
}

function calculateTotalPropertyValue(ownerId) {
  let totalValue = 0;

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const tile = mapData[y][x];

      if (tile?.ownerID === ownerId) {
        const value = tile.value || 0;
        totalValue += value;
      }
    }
  }

  return totalValue;
}



function showPlayerInfo() {
const uid = playerData.playerUid;

const income = calculateTotalIncome(uid);
const value = calculateTotalPropertyValue(uid);
const taxes = calculateTotalTaxes(uid);



  state = playerData;
  const content = `
    <p><strong>Name:</strong> ${state.playerName}</p>
    <p><strong>XP:</strong> ${state.xp}</p>
    <p><strong>Level:</strong> ${state.level}</p>
<hr>
    <p><strong>Bank:</strong> $${state.bank.toLocaleString()}</p>
    <p><strong>Income /hr:</strong> ${income}</p>
    <p><strong>Taxs Owed /hr:</strong> ${taxes}</p>
    <p><strong>Property Value:</strong> ${value}</p>

    <p><strong>Loans:</strong> ${state.loans || 0}</p>
    <hr>
    <p><strong>Trades Left:</strong> ${state.trades}</p>
    <p><strong>Total Trades:</strong> ${state.tradesTotal || 0}</p>

<hr>
    <p><strong>Crypto:</strong> ${state.crypto}</p>
    <p><strong>Zone:</strong> ${zoneInfo[mapData[playerY]?.[playerX]]?.label || 'Unknown'}</p>
    <p><strong>Location:</strong> [${playerX}, ${playerY}]</p>
    <hr>
    <p><strong>Companies Owned:</strong> ${state.companiesOwned?.length || 0}</p>
    <p><strong>Land Owned:</strong> ${state.landOwned?.length || 0}</p>
    <hr>
    <p><strong>Attacks Made:</strong> ${state.attacks || 0}</p>
    <p><strong>Times Attacked:</strong> ${state.attacked || 0}</p>
  `;

  document.getElementById("playerInfoContent").innerHTML = content;

  const modal = new bootstrap.Modal(document.getElementById('playerInfoModal'));
  modal.show();
}


document.getElementById("playerName").addEventListener("click", showPlayerInfo);


const boosts = [
  { id: 'health', label: '‚ù§Ô∏è Health Boost', price: 500 },
  { id: 'security', label: 'üõ°Ô∏è Security Boost', price: 750 },
  { id: 'tech', label: 'üß† Tech Boost', price: 1000 },
  // Add more boosts here easily
];

// Render boost options dynamically
function renderPowerUpStore() {
  const boostList = document.getElementById('boostList');
  boostList.innerHTML = ''; // Clear previous list

  boosts.forEach(boost => {
    const li = document.createElement('li');
    li.className = 'list-group-item d-flex justify-content-between align-items-center';

    li.innerHTML = `
      ${boost.label}
      <button class="btn btn-sm btn-outline-primary" onclick="buyBoost('${boost.id}', ${boost.price})">
        $${boost.price}
      </button>
    `;

    boostList.appendChild(li);
  });
   const modal = new bootstrap.Modal(document.getElementById('levelStoreModal'));
  modal.show();
}

// Called when modal opens
document.getElementById("level").addEventListener("click", renderPowerUpStore);


// Purchase logic (stub, you can add your logic here)
function buyBoost(type, price) {
  if (playerData.bank >= price) {
    playerData.bank -= price;

    if (type === 'health') playerData.health += 50;
    if (type === 'security') playerData.securityStrength += 1;
    if (type === 'tech') playerData.techStrength += 1;

    showMessageModal("Success",`${type} boost purchased!`);
    updatePlayerStats(); // your existing update function
  } else {
    showMessageModal("alert","Not enough bank money!");
  }
}

function renderBankLedger() {

const income = calculateTotalIncome(playerData.playerUid);
const value = calculateTotalPropertyValue(playerData.playerUid);
const taxes = calculateTotalTaxes(playerData.playerUid);


  const ledgerHTML = `
    <p><strong>Balance:</strong> $${(playerData.bank || 0).toLocaleString()}</p>
    <p><strong>Loans:</strong> $${(playerData.loans || 0).toLocaleString()}</p>

    <p><strong>Income /hr:</strong> ${income}</p>
    <p><strong>Taxs Owed /hr:</strong> ${taxes}</p>
    <p><strong>Property Value:</strong> ${value}</p>
    <hr>
    <p><strong>Vault Items:</strong> ${playerData.inventory?.join(", ") || "None"}</p>

  `;
  document.getElementById("bankLedgerContent").innerHTML = ledgerHTML;

}

function renderStockMarket() {
  document.getElementById("stockMarketContent").innerHTML = `
    <p>üìà Stocks coming soon...</p>
    <!-- Add chart, buy/sell buttons here -->
  `;
}

function openStatModal(title, content) {
  document.getElementById("statModalTitle").textContent = title;
  document.getElementById("statModalContent").innerHTML = `<p>${content}</p>`;
  new bootstrap.Modal(document.getElementById("statModal")).show();
}


async function create() {
   scene = this;

  await initializeMap(scene);
  setupMapMovement(scene);
  setupMapInteraction(scene);
}



function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}




function getOwnedTiles(ownerId) {
  const owned = [];

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const tile = mapData[y][x];
      if (tile?.ownerId === ownerId) {
        owned.push({ x, y, ...tile });
      }
    }
  }

  return owned;
}

const tileSpriteMap = new Map(); // Similar to otherPlayerSprites
let tileDataMap; 



// Render other players except local player
function renderAllPlayers(scene) {
  console.log("üé® Rendering All Players...");
  console.log("üßç All Player States:", Array.from(playerState.entries()));

  /*
  for (const [key, sprite] of otherPlayerSprites) {
    if (!playerState.has(key) || key === playerData.playerUid) {
      console.log(`‚ùå Removing sprite for: ${key}`);
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }
*/

  for (const [playerId, pos] of playerState.entries()) {

        console.log(`continue: playerId  ${playerId}, || ${playerState} at (${pos.x}, ${pos.y})`);

   // if (playerId === playerData.playerUid) continue;
    if (!pos || pos.x === undefined || pos.y === undefined) {
      console.warn(`‚ö†Ô∏è Invalid pos for ${playerId}:`, pos);
      continue;
    }

   // console.log(`üßç Drawing ${playerId} at (${pos.x}, ${pos.y})`);

    let sprite = otherPlayerSprites.get(playerId);



    /*
  // Then, check if player is already on that tile
const isOnTile =
  playerData?.playerX === pos.x && playerData?.playerY === pos.y;

if (isOnTile) {
  console.log(`üö´ Skipping render for ${playerId} (already on this tile)`);
  continue;
}
*/
 

  //const avatarKey = playerData?.avatarImage || "avatar1"; // default
 // const avatarImage = scene.add.image(0, -10, avatarKey )


    // Get player data (e.g., from allUsersMap or Firestore cache)
    const otherPlayerData = allUsersMap.get(playerId); 
    const displayName = otherPlayerData?.playerName || "Player";
    const online = otherPlayerData?.online || true;
    const level = otherPlayerData?.level || 1;
    const bank = otherPlayerData?.bank || 1;
    const playersUid = otherPlayerData?.playerUid || 1;

    const securityStrength = otherPlayerData?.securityStrength || 1;
    const techStrength = otherPlayerData?.techStrength || 1;
    const health = otherPlayerData?.health || 100;
    const inCombat = otherPlayerData?.inCombat || false;
    const trainingMode = otherPlayerData?.trainingMode || true;


    console.log("health ", health, " bank ", bank, " playerData.location ",otherPlayerData.location ," X ",pos.x, " Y ",pos.y)

    console.log(`${level}, ${displayName} Drawing: ${playerId} || ${playersUid} || ${playerData.playerUid} at (${pos.x}, ${pos.y})`);




// Create container sprite to hold everything

// Create sprite if it doesn't exist
if (!sprite) {
  sprite = scene.add.container(
    pos.x * TILE_SIZE + TILE_SIZE / 2,
    pos.y * TILE_SIZE + TILE_SIZE / 2
  );

let userHomeImage;

const levelToImageKey = {
  1: "apartment_Lv_1",
  2: "apartment_Lv_2",
  3: "apartment_Lv_3",
  4: "apartment_Lv_4",
  5: "house_Lv_1",
  6: "house_Lv_2",
  7: "house_Lv_3",
  8: "house_Lv_4"
};
// Check if the image is available
if (levelToImageKey[level]) {
  userHomeImage = scene.add.image(0, -10, levelToImageKey[level])
    .setDisplaySize(TILE_SIZE * 0.8, TILE_SIZE * 0.8)
    .setOrigin(0.5);
}

const isLocalPlayer = playersUid === playerData.playerUid;
const nameLabel = isLocalPlayer ? "My Home" : displayName;

const labelPadding = 4;
const labelFontSize = 9;
const labelFontStyle = {
  fontSize: `${labelFontSize}px`,
  color: '#ffffff',
  fontStyle: 'bold',
  align: 'center'
};

// üéñÔ∏è Level Tag
const levelText = scene.add.text(0, 0, `${level}`, labelFontStyle).setOrigin(0.5);
levelText.setWordWrapWidth(TILE_SIZE * 0.8 - labelPadding * 2);

const levelWidth = levelText.width + labelPadding * 2;
const levelHeight = levelText.height + labelPadding * 2;

const levelBg = scene.add.graphics();

const radius = 4;
const left = -levelWidth / 2;
const top = -levelHeight / 2;
const right = levelWidth / 2;
const bottom = levelHeight / 2;

levelBg.fillStyle(0x4444aa, 1);
levelBg.lineStyle(1, 0xffffff, 1);
levelBg.beginPath();


// üîπ Top-left corner (rounded)
levelBg.moveTo(left + radius, top);
levelBg.arc(left + radius, top + radius, radius, Phaser.Math.DegToRad(270), Phaser.Math.DegToRad(180), true);

// üîπ Left side
levelBg.lineTo(left, bottom - radius);

// üîπ Bottom-left corner (rounded)
levelBg.arc(left + radius, bottom - radius, radius, Phaser.Math.DegToRad(180), Phaser.Math.DegToRad(90), true);

// üîπ Bottom side (straight)
levelBg.lineTo(right, bottom);

// üîπ Right side up (straight)
levelBg.lineTo(right, top);

// üîπ Top side back to start
levelBg.lineTo(left + radius, top);

levelBg.closePath();
levelBg.fillPath();
levelBg.strokePath();


// üè† Name/Home Tag
const nameText = scene.add.text(0, 0, nameLabel, labelFontStyle).setOrigin(0.5);
nameText.setWordWrapWidth(TILE_SIZE * 0.8 - labelPadding * 2);

// Optional: increase name container width to feel more balanced
const nameExtraWidth = 0;
const nameWidth = nameText.width + labelPadding * 2 + nameExtraWidth;
const nameHeight = nameText.height + labelPadding * 2;

// Recalculate BEFORE drawing shape
const nameLeft = -nameWidth / 2;
const nameRight = nameWidth / 2;
const nameTop = -nameHeight / 2;
const nameBottom = nameHeight / 2;


const nameBg = scene.add.graphics();
nameBg.fillStyle(0x222222, 1);
nameBg.lineStyle(1, 0xffffff, 1);


nameBg.beginPath();

nameBg.moveTo(nameLeft, nameTop);

// Top-right corner (rounded)
nameBg.lineTo(nameRight - radius, nameTop);
nameBg.arc(nameRight - radius, nameTop + radius, radius, Phaser.Math.DegToRad(270), Phaser.Math.DegToRad(360));

// Right side down
nameBg.lineTo(nameRight, nameBottom - radius);

// Bottom-right corner (rounded)
nameBg.arc(nameRight - radius, nameBottom - radius, radius, Phaser.Math.DegToRad(0), Phaser.Math.DegToRad(90));

// Bottom side (straight to bottom-left)
nameBg.lineTo(nameLeft, nameBottom);

// Left side up (straight)
nameBg.lineTo(nameLeft, nameTop);


nameBg.closePath();
nameBg.fillPath();
nameBg.strokePath();


// üì¶ Combine in container and position at bottom of tile
const labelContainer = scene.add.container(0, TILE_SIZE * 0.35);



// üß† Side-by-side X offset
const levelOffsetX = -nameWidth / 2;
const nameOffsetX = levelOffsetX + levelWidth;


// Both on same horizontal line (Y = 0)
const labelY = 0;

levelBg.setPosition(levelOffsetX, labelY);
levelText.setPosition(levelOffsetX, labelY);
nameBg.setPosition(nameOffsetX, labelY);
nameText.setPosition(nameOffsetX, labelY);



// Add children in order
labelContainer.add([levelBg, levelText, nameBg, nameText]);

// üîß Add to sprite
sprite.add([userHomeImage, labelContainer]);


// Store or render accordingly
  otherPlayerSprites.set(playerId, sprite);
  scene.add.existing(sprite);

// Update sprite position
sprite.setPosition(
  pos.x * TILE_SIZE + TILE_SIZE / 2,
  pos.y * TILE_SIZE + TILE_SIZE / 2
);

}




  }

loadTileDataAndRender(scene);

  console.log("‚úÖ Render Complete. Current Sprites:", Array.from(otherPlayerSprites.keys()));
}



async function loadTileDataAndRender(scene) {
  await loadTileData(); // <- this populates tileDataMap
  if (!tileDataMap) {
    console.error("‚ùå tileDataMap failed to load.");
    return;
  }
  renderAllOwnedTiles(scene); // <- now it's safe to call
}

async function loadTileData() {
  const tilesSnapshot = await getDocs(collection(db, "tiles"));
  tileDataMap = new Map();

  tilesSnapshot.forEach(doc => {
    const data = doc.data();
    tileDataMap.set(doc.id, data);
  });
}


function renderAllOwnedTiles(scene) {
  for (const [tileId, sprite] of tileSpriteMap.entries()) {
    if (!tileDataMap.has(tileId)) {
      console.log(`‚ùå Removing old tile sprite: ${tileId}`);
      sprite.destroy();
      tileSpriteMap.delete(tileId);
    }
  }

  for (const [tileId, tile] of tileDataMap.entries()) {
    const { x, y, icon, level, ownerName, color, label, ownerID, forSale, type } = tile;

    if (x == null || y == null || !ownerID || type == 'home') continue;

    const spriteKey = `${x}_${y}`;

    if (tileSpriteMap.has(spriteKey)) {
      const existing = tileSpriteMap.get(spriteKey);
      existing.setPosition(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
      continue;
    }

    const container = scene.add.container(
      x * TILE_SIZE + TILE_SIZE / 2,
      y * TILE_SIZE + TILE_SIZE / 2
    );

    const border = scene.add.circle(0, 0, TILE_SIZE * 0.4, color || 0x00ff00, 0.2)
      .setStrokeStyle(2, color || 0x00ff00)
      .setDepth(0);

    const iconText = scene.add.text(0, -5, icon || "üè†", {
      fontSize: '16px',
      fontStyle: 'bold',
      color: '#ffffff'
    }).setOrigin(0.5);

    const nameText = scene.add.text(0, TILE_SIZE * 0.25, ownerName || "Owner", {
      fontSize: '10px',
      color: '#cccccc'
    }).setOrigin(0.5);

    container.add([border, iconText, nameText]);

    // üü® For Sale sign
    if (forSale === true) {
      const forSaleText = scene.add.text(TILE_SIZE * 0.25, -TILE_SIZE * 0.25, "üí≤", {
        fontSize: '12px',
        fontStyle: 'bold',
        color: '#ffcc00'
      }).setOrigin(0.5);
      container.add(forSaleText);
    }

    tileSpriteMap.set(spriteKey, container);
  }

  console.log("‚úÖ Tile Render Complete. Tiles drawn:", tileSpriteMap.size);
}

function showMessageModal(title, message) {
  document.getElementById("messageModalTitle").textContent = title;
  document.getElementById("messageModalBody").innerHTML = message;

  const modal = new bootstrap.Modal(document.getElementById('messageModal'));
  modal.show();
   // updateStatsUI();
}

</script>

</body>
</html>
