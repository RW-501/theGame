<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }

    #game-container {
      position: relative;
      margin: auto;
      width: 1000px;
      max-width: 100vw;
      height: 100vh;
      background: #222;
      box-shadow: 0 0 15px #333;
    }

    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }

    .damage-popup {
  position: absolute;
  color: red;
  font-weight: bold;
  animation: floatUp 1.2s ease-out;
}

@keyframes floatUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}

  </style>
</head>
<body>

<div id="game-container"></div>

<div class="info-box" id="statsBox">
  <div>
    💰 Cash: <span id="cash">$0</span> |
    🔁 Trades Left: <span id="trades">2</span> |
    ❤️ Health: <span id="health">100%</span>
  </div>
  <div>
    🛡️ Security: <span id="security">0</span> |
    🧠 Tech Strength: <span id="techStrength">0</span> |
    🪙 Crypto: <span id="crypto">0</span>
  </div>
  <div id="zoneName">📍 Zone: <span>Loading...</span></div>
</div>


<div id="tileTooltip"></div>

<!-- Market Modal -->
<div class="modal fade" id="marketModal" tabindex="-1" aria-labelledby="marketLabel" aria-hidden="true">
  <div class="modal-dialog"><div class="modal-content">
    <div class="modal-header"><h5 class="modal-title">Market</h5></div>
    <div class="modal-body">
      <p>Buy stocks, check prices, and trade.</p>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </div>
  </div></div>
</div>

<!-- Tile Actions Modal -->
<div class="modal fade" id="tileActionModal" tabindex="-1" aria-labelledby="tileActionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="tileActionLabel">Tile Actions</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="tileActionBody">
        <!-- Dynamic content here -->
      </div>
      <div class="modal-footer" id="tileActionFooter">
        <!-- Buttons added dynamically -->
      </div>
    </div>
  </div>
</div>


<!-- ATTACK Modal -->
<div class="modal fade" id="attackModal" tabindex="-1" aria-labelledby="attackLabel" aria-hidden="true">
  <div class="modal-dialog modal-md modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="attackLabel">💣 Attack Panel</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <ul id="attackTargets" class="list-group mb-3" style="max-height: 250px; overflow-y: auto;"></ul>
        <div class="mb-3">
          <label for="attackMethod" class="form-label">Attack Method:</label>
          <select id="attackMethod" class="form-select">
            <option value="brute_force">Brute Force</option>
            <option value="social_engineering">Social Engineering</option>
            <option value="bot_attack">Bot Attack</option>
          </select>
        </div>
        <button id="attackBtn" class="btn btn-danger w-100">Launch Attack</button>
        <div id="attackMessage" class="mt-2 fw-semibold text-danger"></div>
      </div>
    </div>
  </div>
</div>

<!-- HACKER Modal -->
<div class="modal fade" id="hackerModal" tabindex="-1" aria-labelledby="hackerLabel" aria-hidden="true">
  <div class="modal-dialog modal-md modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="hackerLabel">👨‍💻 Hacker Tools</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body text-center">
        <div class="d-grid gap-2 mb-3">
          <button id="spyBtn" class="btn btn-outline-primary">🕵️ Spy</button>
          <button id="corruptBtn" class="btn btn-outline-warning">💼 Corrupt Trade</button>
          <button id="stealBtn" class="btn btn-outline-danger">📂 Steal Data</button>
        </div>
        <div id="hackerStatus" class="fw-bold text-info"></div>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="tileActionModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Tile Action</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="tileActionBody"></div>
      <div class="modal-footer" id="tileActionFooter"></div>
    </div>
  </div>
</div>


<script type="module">
import {  auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import { collection, doc, getDoc, getDocs, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";


// === Game Constants ===
const TILE_SIZE = 64; // was 40
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;
let userData = {};
let playerSprite;
let isMoving = false;
let playerX = 5, playerY = 5; // Default fallback
let graphics, cursors;
let mapData = [];
let otherPlayerSprites = new Map();

let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;

const tileTooltip = document.getElementById("tileTooltip");



const playerState = new Map();

function initializePlayerState(uid) {
  if (!playerState.has(uid)) {
    playerState.set(uid, {
      inCombat: false,
      actionsLeft: 2,
      currentHealth: 100,
        portfolio: {},
  loans: [],
  history: [],
      movesLeft: 3,
      cooldowns: {
        attack: 0,
        dash: 0,
        move: 0
      }
    });
  }
}


// === Zone Metadata ===
const zoneInfo = {
  empty: { color: 0xffffff, label: "Wilderness", icon: "🌲" },
  home: { color: 0x90caf9, label: "Home Base", icon: "🏠" },
  blocked: { color: 0x555555, label: "Blocked Area", icon: "🚧" },
  stock: { color: 0xffd54f, label: "Stock Exchange", icon: "📈" },
zone4: { color: 0x81c784, label: "Finance District (4)", icon: "💸" },
zone3: { color: 0x4db6ac, label: "Finance District (3)", icon: "🏦" },
zone2: { color: 0x4fc3f7, label: "Finance District (2)", icon: "💰" },
zone1: { color: 0x9575cd, label: "Finance District (1)", icon: "🧠" },

};

// === Game Setup ===
const config = {
  type: Phaser.AUTO,
width: window.innerWidth,
height: window.innerHeight,
  parent: "game-container",
  backgroundColor: "#222222",
  scene: { preload, create, update }
};

const game = new Phaser.Game(config);

// === Firebase Login Check ===
onAuthStateChanged(auth, async (user) => {
  if (user) {
    uid = user.uid;

    const userRef = doc(db, "users", uid);
    const snap = await getDoc(userRef);

    if (!snap.exists()) {
      await setDoc(userRef, {
        username: "Player" + Math.floor(Math.random() * 1000),
        trainingMode: true,
        cash: 10000,
        level: 1,
        techStrength: 1,
        security: 1,
        health: 100,
        safe: true,
        location: [5, 5],
        inCombat: false,
        avatar: "1",
        crypto: 5,
        xp: 0
      });
    }

    userData = snap.data() || {};
    const location = userData.location || [5, 5];
    playerX = location[0];
    playerY = location[1];

    // Sync player state from DB
    playerState.inCombat = userData.inCombat || false;
    playerState.currentHealth = userData.health || 100;
    playerState.movesLeft = 3;

    console.log("✅ User loaded:", userData.name || "Unnamed");



  } else {
    await signInAnonymously(auth);
  }
      initializePlayerState(userData);

});

// === Phaser Scene Methods ===
function preload() {
  // Preload assets here if needed
}


async function create() {
  graphics = this.add.graphics();
const cam = this.cameras.main;

  await loadMapFromFirebase();
  drawMap(this);

  // Player sprite: blue circle with white border
  playerSprite = this.add.circle(playerX * TILE_SIZE + TILE_SIZE/2, playerY * TILE_SIZE + TILE_SIZE/2, TILE_SIZE * 0.4, 0x0000ff);
  playerSprite.setStrokeStyle(3, 0xffffff);

  cursors = this.input.keyboard.createCursorKeys();

  this.input.keyboard.on('keydown', (event) => {
    if (isMoving) return;
    switch(event.code) {
      case 'ArrowLeft': tryMove(-1, 0, this); break;
      case 'ArrowRight': tryMove(1, 0, this); break;
      case 'ArrowUp': tryMove(0, -1, this); break;
      case 'ArrowDown': tryMove(0, 1, this); break;
    }
  });

  // Pointer input: click adjacent tile to move
this.input.on('pointerdown', async pointer => {
  if (isMoving) return;

  const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
  const clickedX = Math.floor(worldPoint.x / TILE_SIZE);
  const clickedY = Math.floor(worldPoint.y / TILE_SIZE);


  if (clickedX < 0 || clickedX >= MAP_SIZE || clickedY < 0 || clickedY >= MAP_SIZE) return;

  // Get tile info
  const tileType = mapData[clickedY][clickedX] || "empty";

  // Check if a player is on that tile (other than self)
  let otherPlayerId = null;
if (playerState && typeof playerState === "object") {
  const entries = playerState instanceof Map
    ? playerState.entries()
    : Object.entries(playerState);

  for (const [pid, pos] of entries) {
    if (pid !== uid && pos.x === clickedX && pos.y === clickedY) {
      otherPlayerId = pid;
      break;
    }
  }
}


  // Show modal with options based on tile and player presence
  showTileActionModal(clickedX, clickedY, tileType, otherPlayerId);
});


  // Show tile tooltip on pointer move
this.input.on('pointermove', pointer => {
  const cam = this.cameras.main;

  // 🖱️ Drag the map if mouse is down
  if (pointer.isDown) {
    cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
    cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;
    return; // 🛑 Skip tooltip while dragging
  }

  // 🎯 Show tile tooltip when hovering
  const worldPoint = cam.getWorldPoint(pointer.x, pointer.y);
  const x = Math.floor(worldPoint.x / TILE_SIZE);
  const y = Math.floor(worldPoint.y / TILE_SIZE);

  if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
    const zoneType = mapData[y]?.[x] || "empty";
    const info = zoneInfo[zoneType] || zoneInfo.empty;

    tileTooltip.style.left = (pointer.x + 15) + "px";
    tileTooltip.style.top = (pointer.y + 15) + "px";
    tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
    tileTooltip.style.display = "block";
  } else {
    tileTooltip.style.display = "none";
  }
});


  this.input.on('pointerout', () => {
    tileTooltip.style.display = "none";
  });



  // Setup camera bounds and initial zoom
cam.setBounds(0, 0, MAP_SIZE * TILE_SIZE, MAP_SIZE * TILE_SIZE);
cam.startFollow(playerSprite, true, 0.1, 0.1);
cam.setZoom(1);

// Enable drag (click & hold) to pan
this.input.on('pointermove', pointer => {
  if (!pointer.isDown) return;
  cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
  cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;
}, this);

// Mouse wheel to zoom
this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
  const newZoom = Phaser.Math.Clamp(cam.zoom - deltaY * 0.001, 0.5, 2);
  cam.setZoom(newZoom);
});

  /*
      case "attack":
      loadAttackTargets();
      new bootstrap.Modal(document.getElementById("attackModal")).show();
      break;
    case "hacker":
      setupHackerPanel();
      new bootstrap.Modal(document.getElementById("hackerModal")).show();
      break;


      
// ====== ATTACK ======
async function loadAttackTargets() {
  document.getElementById("attackMessage").textContent = "";
  const playersSnap = await getDocs(collection(db, "players"));
  playersList = [];
  playersSnap.forEach(doc => {
    const data = doc.data();
    if (doc.id !== uid) { // exclude current player
      playersList.push({ id: doc.id, name: data.name || "Unnamed", security: data.security || 1 });
    }
  });

  renderAttackTargets();
}

function renderAttackTargets() {
  const attackTargetsEl = document.getElementById("attackTargets");
  attackTargetsEl.innerHTML = "";
  playersList.forEach(player => {
    const li = document.createElement("li");
    li.className = "list-group-item d-flex justify-content-between align-items-center";
    li.textContent = `${player.name} (Security: ${player.security})`;
    li.style.cursor = "pointer";
    li.onclick = () => {
      selectedAttackTarget = player;
      // highlight selected
      Array.from(attackTargetsEl.children).forEach(child => child.classList.remove("active"));
      li.classList.add("active");
    };
    attackTargetsEl.appendChild(li);
  });
}

document.getElementById("attackBtn").addEventListener("click", async () => {
  if (!selectedAttackTarget) {
    document.getElementById("attackMessage").textContent = "Select a target first.";
    return;
  }

  const method = document.getElementById("attackMethod").value;
  // For example, attacks are logged in a collection "attacks"
  const attackDoc = {
    attacker: uid,
    target: selectedAttackTarget.id,
    method,
    timestamp: new Date()
  };

  try {
    await setDoc(doc(collection(db, "attacks")), attackDoc);
    document.getElementById("attackMessage").textContent = `Attack launched against ${selectedAttackTarget.name} using ${method}.`;
  } catch (err) {
    document.getElementById("attackMessage").textContent = "Failed to launch attack: " + err.message;
  }
});

// ====== HACKER ======
function setupHackerPanel() {
  document.getElementById("hackerStatus").textContent = "";
}

document.getElementById("spyBtn").addEventListener("click", () => {
  performHackAction("spy");
});

document.getElementById("corruptBtn").addEventListener("click", () => {
  performHackAction("corrupt_trade");
});

document.getElementById("stealBtn").addEventListener("click", () => {
  performHackAction("steal_data");
});

async function performHackAction(action) {
  // Dummy cooldown + success simulation
  const hackerStatus = document.getElementById("hackerStatus");
  hackerStatus.textContent = `Performing ${action}...`;

  // Simulate delay
  await new Promise(r => setTimeout(r, 1500));

  // Success chance based on player techStrength and security, just an example
  const successChance = playerData.techStrength / (playerData.security + 1);
  const success = Math.random() < successChance;

  if (success) {
    hackerStatus.textContent = `${action} succeeded!`;
    // Record hack event in Firestore, e.g. in "hacks" collection
    await setDoc(doc(collection(db, "hacks")), {
      user: uid,
      action,
      success,
      timestamp: new Date()
    });
  } else {
    hackerStatus.textContent = `${action} failed. Try again later.`;
  }
}


      */
     


// === Tile Modal ===
async function showTileActionModal(x, y, tileType, otherPlayerId) {
  const modalEl = document.getElementById("tileActionModal");
  const modalBody = document.getElementById("tileActionBody");
  const modalFooter = document.getElementById("tileActionFooter");

  modalBody.innerHTML = `<p><strong>Coordinates:</strong> (${x}, ${y})</p>`;
  modalBody.innerHTML += `<p><strong>Tile Type:</strong> ${zoneInfo[tileType]?.label || "Unknown"}</p>`;
  modalFooter.innerHTML = "";


  if (tileType === "wilderness") {
    // Add "Move Here" button
    const moveBtn = document.createElement("button");
    moveBtn.className = "btn btn-success";
    moveBtn.innerText = "Move Here (Purchase)";
    moveBtn.onclick = async () => {
      await handleMoveAndPurchase(x, y);
      const modalInstance = bootstrap.Modal.getInstance(modalEl);
      if (modalInstance) modalInstance.hide(); // Close modal
    };
    modalFooter.appendChild(moveBtn);
        
    return new bootstrap.Modal(modalEl).show();
  }

  const now = Date.now();


      if (tileType === "blocked") {
    modalBody.innerHTML += "<p>This area is blocked. No actions available.</p>";
    return new bootstrap.Modal(modalEl).show();
  }
  const isInCombat = playerState.inCombat;
  const hasActions = playerState.actionsLeft > 0;

  function isOnCooldown(action) {
    return playerState.cooldowns[action] && playerState.cooldowns[action] > now;
  }

  function cooldownLeft(action) {
    return isOnCooldown(action) ? Math.ceil((playerState.cooldowns[action] - now) / 1000) : 0;
  }



  // === Player tile ===
  if (otherPlayerId) {
    const otherSnap = await getDoc(doc(db, "users", otherPlayerId));
    const data = otherSnap.exists() ? otherSnap.data() : {};
    const info = {
      username: data.username ?? otherPlayerId.substring(0, 6),
      health: data.health ?? "??",
      level: data.level ?? "?",
      techStrength: data.techStrength ?? "?",
      security: data.security ?? "?",
    };

    modalBody.innerHTML += `
      <p>Player <strong>${info.username}</strong> is here.</p>
      <p>Health: ${info.health}</p>
      <p>Level: ${info.level}</p>
      <p>Tech Strength: ${info.techStrength}</p>
      <p>Security: ${info.security}</p>
    `;

    // === Attack Button ===
    const attackBtn = createButton(
      `Attack${isOnCooldown("attack") ? ` (${cooldownLeft("attack")}s)` : ""}`,
      "btn-danger",
      async () => {
        if (isInCombat || !hasActions || isOnCooldown("attack")) return;
        await performAttack(otherPlayerId);
        bootstrap.Modal.getInstance(modalEl).hide();
      }
    );
    attackBtn.disabled = isInCombat || !hasActions || isOnCooldown("attack");
    modalFooter.appendChild(attackBtn);

    // === Talk Button ===
    const talkBtn = createButton("Talk", "btn-primary", () => {
      alert(`Talking to ${info.username}...`);
      bootstrap.Modal.getInstance(modalEl).hide();
    });
    talkBtn.disabled = isInCombat;
    modalFooter.appendChild(talkBtn);
  }

  // === Move Button ===
  if (isAdjacent(playerX, playerY, x, y)) {
    const moveBtn = createButton(
      `Move Here${isOnCooldown("move") ? ` (${cooldownLeft("move")}s)` : ""}`,
      "btn-success",
      async () => {
        if (isInCombat || !hasActions || isOnCooldown("move")) return;
        await tryMove(x - playerX, y - playerY, game.scene.scenes[0]);
        bootstrap.Modal.getInstance(modalEl).hide();
      }
    );
    moveBtn.disabled = isInCombat || !hasActions || isOnCooldown("move");
    modalFooter.appendChild(moveBtn);
  }

  new bootstrap.Modal(modalEl).show();
}

// === Attack Flow ===
async function performAttack(targetPlayerId) {
  if (!playerState.actionsLeft || playerState.inCombat) return;

  playerState.inCombat = true;
  playerState.actionsLeft--;
  playerState.cooldowns.attack = Date.now() + 10000;

  await setDoc(doc(db, "users", uid), {
    inCombat: true,
    actionsLeft: playerState.actionsLeft,
    cooldowns: playerState.cooldowns
  }, { merge: true });

  await handleCombat(uid, targetPlayerId);

  setTimeout(async () => {
    playerState.inCombat = false;
    await setDoc(doc(db, "users", uid), { inCombat: false }, { merge: true });
  }, 15000);
}

// === Combat Logic ===
function calculateDamage(attacker, defender) {
  const atk = attacker.attack ?? 5;
  const def = defender.defense ?? 2;
  return Math.max(1, atk - def + Math.floor(Math.random() * 3));
}

async function handleCombat(attackerId, defenderId) {
  const attackerRef = doc(db, "players", attackerId);
  const defenderRef = doc(db, "players", defenderId);

  const [attackerSnap, defenderSnap] = await Promise.all([
    getDoc(attackerRef), getDoc(defenderRef)
  ]);

  if (!attackerSnap.exists() || !defenderSnap.exists()) return;

  const attacker = attackerSnap.data();
  const defender = defenderSnap.data();

  const damage = calculateDamage(attacker, defender);
  const newHp = Math.max((defender.hp ?? 10) - damage, 0);

  await updateDoc(defenderRef, {
    hp: newHp,
    lastDamagedBy: attackerId,
    lastCombat: serverTimestamp()
  });

  showCombatAnimation(attackerId, defenderId, damage);
  updateCombatUI(attacker, { ...defender, hp: newHp });

  if (newHp === 0) {
    await updateDoc(defenderRef, { status: "defeated" });
    alert(`${attacker.name ?? "Player"} defeated ${defender.name ?? "Enemy"}!`);
  }
}

// === Combat UI + Animation ===
function showCombatAnimation(attackerId, defenderId, damage) {
  const scene = game.scene.scenes[0];
  const targetGraphics = scene.add.graphics();
  targetGraphics.lineStyle(3, 0xff0000, 1);
  targetGraphics.strokeRect(playerX * TILE_SIZE, playerY * TILE_SIZE, TILE_SIZE, TILE_SIZE);

  setTimeout(() => targetGraphics.destroy(), 500);

    const tile = document.querySelector(`[data-player-id="${defender.id}"]`);
  if (!tile) return;

  const dmg = document.createElement("div");
  dmg.className = "damage-popup";
  dmg.innerText = `-${damage} HP`;
  tile.appendChild(dmg);

  setTimeout(() => dmg.remove(), 1200);
}

function updateCombatUI(attacker, defender) {
  const attackerEl = document.getElementById(`${attacker.id}-hp`);
  const defenderEl = document.getElementById(`${defender.id}-hp`);
  if (attackerEl) attackerEl.textContent = attacker.hp;
  if (defenderEl) defenderEl.textContent = defender.hp;

  const isDisabled = attacker.inCombat || attacker.actionsLeft <= 0;
  document.querySelectorAll(".action-button").forEach(btn => {
    btn.disabled = isDisabled;
  });
  setInterval(() => updateActionButtons(currentPlayer), 1000);

}

function updateActionButtons(player) {
  const buttons = document.querySelectorAll(".action-btn");
  const inCombat = player.inCombat;
  const onCooldown = player.cooldown && player.cooldown > Date.now();

  buttons.forEach(btn => {
    btn.disabled = inCombat || onCooldown;
  });
}

// === Move Logic ===
async function tryMove(dx, dy, scene) {
  if (playerState.inCombat || playerState.actionsLeft <= 0) return;

  const now = Date.now();
  if (playerState.cooldowns.move && playerState.cooldowns.move > now) {
    alert(`Move cooldown active. Wait ${Math.ceil((playerState.cooldowns.move - now) / 1000)}s.`);
    return;
  }

  const newX = Phaser.Math.Clamp(playerX + dx, 0, MAP_SIZE - 1);
  const newY = Phaser.Math.Clamp(playerY + dy, 0, MAP_SIZE - 1);
  if (mapData[newY]?.[newX] === "blocked") return alert("Blocked tile!");

  function applyTileEffects(x, y) {
    const zone = mapData[y][x];
    if (zone === "stock") {
      playerData.stockTradeDiscount = 0.25;
      console.log("📈 Stock trading fees reduced!");
    } else if (zone?.startsWith("zone")) {
      const bonusTier = parseInt(zone.replace("zone", ""));
      playerData.movementCost = bonusTier;
      console.log(`🧭 Zone bonus tier ${bonusTier}: movement cost increased.`);
    } else {
      playerData.stockTradeDiscount = 0;
      playerData.movementCost = 1;
    }
  }

  isMoving = true;
  await movePlayerSmoothly(scene, newX, newY);
  playerX = newX;
  playerY = newY;
  applyTileEffects(playerX, playerY); // ✅ FIXED
  updateZoneName();

  await handleZoneEvent(mapData[playerY]?.[playerX]);

  try {
    await setDoc(doc(db, "players", uid), {
      position: { x: playerX, y: playerY },
      updatedAt: new Date().toISOString()
    }, { merge: true });

    playerState.actionsLeft--;
    playerState.cooldowns.move = now + 5000;

    await setDoc(doc(db, "users", uid), {
      actionsLeft: playerState.actionsLeft,
      cooldowns: playerState.cooldowns
    }, { merge: true });
  } catch (err) {
    console.error("Error saving player move:", err);
  }

  isMoving = false;
}

async function handleMoveAndPurchase(x, y) {
  try {
    console.log(`Purchasing tile at (${x}, ${y})...`);

    const user = firebase.auth().currentUser;
    if (!user) {
      throw new Error("User not logged in");
    }

    const userRef = doc(db, "users", user.uid);
    const tileRef = doc(db, "tiles", `${x}_${y}`);

    const [userSnap, tileSnap] = await Promise.all([
      getDoc(userRef),
      getDoc(tileRef)
    ]);

    if (!userSnap.exists()) throw new Error("User data not found");
    if (!tileSnap.exists()) throw new Error("Tile data not found");

    const userData = userSnap.data();
    const tileData = tileSnap.data();

    // Check if already owned
    if (tileData.owner && tileData.owner !== user.uid) {
      alert("Tile already owned by someone else.");
      return;
    }

    const cost = tileData.price || 100;

    if (userData.balance < cost) {
      alert("Not enough funds to purchase tile.");
      return;
    }

    // Deduct funds and update tile ownership
    await Promise.all([
      updateDoc(userRef, {
        balance: userData.balance - cost
      }),
      updateDoc(tileRef, {
        owner: user.uid,
        type: "owned", // optional: update type
        ownerName: userData.displayName || user.email
      })
    ]);

    console.log(`Tile at (${x}, ${y}) successfully purchased!`);
    alert("Purchase successful!");
    // Optional: update UI
  } catch (error) {
    console.error("Purchase failed:", error.message);
    alert("Failed to purchase tile: " + error.message);
  }
}


// === Stats UI ===
function updateStatsUI() {
    const state = playerState.get(uid);
  if (!state || !state.cooldowns) {
    console.warn("Missing player state or cooldowns for UID:", uid);
    return;
  }
  const now = Date.now();
  const attackCD = Math.max(0, Math.ceil(((state.cooldowns.attack ?? 0) - now) / 1000));
  const moveCD = Math.max(0, Math.ceil(((state.cooldowns.move ?? 0) - now) / 1000));

  document.getElementById("cash").textContent = `$${playerState.cash ?? 0}`;
  document.getElementById("trades").textContent = playerState.actionsLeft ?? 0;
  document.getElementById("health").textContent = `${playerState.health ?? 100}%`;
  document.getElementById("security").textContent = `${playerState.security ?? 100}%`;
  document.getElementById("techStrength").textContent = `${playerState.techStrength ?? 100}%`;
  document.getElementById("crypto").textContent = `${playerState.crypto ?? 5}`;
/*
    document.getElementById("combatLog").innerHTML = `
    <p><strong>${playerState.name}</strong> hit <strong>${defender.name}</strong> for <strong>${playerState.lastDamage || 0}</strong> damage.</p>
    <p>${defender.name} has ${defender.hp} HP left.</p>
  `;
  */
  document.getElementById("zoneName").textContent =
    `Zone: ${zoneInfo[mapData[playerY]?.[playerX]]?.label || "Unknown"} | Attack CD: ${attackCD}s | Move CD: ${moveCD}s`;
}
setInterval(updateStatsUI, 1000);

// === Helper ===
function createButton(text, btnClass, onClick) {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = `btn ${btnClass} me-2`;
  btn.textContent = text;
  btn.onclick = onClick;
  return btn;
}

  // Listen for own player position changes
  const playerRef = doc(db, "players", uid);
  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const pos = docSnap.data().position;
      if (pos && (pos.x !== playerX || pos.y !== playerY)) {
        playerX = pos.x;
        playerY = pos.y;
        movePlayerSmoothly(this, playerX, playerY);
        updateZoneName();
      }
    }
  });

  // Listen for all players data to show other players
  const playersCollection = collection(db, "players");
  onSnapshot(playersCollection, (querySnapshot) => {
    playerState.clear();
    querySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.position) {
        playerState.set(doc.id, data.position);
      }
    });
    renderAllPlayers(this);
  });

  this.cameras.main.setBounds(0, 0, MAP_SIZE * TILE_SIZE, MAP_SIZE * TILE_SIZE);
this.cameras.main.startFollow(playerSprite, true, 0.1, 0.1);
this.input.on('pointermove', function (pointer) {
  if (!pointer.isDown) return;
  this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x);
  this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y);
}, this);

  updateZoneName();
}

function update() {
  // nothing needed here for now
}

function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}

function drawMap(scene) {
  graphics.clear();
for (let y = 0; y < MAP_SIZE; y++) {
  for (let x = 0; x < MAP_SIZE; x++) {
    const zoneType = mapData[y][x] || "empty";
    const info = zoneInfo[zoneType] || zoneInfo.empty;

    graphics.fillStyle(info.color, 1);
    graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

    scene.add.text(
      x * TILE_SIZE + TILE_SIZE/2,
      y * TILE_SIZE + TILE_SIZE/2,
      info.icon,
      { font: `${TILE_SIZE * 0.5}px Arial`, align: 'center' }
    ).setOrigin(0.5);
    //         setTimeout(() => info.destroy(), 5000);

  }
}

}

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}

function updateZoneName() {
  const zoneType = mapData[playerY]?.[playerX] || "empty";
  const label = zoneInfo[zoneType]?.label || "Unknown";
  document.getElementById("zoneName").textContent = `Zone: ${label}`;
}

async function handleZoneEvent(zoneType) {
  if (!zoneType) return;

  switch(zoneType) {
    case "market":
      new bootstrap.Modal(document.getElementById("marketModal")).show();
      break;
    case "training":
      alert("🎯 You have entered the Training Center! Time to improve your skills.");
      break;
    case "safe":
      alert("🛡️ You are in a Safe House. Take a moment to rest.");
      break;
    case "home":
      // Redirect on clicking the home tile is handled by icon click, but also do here on arrival:
      if (confirm("Welcome home! Do you want to go to your platform?")) {
        window.location.href = platformURL;
      }
      break;
    default:
      // wilderness or others: no special action
      break;
  }
}

async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  // Initialize the map with "empty" tiles
  mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

  const stockX = 12;
  const stockY = 12;
  mapData[stockY][stockX] = "stock";

  // Surrounding bonus zones
  for (let y = stockY - 2; y <= stockY + 2; y++) {
    for (let x = stockX - 2; x <= stockX + 2; x++) {
      if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) continue;
      if (x === stockX && y === stockY) continue;
      const dist = Math.max(Math.abs(x - stockX), Math.abs(y - stockY));
      mapData[y][x] = `zone${5 - dist}`; // zone4, zone3, etc.
    }
  }
}




// Render other players except local player
function renderAllPlayers(scene) {
  // Remove old sprites no longer in playerState
  for (const [key, sprite] of otherPlayerSprites) {
    if (!playerState.has(key) || key === uid) {
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }

  // Draw other players as red circles with initials
  for (const [playerId, pos] of playerState.entries()) {
    if (playerId === uid) continue;
    if (!pos) continue;

    let sprite = otherPlayerSprites.get(playerId);
    if (!sprite) {
      // Create a container with red circle and initials text
      sprite = scene.add.container(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);

      const circle = scene.add.circle(0, 0, TILE_SIZE * 0.4, 0xff4444);
      circle.setStrokeStyle(2, 0xffffff);

      const initials = scene.add.text(0, 0, playerId.substring(0, 2).toUpperCase(), {
        fontSize: '16px',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      sprite.add([circle, initials]);
      otherPlayerSprites.set(playerId, sprite);
    } else {
      sprite.setPosition(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);
    }
  }
}

</script>

</body>
</html>
