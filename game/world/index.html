<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }

    #game-container {
      position: relative;
      margin: auto;
      width: 1000px;
      max-width: 100vw;
      height: 100vh;
      background: #222;
      box-shadow: 0 0 15px #333;
    }

    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }

    .damage-popup {
  position: absolute;
  color: red;
  font-weight: bold;
  animation: floatUp 1.2s ease-out;
}

@keyframes floatUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}

  </style>
</head>
<body>

<div id="game-container"></div>

<div class="info-box" id="statsBox">
  üí∞ <span id="cash">$0</span> |
  üîÅ Trades Left: <span id="trades">2</span> |
  ‚ù§Ô∏è <span id="health">100%</span>
  <div id="zoneName">Zone: Loading...</div>
</div>

<div id="tileTooltip"></div>

<!-- Market Modal -->
<div class="modal fade" id="marketModal" tabindex="-1" aria-labelledby="marketLabel" aria-hidden="true">
  <div class="modal-dialog"><div class="modal-content">
    <div class="modal-header"><h5 class="modal-title">Market</h5></div>
    <div class="modal-body">
      <p>Buy stocks, check prices, and trade.</p>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </div>
  </div></div>
</div>

<!-- Tile Actions Modal -->
<div class="modal fade" id="tileActionModal" tabindex="-1" aria-labelledby="tileActionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="tileActionLabel">Tile Actions</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="tileActionBody">
        <!-- Dynamic content here -->
      </div>
      <div class="modal-footer" id="tileActionFooter">
        <!-- Buttons added dynamically -->
      </div>
    </div>
  </div>
</div>


<script type="module">
import { initializeFirebase, auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import { collection, doc, getDoc, getDocs, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

initializeFirebase();

const TILE_SIZE = 40;
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;

onAuthStateChanged(auth, async (user) => {
  if (user) {
    uid = user.uid;

    const userRef = doc(db, "users", uid);
    const snap = await getDoc(userRef);
    if (!snap.exists()) {
      await setDoc(userRef, {
        username: "Player" + Math.floor(Math.random() * 1000),
        trainingMode: true,
        cash: 10000,
        level: 1,
        techStrength: 1,
        security: 1,
        health: 100,
        assets: { car: 0, home: 0 },
        safe: true,
        location: [5, 5],

      });
    }
  } else {
    await signInAnonymously(auth);
  }
});


const playerState = {
            inCombat: false,
  actionsLeft: 2,
  
  currentHealth: 75,
  isInCombat: true,
  movesLeft: 0,
  cooldowns: {
    attack: 3,
    dash: 0,
    moves
  },
};

// Zone colors and icons (use emojis for fun)
const zoneInfo = {
  empty: { color: 0xffffff, label: "Wilderness", icon: "üå≤" },
  home: { color: 0x90caf9, label: "Home Base", icon: "üè†" },
  market: { color: 0xa5d6a7, label: "Market", icon: "üõí" },
  training: { color: 0xffcc80, label: "Training Center", icon: "üéØ" },
  safe: { color: 0xce93d8, label: "Safe House", icon: "üõ°Ô∏è" },
  blocked: { color: 0x555555, label: "Blocked Area", icon: "üöß" }
};

let mapData = []; // 2D array [y][x] = zoneType
let playersData = new Map();

const config = {
  type: Phaser.AUTO,
  width: TILE_SIZE * MAP_SIZE,
  height: TILE_SIZE * MAP_SIZE,
  parent: "game-container",
  backgroundColor: "#222222",
  scene: {
    preload,
    create,
    update
  }
};

let playerX = 0, playerY = 0;
let playerSprite;
let graphics;
let cursors;
let otherPlayerSprites = new Map();
let isMoving = false;
let moveTween;
let tileTooltip = document.getElementById("tileTooltip");

const game = new Phaser.Game(config);

function preload() {
  // load any assets here if you want later
}

async function create() {
  graphics = this.add.graphics();

  await loadMapFromFirebase();
  drawMap(this);

  // Player sprite: blue circle with white border
  playerSprite = this.add.circle(playerX * TILE_SIZE + TILE_SIZE/2, playerY * TILE_SIZE + TILE_SIZE/2, TILE_SIZE * 0.4, 0x0000ff);
  playerSprite.setStrokeStyle(3, 0xffffff);

  cursors = this.input.keyboard.createCursorKeys();

  this.input.keyboard.on('keydown', (event) => {
    if (isMoving) return;
    switch(event.code) {
      case 'ArrowLeft': tryMove(-1, 0, this); break;
      case 'ArrowRight': tryMove(1, 0, this); break;
      case 'ArrowUp': tryMove(0, -1, this); break;
      case 'ArrowDown': tryMove(0, 1, this); break;
    }
  });

  // Pointer input: click adjacent tile to move
this.input.on('pointerdown', async pointer => {
  if (isMoving) return;
  const clickedX = Math.floor(pointer.x / TILE_SIZE);
  const clickedY = Math.floor(pointer.y / TILE_SIZE);

  if (clickedX < 0 || clickedX >= MAP_SIZE || clickedY < 0 || clickedY >= MAP_SIZE) return;

  // Get tile info
  const tileType = mapData[clickedY][clickedX] || "empty";

  // Check if a player is on that tile (other than self)
  let otherPlayerId = null;
  for (const [pid, pos] of playersData.entries()) {
    if (pid !== uid && pos.x === clickedX && pos.y === clickedY) {
      otherPlayerId = pid;
      break;
    }
  }

  // Show modal with options based on tile and player presence
  showTileActionModal(clickedX, clickedY, tileType, otherPlayerId);
});


  // Show tile tooltip on pointer move
  this.input.on('pointermove', pointer => {
    const x = Math.floor(pointer.x / TILE_SIZE);
    const y = Math.floor(pointer.y / TILE_SIZE);
    if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
      const zoneType = mapData[y]?.[x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;
      tileTooltip.style.left = (pointer.x + 15) + "px";
      tileTooltip.style.top = (pointer.y + 15) + "px";
      tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
      tileTooltip.style.display = "block";
    } else {
      tileTooltip.style.display = "none";
    }
  });

  this.input.on('pointerout', () => {
    tileTooltip.style.display = "none";
  });

// === Tile Modal ===
async function showTileActionModal(x, y, tileType, otherPlayerId) {
  const modalEl = document.getElementById("tileActionModal");
  const modalBody = document.getElementById("tileActionBody");
  const modalFooter = document.getElementById("tileActionFooter");

  modalBody.innerHTML = `<p><strong>Coordinates:</strong> (${x}, ${y})</p>`;
  modalBody.innerHTML += `<p><strong>Tile Type:</strong> ${zoneInfo[tileType]?.label || "Unknown"}</p>`;
  modalFooter.innerHTML = "";

  const now = Date.now();
  const isInCombat = playerState.inCombat;
  const hasActions = playerState.actionsLeft > 0;

  function isOnCooldown(action) {
    return playerState.cooldowns[action] && playerState.cooldowns[action] > now;
  }

  function cooldownLeft(action) {
    return isOnCooldown(action) ? Math.ceil((playerState.cooldowns[action] - now) / 1000) : 0;
  }

  if (tileType === "blocked") {
    modalBody.innerHTML += "<p>This area is blocked. No actions available.</p>";
    return new bootstrap.Modal(modalEl).show();
  }

  // === Player tile ===
  if (otherPlayerId) {
    const otherSnap = await getDoc(doc(db, "users", otherPlayerId));
    const data = otherSnap.exists() ? otherSnap.data() : {};
    const info = {
      username: data.username ?? otherPlayerId.substring(0, 6),
      health: data.health ?? "??",
      level: data.level ?? "?",
      techStrength: data.techStrength ?? "?",
      security: data.security ?? "?",
    };

    modalBody.innerHTML += `
      <p>Player <strong>${info.username}</strong> is here.</p>
      <p>Health: ${info.health}</p>
      <p>Level: ${info.level}</p>
      <p>Tech Strength: ${info.techStrength}</p>
      <p>Security: ${info.security}</p>
    `;

    // === Attack Button ===
    const attackBtn = createButton(
      `Attack${isOnCooldown("attack") ? ` (${cooldownLeft("attack")}s)` : ""}`,
      "btn-danger",
      async () => {
        if (isInCombat || !hasActions || isOnCooldown("attack")) return;
        await performAttack(otherPlayerId);
        bootstrap.Modal.getInstance(modalEl).hide();
      }
    );
    attackBtn.disabled = isInCombat || !hasActions || isOnCooldown("attack");
    modalFooter.appendChild(attackBtn);

    // === Talk Button ===
    const talkBtn = createButton("Talk", "btn-primary", () => {
      alert(`Talking to ${info.username}...`);
      bootstrap.Modal.getInstance(modalEl).hide();
    });
    talkBtn.disabled = isInCombat;
    modalFooter.appendChild(talkBtn);
  }

  // === Move Button ===
  if (isAdjacent(playerX, playerY, x, y)) {
    const moveBtn = createButton(
      `Move Here${isOnCooldown("move") ? ` (${cooldownLeft("move")}s)` : ""}`,
      "btn-success",
      async () => {
        if (isInCombat || !hasActions || isOnCooldown("move")) return;
        await tryMove(x - playerX, y - playerY, game.scene.scenes[0]);
        bootstrap.Modal.getInstance(modalEl).hide();
      }
    );
    moveBtn.disabled = isInCombat || !hasActions || isOnCooldown("move");
    modalFooter.appendChild(moveBtn);
  }

  new bootstrap.Modal(modalEl).show();
}

// === Attack Flow ===
async function performAttack(targetPlayerId) {
  if (!playerState.actionsLeft || playerState.inCombat) return;

  playerState.inCombat = true;
  playerState.actionsLeft--;
  playerState.cooldowns.attack = Date.now() + 10000;

  await setDoc(doc(db, "users", uid), {
    inCombat: true,
    actionsLeft: playerState.actionsLeft,
    cooldowns: playerState.cooldowns
  }, { merge: true });

  await handleCombat(uid, targetPlayerId);

  setTimeout(async () => {
    playerState.inCombat = false;
    await setDoc(doc(db, "users", uid), { inCombat: false }, { merge: true });
  }, 15000);
}

// === Combat Logic ===
function calculateDamage(attacker, defender) {
  const atk = attacker.attack ?? 5;
  const def = defender.defense ?? 2;
  return Math.max(1, atk - def + Math.floor(Math.random() * 3));
}

async function handleCombat(attackerId, defenderId) {
  const attackerRef = doc(db, "players", attackerId);
  const defenderRef = doc(db, "players", defenderId);

  const [attackerSnap, defenderSnap] = await Promise.all([
    getDoc(attackerRef), getDoc(defenderRef)
  ]);

  if (!attackerSnap.exists() || !defenderSnap.exists()) return;

  const attacker = attackerSnap.data();
  const defender = defenderSnap.data();

  const damage = calculateDamage(attacker, defender);
  const newHp = Math.max((defender.hp ?? 10) - damage, 0);

  await updateDoc(defenderRef, {
    hp: newHp,
    lastDamagedBy: attackerId,
    lastCombat: serverTimestamp()
  });

  showCombatAnimation(attackerId, defenderId, damage);
  updateCombatUI(attacker, { ...defender, hp: newHp });

  if (newHp === 0) {
    await updateDoc(defenderRef, { status: "defeated" });
    alert(`${attacker.name ?? "Player"} defeated ${defender.name ?? "Enemy"}!`);
  }
}

// === Combat UI + Animation ===
function showCombatAnimation(attackerId, defenderId, damage) {
  const scene = game.scene.scenes[0];
  const targetGraphics = scene.add.graphics();
  targetGraphics.lineStyle(3, 0xff0000, 1);
  targetGraphics.strokeRect(playerX * TILE_SIZE, playerY * TILE_SIZE, TILE_SIZE, TILE_SIZE);

  setTimeout(() => targetGraphics.destroy(), 500);

    const tile = document.querySelector(`[data-player-id="${defender.id}"]`);
  if (!tile) return;

  const dmg = document.createElement("div");
  dmg.className = "damage-popup";
  dmg.innerText = `-${damage} HP`;
  tile.appendChild(dmg);

  setTimeout(() => dmg.remove(), 1200);
}

function updateCombatUI(attacker, defender) {
  const attackerEl = document.getElementById(`${attacker.id}-hp`);
  const defenderEl = document.getElementById(`${defender.id}-hp`);
  if (attackerEl) attackerEl.textContent = attacker.hp;
  if (defenderEl) defenderEl.textContent = defender.hp;

  const isDisabled = attacker.inCombat || attacker.actionsLeft <= 0;
  document.querySelectorAll(".action-button").forEach(btn => {
    btn.disabled = isDisabled;
  });
  setInterval(() => updateActionButtons(currentPlayer), 1000);

}

function updateActionButtons(player) {
  const buttons = document.querySelectorAll(".action-btn");
  const inCombat = player.inCombat;
  const onCooldown = player.cooldown && player.cooldown > Date.now();

  buttons.forEach(btn => {
    btn.disabled = inCombat || onCooldown;
  });
}

// === Move Logic ===
async function tryMove(dx, dy, scene) {
  if (playerState.inCombat || playerState.actionsLeft <= 0) return;

  const now = Date.now();
  if (playerState.cooldowns.move && playerState.cooldowns.move > now) {
    alert(`Move cooldown active. Wait ${Math.ceil((playerState.cooldowns.move - now) / 1000)}s.`);
    return;
  }

  const newX = Phaser.Math.Clamp(playerX + dx, 0, MAP_SIZE - 1);
  const newY = Phaser.Math.Clamp(playerY + dy, 0, MAP_SIZE - 1);
  if (mapData[newY]?.[newX] === "blocked") return alert("Blocked tile!");

  isMoving = true;
  await movePlayerSmoothly(scene, newX, newY);
  playerX = newX;
  playerY = newY;
  updateZoneName();

  await handleZoneEvent(mapData[playerY]?.[playerX]);
  await setDoc(doc(db, "players", uid), {
    position: { x: playerX, y: playerY },
    updatedAt: new Date().toISOString()
  }, { merge: true });

  playerState.actionsLeft--;
  playerState.cooldowns.move = Date.now() + 5000;

  await setDoc(doc(db, "users", uid), {
    actionsLeft: playerState.actionsLeft,
    cooldowns: playerState.cooldowns
  }, { merge: true });

  isMoving = false;
}

// === Stats UI ===
function updateStatsUI() {
  const now = Date.now();
  const attackCD = Math.max(0, Math.ceil(((playerState.cooldowns.attack ?? 0) - now) / 1000));
  const moveCD = Math.max(0, Math.ceil(((playerState.cooldowns.move ?? 0) - now) / 1000));

  document.getElementById("cash").textContent = `$${playerData.cash ?? 0}`;
  document.getElementById("trades").textContent = playerState.actionsLeft ?? 0;
  document.getElementById("health").textContent = `${playerState.health ?? 100}%`;

    document.getElementById("combatLog").innerHTML = `
    <p><strong>${attacker.name}</strong> hit <strong>${defender.name}</strong> for <strong>${attacker.lastDamage || 0}</strong> damage.</p>
    <p>${defender.name} has ${defender.hp} HP left.</p>
  `;
  document.getElementById("zoneName").textContent =
    `Zone: ${zoneInfo[mapData[playerY]?.[playerX]]?.label || "Unknown"} | Attack CD: ${attackCD}s | Move CD: ${moveCD}s`;
}
setInterval(updateStatsUI, 1000);

// === Helper ===
function createButton(text, btnClass, onClick) {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = `btn ${btnClass} me-2`;
  btn.textContent = text;
  btn.onclick = onClick;
  return btn;
}

  // Listen for own player position changes
  const playerRef = doc(db, "players", uid);
  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const pos = docSnap.data().position;
      if (pos && (pos.x !== playerX || pos.y !== playerY)) {
        playerX = pos.x;
        playerY = pos.y;
        movePlayerSmoothly(this, playerX, playerY);
        updateZoneName();
      }
    }
  });

  // Listen for all players data to show other players
  const playersCollection = collection(db, "players");
  onSnapshot(playersCollection, (querySnapshot) => {
    playersData.clear();
    querySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.position) {
        playersData.set(doc.id, data.position);
      }
    });
    renderAllPlayers(this);
  });

  updateZoneName();
}

function update() {
  // nothing needed here for now
}

function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}

function drawMap(scene) {
  graphics.clear();
  for (let y=0; y < MAP_SIZE; y++) {
    for (let x=0; x < MAP_SIZE; x++) {
      const type = mapData[y]?.[x] || "empty";
      const info = zoneInfo[type] || zoneInfo.empty;

      // draw colored tile
      graphics.fillStyle(info.color, 1);
      graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

      // draw tile border
      graphics.lineStyle(2, 0x999999);
      graphics.strokeRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);

      // draw emoji icon centered
      const iconText = scene.add.text(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, info.icon, {
        fontSize: '24px',
        align: 'center'
      });
      iconText.setOrigin(0.5);
      iconText.setDepth(1);

      // make home tile clickable with pointer cursor and interactive
      if (type === "home") {
        iconText.setInteractive({ useHandCursor: true });
        iconText.on('pointerdown', () => {
          window.location.href = platformURL;
        });
        iconText.on('pointerover', () => {
          iconText.setStyle({ fill: '#0000ff', fontStyle: 'bold' });
        });
        iconText.on('pointerout', () => {
          iconText.setStyle({ fill: '#000000', fontStyle: 'normal' });
        });
      }
    }
  }
}

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}

function updateZoneName() {
  const zoneType = mapData[playerY]?.[playerX] || "empty";
  const label = zoneInfo[zoneType]?.label || "Unknown";
  document.getElementById("zoneName").textContent = `Zone: ${label}`;
}

async function handleZoneEvent(zoneType) {
  if (!zoneType) return;

  switch(zoneType) {
    case "market":
      new bootstrap.Modal(document.getElementById("marketModal")).show();
      break;
    case "training":
      alert("üéØ You have entered the Training Center! Time to improve your skills.");
      break;
    case "safe":
      alert("üõ°Ô∏è You are in a Safe House. Take a moment to rest.");
      break;
    case "home":
      // Redirect on clicking the home tile is handled by icon click, but also do here on arrival:
      if (confirm("Welcome home! Do you want to go to your platform?")) {
        window.location.href = platformURL;
      }
      break;
    default:
      // wilderness or others: no special action
      break;
  }
}

async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  mapData = [];
  for(let y=0; y<MAP_SIZE; y++) {
    const row = [];
    for(let x=0; x<MAP_SIZE; x++) {
      if(x === 5 && y === 5) row.push("home");
      else if(x === 10 && y === 8) row.push("market");
      else if(x === 17 && y === 12) row.push("training");
      else if(x === 22 && y === 20) row.push("safe");
      else if(x >= 15 && x <= 18 && y >= 15 && y <= 18) row.push("blocked");
      else row.push("empty");
    }
    mapData.push(row);
  }
}

// Render other players except local player
function renderAllPlayers(scene) {
  // Remove old sprites no longer in playersData
  for (const [key, sprite] of otherPlayerSprites) {
    if (!playersData.has(key) || key === uid) {
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }

  // Draw other players as red circles with initials
  for (const [playerId, pos] of playersData.entries()) {
    if (playerId === uid) continue;
    if (!pos) continue;

    let sprite = otherPlayerSprites.get(playerId);
    if (!sprite) {
      // Create a container with red circle and initials text
      sprite = scene.add.container(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);

      const circle = scene.add.circle(0, 0, TILE_SIZE * 0.4, 0xff4444);
      circle.setStrokeStyle(2, 0xffffff);

      const initials = scene.add.text(0, 0, playerId.substring(0, 2).toUpperCase(), {
        fontSize: '16px',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      sprite.add([circle, initials]);
      otherPlayerSprites.set(playerId, sprite);
    } else {
      sprite.setPosition(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);
    }
  }
}

</script>

</body>
</html>
