<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>
<link rel="icon" type="image/png" href="https://img.icons8.com/external-wanicon-lineal-color-wanicon/64/external-bank-stock-market-wanicon-lineal-color-wanicon.png">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }

#game-container {
  position: relative;
  margin: auto;
  width: fit-content;
  max-width: 100vw;
  height: 90%;
  margin: 5rem;
  overflow: scroll;
  /*
 background: #222;
  box-shadow: 0 0 15px #333;
  */

  canvas {
    margin-bottom: 20rem;
}
}


    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      user-select: none;

    }

    .stats-row {
  margin-bottom: 6px;
  line-height: 1.4;
}

.stats-row:last-child {
  margin-bottom: 0;
  font-weight: bold;
  color: #ffd700; /* Gold color for zone */
}

.info-box span {
  font-weight: 600;
  color: #90caf9;
  padding: 0 3px;
}
    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }

    .damage-popup {
  position: absolute;
  color: red;
  font-weight: bold;
  animation: floatUp 1.2s ease-out;
}

@keyframes floatUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}

:root {
  --accent: #28a745;
  --accent-hover: #218838;
  --bg-dark: #fff;
  --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

#userTool {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-end;
}

#userTool button {
  background-color: var(--accent);
  color: var(--bg-dark);
  padding: 10px 14px;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: var(--shadow);
  transition: background-color 0.3s ease, transform 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
  
    background: rgba(20, 20, 30, 0.95);
    border: 2px solid #4caf50;
    border-radius: 12px;
    box-shadow: 0 0 12px #4caf50cc;
    font-family: 'Orbitron', sans-serif;
    color: #e0e0e0;
}

#userTool button:hover {
  background-color: var(--accent-hover);
  transform: translateY(-2px);
}

#notifBellBtn {
  position: relative;
  background-color: var(--accent);
}

/*
#notifBadge {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: #dc3545;
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 50%;
  display: none;
}

#openChatBtn {
  position: fixed;
  bottom: 90px; 
  right: 20px;
  z-index: 2000;
  padding: 12px 16px;
  border-radius: 50%;
  background: var(--accent);
  color: var(--bg-dark);
  border: none;
  cursor: pointer;
  box-shadow: var(--shadow);
  font-size: 20px;
}

*/


.tile-highlight {
  outline: 3px solid gold;
  z-index: 999;
}



.blink {
  animation: blink-glow 1.2s infinite alternate;
}

@keyframes blink-glow {
  from {
    box-shadow: 0 0 0px transparent;
  }
  to {
    box-shadow: 0 0 8px 3px lime;
  }
}


/* Shared Modal Styles for TileAction and Message Modals */
#manageHomeModal .modal-content,
#tileActionModal .modal-content,
#messageModal .modal-content {
  background: rgba(20, 20, 30, 0.95);
  border: 2px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 0 12px #4caf50cc;
  font-family: 'Orbitron', sans-serif;
  color: #e0e0e0;
}

/* Modal Header */
#manageHomeModal .modal-header,
#tileActionModal .modal-header,
#messageModal .modal-header {
  border-bottom: 1px solid #555;
  background-color: rgba(0, 0, 0, 0.3);
  color: #fff;
}

/* Card inside modal */
#manageHomeModal .card,
#tileActionModal .card,
#messageModal .card {
  background-color: #1f1f2b;
  border: 1px solid #333;
  border-radius: 10px;
  color: #ddd;
}

/* Card Title */
#manageHomeModal .card-title,
#tileActionModal .card-title,
#messageModal .card-title {
  color: #4caf50;
  font-weight: bold;
  font-size: 1.2rem;
}

/* Row Labels */
#manageHomeModal .row strong,
#tileActionModal .row strong,
#messageModal .row strong {
  color: #90caf9;
}

/* Modal Footer Buttons */
#manageHomeModal .modal-footer .btn,
#tileActionModal .modal-footer .btn,
#messageModal .modal-footer .btn {
  border-radius: 8px;
  font-size: 1rem;
  padding: 10px 18px;
  font-weight: 600;
  transition: 0.3s ease;
}

/* Success Button */
#manageHomeModal .btn-success,
#tileActionModal .btn-success,
#messageModal .btn-success {
  background-color: #4caf50;
  border-color: #4caf50;
}

#manageHomeModal .btn-success:hover,
#tileActionModal .btn-success:hover,
#messageModal .btn-success:hover {
  background-color: #66bb6a;
}

/* Text Colors */
#manageHomeModal .text-danger,
#tileActionModal .text-danger,
#messageModal .text-danger {
  color: #e53935 !important;
}

#manageHomeModal .text-success,
#tileActionModal .text-success,
#messageModal .text-success {
  color: #66bb6a !important;
}

@keyframes tileZoomIn {
  0% { transform: scale(1); z-index: 2; }
  50% { transform: scale(1.25); z-index: 5; }
  100% { transform: scale(1); z-index: 2; }
}

@keyframes electricShock {
  0% { box-shadow: 0 0 8px 4px #00f6ff; background-color: rgba(0,255,255,0.2); }
  50% { box-shadow: 0 0 12px 6px #00f6ff; background-color: rgba(0,255,255,0.4); }
  100% { box-shadow: 0 0 8px 4px #00f6ff; background-color: rgba(0,255,255,0.2); }
}

  @keyframes zapEffect {
    0% {
      opacity: 0;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.2);
    }
    100% {
      opacity: 0;
      transform: scale(1);
    }
  }
  .hack-overlay {
    position: absolute;
    width: 64px;
    height: 64px;
    z-index: 1000;
    pointer-events: none;
    animation: zapEffect 0.6s ease-out;
   /* background: url('/assets/electric-shock.gif') center center no-repeat; */
    background-size: cover;
      animation: tileZoomIn 0.6s ease-in-out;
        animation: electricShock 1.2s ease-in-out;


  }


  

.modal {
  z-index: 10000;
}
  </style>
</head>
<body>

  <main>
<div id="mainArea" class="d-flex justify-content-center align-items-center vh-100">
  <div id="game-container"></div>
</div>

<div class="info-box" id="statsBox">
  <div class="stats-row">
    üéñÔ∏è Level: <span id="level">0</span> |
    üí∞ xp: <span id="xp">$0</span> |
    üè¶ Bank: <span id="bank">$0</span> |
    ü™ô Crypto: <span id="crypto">0</span> |
    üîÅ Trades Left: <span id="trades">2</span>
  </div>
  <div class="stats-row">
    ‚ù§Ô∏è Health: <span id="health">100%</span> |
    üõ°Ô∏è Security: <span id="security">0</span> |
    üß† Tech Strength: <span id="techStrength">0</span>
  </div>
  <div class="stats-row" id="zoneName">
    üìç Zone: <span>Loading...</span>
  </div>
</div>

<div id="tileTooltip"></div>


<div id="userTool">
  <button id="returnToLocationBtn">üìç Return to My Location</button>
  <button id="goToPlatformBtn">üåê Go to Platform</button>
  <button id="openOwnedBtn">üì¶ Assets</button>

  <!-- Notification Bell Button -->
  <button id="notifBellBtn" style="box-shadow: none;">
    üîî
    <span id="notifBadge">!</span>
  </button>

  <button id="openChatBtn" title="Open Chat">üí¨</button>

  <!-- Gear Toggle Button -->
  <button id="toggleToolsBtn" title="Toggle Tools" style="margin-top: 8px;">‚öôÔ∏è</button>
</div>



</main>


<!-- Market Modal -->
<div class="modal fade" id="marketModal" tabindex="-1" aria-labelledby="marketLabel" aria-hidden="true">
  <div class="modal-dialog"><div class="modal-content">
    <div class="modal-header"><h5 class="modal-title">Market</h5></div>
    <div class="modal-body">
      <p>Buy stocks, check prices, and trade.</p>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </div>
  </div></div>
</div>

<!-- Tile Actions Modal -->
<div class="modal fade game-modal" id="tileActionModal" tabindex="-1" aria-labelledby="tileActionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="tileActionLabel">Tile Actions</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="tileActionBody">
        <!-- Dynamic content here -->
      </div>
      <div class="modal-footer" id="tileActionFooter">
        <!-- Buttons added dynamically -->
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="tileActionModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Tile Action</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="tileActionBody"></div>
      <div class="modal-footer" id="tileActionFooter"></div>
    </div>
  </div>
</div>


<!-- Message Modal -->
<div class="modal fade game-modal" id="messageModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="messageModalTitle">Message</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="messageModalBody">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>


<!-- Asset Viewer Modal -->
<!-- Owned Assets Modal -->
<div class="modal fade" id="ownedModal" tabindex="-1" aria-labelledby="ownedModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="ownedModalLabel">Your Owned Land & Companies</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <div class="modal-body">
        <div class="mb-3">
          <label for="sortFilter" class="form-label">Sort By:</label>
          <select class="form-select" id="sortFilter">
            <option value="value">Value</option>
            <option value="taxRate">Tax Rate</option>
          </select>
        </div>

        <ul id="ownedList" class="list-group">
          <!-- Dynamically generated list items will be injected here -->
        </ul>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="startCompanyModal" tabindex="-1" aria-labelledby="startCompanyLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
    
      <div class="modal-header">
        <h5 class="modal-title" id="startCompanyLabel">Start a Company</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="modal-body">
        <label for="sectorSelect">Choose a Sector:</label>
        <select class="form-select mb-3" id="sectorSelect">
          <option value="tech">Tech</option>
          <option value="energy">Energy</option>
          <option value="healthcare">Healthcare</option>
          <option value="finance">Finance</option>
          <option value="transport">Transportation</option>
        </select>

        <label for="companyNameInput">Company Name:</label>
        <input type="text" id="companyNameInput" class="form-control mb-3" placeholder="e.g., NovaTech Inc.">

        <label for="stockSymbolInput">Stock Symbol (3‚Äì5 uppercase letters):</label>
        <input type="text" id="stockSymbolInput" class="form-control" maxlength="5" placeholder="e.g., NTV">
      </div>

      <div class="modal-footer">
        <button class="btn btn-success" id="confirmStartCompanyBtn">Confirm</button>
      </div>

    </div>
  </div>
</div>

<div id="employeesModal" class="modal fade" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Employees</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <!-- Content is dynamically inserted here -->
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="manageHomeModal" tabindex="-1" aria-labelledby="manageHomeModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="manageHomeModalLabel">Manage Home Systems</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <!-- dynamically filled -->
      </div>
      <div class="modal-footer">
        <!-- dynamically filled -->
      </div>
    </div>
  </div>
</div>



<script type="module">
import {  auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import {   getFirestore,  query,
  where, limit, addDoc ,
  arrayRemove, increment, serverTimestamp, 
  arrayUnion, collection, doc, getDoc, getDocs, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { initLiveNotifications } from 'https://rw-501.github.io/theGame/game/includes/notifications.js'; // Adjust path as needed
import {  } from 'https://rw-501.github.io/theGame/game/includes/chat.js'; // Adjust path as needed

document.addEventListener("DOMContentLoaded", () => {
  const notifBtn = document.getElementById("notifBellBtn");

  if (notifBtn) {
notifBtn.addEventListener("click", () => {
  // Just show modal
  new bootstrap.Modal(document.getElementById("notifModal")).show();
});
  }
});

document.getElementById("toggleToolsBtn").addEventListener("click", () => {
  const toolButtons = document.querySelectorAll("#userTool button:not(#toggleToolsBtn)");
  toolButtons.forEach(btn => {
    btn.style.display = btn.style.display === "none" ? "inline-block" : "none";
  });
});

window.addEventListener("DOMContentLoaded", () => {
  const toolButtons = document.querySelectorAll("#userTool button:not(#toggleToolsBtn)");
  toolButtons.forEach(btn => btn.style.display = "none");
});




// === Game Constants ===
const TILE_SIZE = 64; 
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;
let playerData = {};
let playerSprite;
let isMoving = false;
let playerX = 5, playerY = 5; // Default fallback
let graphics, cursors;
let mapData = [];
let otherPlayerSprites = new Map();


const playerState = new Map();

// === Zone Metadata ===
// === Zone Metadata ===
const zoneInfo = {
  empty: {
    color: 0xffffff,
    label: "Wilderness",
    type: "empty",
    icon: "üå≤",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/trees/tree-small.png', // fixed slashes and removed extra quotes
    price: 1000,
    income: 0,
    taxRate: 0.8,
    value: 500,
    unlocked: true
  },
  playerHome: {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    icon: "üè†",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png', // fixed slashes and removed extra quotes
    price: 0,
    income: 1,
    taxRate: 0.5,
    value: 100,
    unlocked: true
  },
  company: {
    color: 0x90caf9,
    label: "Company",
    type: "company",
    icon: "üè¢",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/industrial/building-5.png', // fixed slashes and removed extra quotes
    price: 1500,
    income: 0,
    taxRate: 10,
    value: 500,
    unlocked: false
  },
  blocked: {
    color: 0x555555,
    label: "Blocked Area",
    type: "blocked",
    icon: "üöß",
    price: 0,
    income: 0,
    taxRate: 0,
    value: 0,
    unlocked: false
  },
  stockMarket: {
    color: 0xffd54f,
    label: "Stock Exchange",
    type: "stockMarket",
    icon: "üìà",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/building.png', // fixed slashes and removed extra quotes
    price: 50000000,
    income: 100000,
    taxRate: 0.25,
    value: 10000000,
    unlocked: false
  },
  // 12 Custom Zones with Incremental Pricing
  ...(() => {
    const zones = {};
    const basePrice = 5000;      // start price at 5000 for Zone 1
    const priceStep = -400;      // negative step to decrease price per zone (adjust as needed)

    const incomeStep = 25;
    const valueStep = 500;
    const baseTax = 0.1;

    const zoneColors = [
      0x9575cd, 0x4fc3f7, 0x4db6ac, 0x81c784, 0xffb74d,
      0xa1887f, 0xe57373, 0xba68c8, 0x64b5f6, 0x81c784,
      0xff8a65, 0xaed581
    ];

    const zoneIcons = [
      "üåÜ", "üèôÔ∏è", "üåÉ", "üèóÔ∏è", "üè¨",
      "üè¢", "üè†", "üèòÔ∏è", "üèöÔ∏è", "üèõÔ∏è",
      "üè®", "üïå"
    ];

    for (let i = 1; i <= 12; i++) {
      const price = basePrice + priceStep * (i - 1);  // decreases price for each subsequent zone
      zones[`zone${i}`] = {
        color: zoneColors[i - 1] || 0xcccccc,
        label: `Zone ${i} Company`,
        type: "company",
        icon: zoneIcons[i - 1] || "üèôÔ∏è",
        tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/commercial/building-3.png', // fixed slashes and removed extra quotes
        price,
        level: 1,
        income: 50 + incomeStep * (i - 1),
        taxRate: parseFloat((baseTax + i * 0.01).toFixed(2)),
        value: price + valueStep * (i - 1),
        unlocked: i > 3 // unlock first 3 zones by default
      };
    }

    return zones;
  })()
};


async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

  const centerX = 12;
  const centerY = 12;
  mapData[centerY][centerX] = "stockMarket";

  for (let y = centerY - 6; y <= centerY + 6; y++) {
    for (let x = centerX - 6; x <= centerX + 6; x++) {
      if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) continue;
      if (x === centerX && y === centerY) continue;

      const dist = Math.max(Math.abs(x - centerX), Math.abs(y - centerY));
      if (dist >= 1 && dist <= 12) {
        mapData[y][x] = `zone${dist}`;
      }
    }
  }
}

let game;
let scene;
let cam;
let newZoom;
let isPointerDown = false;
let pointerDownTime = 0;
let initialPointer = null;
const allUsersMap = new Map();


function getRandomEmptyTile(mapData) {
  const emptyTiles = [];

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      if (mapData[y][x] === "empty") {
        emptyTiles.push([x, y]);
      }
    }
          //  console.log("emptyTiles   ", emptyTiles);

  }

  if (emptyTiles.length === 0) {
    console.warn("‚ö†Ô∏è No empty tiles found. Defaulting to [5, 5].");
    return [5, 5];
  }

  return emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
}


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// === Firebase Login Check ===
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = 'https://rw-501.github.io/theGame';
    return;
  }

let MapWidth = (TILE_SIZE * MAP_SIZE) / 2;


// === Game Setup ===
const config = {
  type: Phaser.AUTO,

width: MapWidth, // window.innerWidth,
height: MapWidth, //window.innerHeight,


  parent: "game-container",
  backgroundColor: "#222222",
  scene: { preload, create }
};

 game = new Phaser.Game(config);

  uid = user.uid;

    
 // Add a 200ms delay before continuing
  await sleep(200);

  try {
 
    setTimeout(async () => {
      /*
console.log("First row:", mapData[0]);         // Logs the first row (an array of 25)
console.log("First tile:", mapData[0][0]);     // Logs the first tile
console.table(mapData);                        // Displays a visual table
      */


      // ‚úÖ Get a random empty tile
  const randomLocation = getRandomEmptyTile(mapData);



  // Query the player with userID === uid and server === "main"
const q = query(
  collection(db, "players"),
  where("userID", "==", uid),
  where("server", "==", "main"),
  limit(1)
);

const querySnapshot = await getDocs(q);

if (!querySnapshot.empty) {
const docSnap = querySnapshot.docs[0];
playerData = docSnap.data();
playerData.id = docSnap.id; // store doc ID
playerData.isNew = false;

const [x, y] = playerData.location;
playerX = x;
playerY = y;

cam.setZoom(newZoom);

// ‚úÖ Center camera on player location
//const TILE_SIZE = 64; // or whatever your tile size is
cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);

  console.log("playerY   ", playerY);

  if (playerData.location === 'start') {

    playerData.location = randomLocation;
    
  const [x, y] =  randomLocation;
  playerX = x;
  playerY = y;
    // Update the location in Firestore
    const docRef = doc(db, "players", docSnap.id);
    await updateDoc(docRef, { location: randomLocation, playerX, playerY });
  }
 } else {
          // Initialize player location
  const [x, y] =  randomLocation;
    // No player found, create a new one
    const newPlayer = {
      playerUid: "", // will be updated below
      userID: uid,
      playerName: user.displayName || "Player" + Math.floor(Math.random() * 1000),
      avatarUrl: 'https://robohash.org/1?size=50x50',
      status: "active",
      lastUpdate: serverTimestamp(),
      online: true,
      server: "main",

      location: randomLocation, // ‚úÖ Assigned here
      playerX: x,
      playerY: y,

      isNew: true,
      trainingMode: true,

      crypto: 5,
      xp: 0,
      level: 1,
      bank: 1000,
      vault: [],
      loans: [],
      health: 100,
      techStrength: 1,
      security: 1,

      landOwned: [],
      jobs: [],
      companiesOwned: [],
      stocks: [],
      trades: 0,
      tradesTotal: 0,
      portfolio: [],
      inCombat: false,
      attacks: 0,
      attacked: 0,
      inventory: [],
      history: [],
      createdAt: serverTimestamp()
    };

    // Create new player document
    const docRef = await addDoc(collection(db, "players"), newPlayer);
    const newId = docRef.id;

    // Update the playerUid in Firestore
    await updateDoc(docRef, { playerUid: newId });

    // Set locally
    newPlayer.id = newId;
    newPlayer.playerUid = newId;
    playerData = newPlayer;
  }

           
const playerRef = doc(db, "players", playerData.playerUid);

// Define the tile ID based on player's current position
const tileId = `${playerX}_${playerY}`;
const tileRef = doc(db, "tiles", tileId);
const tileSnap = await getDoc(tileRef);

if (!tileSnap.exists()) {
  const defaultTileData = {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    level: 1,
    icon: "üè†",
    tileImage: "https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png",
    price: 0,
    income: 100,
    taxRate: 10,
    value: 1000,
    unlocked: false,
    ownerID: playerData.playerUid,
    ownerName: playerData.playerName,
    createdAt: Date.now(),
  };

  await setDoc(tileRef, defaultTileData);
} else {
  /*
  // Optional: update existing tile with some info (if needed)
  await updateDoc(tileRef, {
    unlocked: true
  });
  */
}




// Example: Update player data if needed
await updateDoc(playerRef, {
  landOwned: [tileId]
});


  // Save player data locally
  localStorage.setItem("theGame_currentPlayerData", JSON.stringify(playerData));

  // Store in playerState map
  playerState.set(uid, playerData);

 

  console.log("‚úÖ Player loaded:", playerData);
  updateStatsUI();
}, 1000);


  } catch (error) {
    console.error("‚ùå Error loading player:", error);
  }

});



const tileTooltip = document.getElementById("tileTooltip");


function centerCameraOnPlayer() {
  cam.setZoom(newZoom);

cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);
}


async function initializeMap(scene) {
  // Assuming graphics and playerSprite are globals or declared elsewhere
  graphics = scene.add.graphics();
   cam = scene.cameras.main;

  // Await loading map data before drawing
  await loadMapFromFirebase();

  // Draw the map based on loaded data
  drawMap(scene);



  const mapWidth = MAP_SIZE * TILE_SIZE;
  const mapHeight = MAP_SIZE * TILE_SIZE;
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  // Calculate zoom to fit entire map inside screen
  const zoomX = screenWidth / mapWidth;
  const zoomY = screenHeight / mapHeight;
  const zoom = Math.min(zoomX, zoomY, 1); // Limit max zoom to 1 (optional)

  // Set camera bounds to map size
  cam.setBounds(0, 0, mapWidth, mapHeight);

  // Set camera zoom to fit map
  cam.setZoom(zoom);

  // Center camera on map
  // This centers by scrollX/Y, not centerOn (better control)
  cam.scrollX = (mapWidth / 2) - (screenWidth / (2 * zoom));
  cam.scrollY = (mapHeight / 2) - (screenHeight / (2 * zoom));

  updateStatsUI();
}

function drawMap(scene) {
  graphics.clear();

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {

      // Skip the player‚Äôs tile

      const zoneType = mapData[y][x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;

      // Background fill
      graphics.fillStyle(info.color, 1);
      graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);



          // Draw base concrete if not empty
    if (zoneType != "empty") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "concrete").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }



        if (zoneType == "empty") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "dirt").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }


    // Retrieve and parse the player data from localStorage
const storedData = JSON.parse(localStorage.getItem("theGame_currentPlayerData"));

// Safely extract playerX and playerY
const playerX = storedData?.location?.[0]; // assuming location = [x, y]
const playerY = storedData?.location?.[1];

if (x === playerX && y === playerY) continue;
if (info.x === "home" ) continue;



            if (zoneType == "zone2" || zoneType == "zone4" || zoneType == "zone6") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "company_company").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }
                if (zoneType == "zone3" || zoneType == "zone5") {
      scene.add.image(
        x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
           "zone1_company").setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
    }

      // Draw image if available
      if (info.imageKey) {
        scene.add.image(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.imageKey
        ).setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
      } 
      
      if (!info.icon) {
        scene.add.text(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.icon,
          { font: `${TILE_SIZE * 0.3}px Arial`, align: 'center' }
        ).setOrigin(0.5);
      }


    }
  }

}

function returnToPlayerLocation(scene) {
  const cam = scene.cameras.main;
  const targetX = playerX * TILE_SIZE + TILE_SIZE / 2;
  const targetY = playerY * TILE_SIZE + TILE_SIZE / 2;

  cam.pan(targetX, targetY, 500, 'Sine.easeInOut');
}


document.getElementById("returnToLocationBtn").addEventListener("click", () => {
  returnToPlayerLocation(game.scene.scenes[0]); // or pass in your current scene reference
});

document.getElementById("goToPlatformBtn").addEventListener("click", () => {
    window.location.href = "https://rw-501.github.io/theGame/game/platform/";
});

 let loadingText;

// === Phaser Scene Methods ===
function preload() {
  // Add loading text or a bar
   loadingText = this.add.text(
    this.cameras.main.centerX,
    this.cameras.main.centerY,
    'Loading...',
    { font: '32px Arial', fill: '#ffffff' }
  ).setOrigin(0.5);

  const usedImages = new Set(); // avoid duplicate loads

this.load.image("concrete", "https://rw-501.github.io/theGame/game/images/tile_images/sk.png"); // or wherever the file is
this.load.image("dirt", "https://rw-501.github.io/theGame/game/images/tile_images/dk.png"); // or wherever the file is


  for (const zoneKey in zoneInfo) {
    const tileData = zoneInfo[zoneKey];
    if (tileData.tileImage && !usedImages.has(tileData.tileImage)) {

      const imageKey = zoneKey + "_" + tileData.type; // already correct, just confirm uniqueness
      this.load.image(imageKey, tileData.tileImage);
      tileData.imageKey = imageKey; // store it for drawMap()
      usedImages.add(tileData.tileImage);

      console.log("imageKey ",imageKey);
      console.log("zoneKey ",zoneKey);
      console.log("tileData ",tileData);
    }
  }
this.load.image('avatar1', "https://robohash.org/1?size=50x50");
this.load.image('avatar2', "https://robohash.org/2?size=50x50");
this.load.image('avatar3', "https://robohash.org/3?size=50x50");
// etc.

  
  // Optional: Simulate longer loading for testing
  for (let i = 0; i < 100; i++) {
   // this.load.image(`dummy${i}`, 'path/to/dummy.png');
  }

  // Display loading progress
  this.load.on('progress', (value) => {
    loadingText.setText(`Loading... ${Math.round(value * 100)}%`);
  });
/*
  this.load.on('complete', () => {
    loadingText.setText('Loading Complete!');
  });

  */
}













function setupMapMovement(scene) {
  const cam = scene.cameras.main;

  // Drag to move camera

let pointer;


scene.input.on("pointermove", pointer => {
  if (pointer.isDown && isPointerDown) {
    cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
    cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;

  }
});

  // Mouse wheel zoom
  scene.input.on("wheel", (pointer, gameObjects, deltaX, deltaY) => {
     newZoom = Phaser.Math.Clamp(cam.zoom - deltaY * 0.001, 0.5, 2);
    cam.setZoom(newZoom);
  });

    cam.setZoom(newZoom);
}

function setupMapInteraction(scene) {
  cursors = scene.input.keyboard.createCursorKeys();

  scene.input.keyboard.on("keydown", event => {
    if (isMoving) return;
    switch (event.code) {
      case "ArrowLeft": tryMove(-1, 0, scene); break;
      case "ArrowRight": tryMove(1, 0, scene); break;
      case "ArrowUp": tryMove(0, -1, scene); break;
      case "ArrowDown": tryMove(0, 1, scene); break;
    }
  });



scene.input.on("pointerdown", pointer => {
  isPointerDown = true;
  pointerDownTime = Date.now();
  initialPointer = { x: pointer.x, y: pointer.y };
});

scene.input.on("pointerup", pointer => {
  if (!isPointerDown) return;
  isPointerDown = false;

  const timeHeld = Date.now() - pointerDownTime;
  const movedDistance = Phaser.Math.Distance.Between(pointer.x, pointer.y, initialPointer.x, initialPointer.y);

  const maxTapTime = 300;       // max press time in ms
  const maxMoveDistance = 10;   // max movement in px before cancel

  if (timeHeld <= maxTapTime && movedDistance <= maxMoveDistance) {
    const worldPoint = scene.cameras.main.getWorldPoint(pointer.x, pointer.y);
    const clickedX = Math.floor(worldPoint.x / TILE_SIZE);
    const clickedY = Math.floor(worldPoint.y / TILE_SIZE);

    if (clickedX < 0 || clickedX >= MAP_SIZE || clickedY < 0 || clickedY >= MAP_SIZE) return;

let otherPlayerId = null;

const entries = playerState instanceof Map
  ? Array.from(playerState.entries())
  : Object.entries(playerState);
/*
console.log("Entries to check:", entries);
console.log("Clicked position:", clickedX, clickedY);
*/
console.log("Current user:", playerData.playerUid);

for (const [pid, pos] of entries) {
  // Defensive checks
  if (!pos || typeof pos.x !== "number" || typeof pos.y !== "number") {
    console.warn(`Skipping invalid player data for ${pid}:`, pos);
    continue;
  }


  // Compare position and exclude current user
  if (
    pid !== playerData.playerUid &&
    Number(pos.x) === Number(clickedX) &&
    Number(pos.y) === Number(clickedY)
  ) {
    otherPlayerId = pid;
    console.log(`‚úÖ Found other player at this tile: ${otherPlayerId}`);
    break;
  }
}

    console.log(`clicked position: ${otherPlayerId}`);

    if (!isPointerDown) {
      const tileType = mapData[clickedY]?.[clickedX] || "empty";
      showTileActionModal(clickedX, clickedY, tileType, otherPlayerId);
    }
  }
});

scene.input.on("pointermove", pointer => {
  cam = scene.cameras.main;

  const worldPoint = cam.getWorldPoint(pointer.x, pointer.y);
  const x = Math.floor(worldPoint.x / TILE_SIZE);
  const y = Math.floor(worldPoint.y / TILE_SIZE);

  if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
    const zoneType = mapData[y]?.[x] || "empty";
    const info = zoneInfo[zoneType] || zoneInfo.empty;

    tileTooltip.style.left = pointer.event.clientX + 15 + "px";
    tileTooltip.style.top = pointer.event.clientY + 15 + "px";
    tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
    tileTooltip.style.display = "block";
  } else {
    tileTooltip.style.display = "none";
  }
});


  scene.input.on("pointerout", () => {
    tileTooltip.style.display = "none";
  });


async function showTileActionModal(x, y, tileTypeFromCaller, otherPlayerId) {


  const modalEl = document.getElementById("tileActionModal");
  const modalBody = document.getElementById("tileActionBody");
  const modalFooter = document.getElementById("tileActionFooter");

  if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return;

    const dbTileInfo = await getTileDataAt(x, y);

const tileInfo = mapData[y]?.[x] || "empty";
const info = dbTileInfo ? dbTileInfo : zoneInfo[tileInfo] || zoneInfo.empty;

const trueType = info.type;
const now = Date.now();

// Optional checks
const isUnlocked = info.unlocked ?? true; // fallback to true if not specified
const level = info.level ?? 1;
const income = info.income ?? 0;
const value = info.value ?? info.price ?? 0;
const taxRate = info.taxRate ?? 0;

modalBody.innerHTML = `
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h5 class="card-title mb-3">üìç Tile Info</h5>
      <div class="row g-2">
        <div class="col-6"><strong>Coordinates:</strong><br>(${x}, ${y})</div>
        <div class="col-6"><strong>Tile Type:</strong><br>${info.label} ${info.icon ?? ''}</div>
        <div class="col-6"><strong>Price:</strong><br>$${info.price?.toLocaleString() ?? 'N/A'}</div>
        <div class="col-6"><strong>Value:</strong><br>$${value.toLocaleString()}</div>
        <div class="col-6"><strong>Income:</strong><br>$${income.toLocaleString()} / Weekly</div>
        <div class="col-6"><strong>Tax Rate:</strong><br>${taxRate}%</div>
        <div class="col-6"><strong>Level:</strong><br>${level}</div>
        <div class="col-6"><strong>Owner:</strong><br>${info.ownerName || "None"}</div>
        <div class="col-6">
          <strong>Status:</strong><br>
          ${isUnlocked ? `<span class="text-success">Unlocked</span>` : `<span class="text-danger">Locked</span>`}
        </div>
      </div>
    </div>
  </div>
`;


  modalFooter.innerHTML = "";

  if (trueType === "blocked") {
    modalBody.innerHTML += "<p>This area is blocked. No actions available.</p>";
    return new bootstrap.Modal(modalEl).show();
  }


  
  // === Player tile interaction ===
  if (otherPlayerId) {
/*
let data = allUsersMap.get(otherPlayerId);

if (!data) {
  const playersRef = collection(db, "players");
  const q = query(playersRef, where("playerUid", "==", otherPlayerId));
  const otherSnap = await getDocs(q);
  
  if (!otherSnap.empty) {
    data = otherSnap.docs[0].data();
  } else {
    data = {};
  }
}

const info = {
  playerName: data.playerName ?? otherPlayerId.substring(0, 6),
  health: data.health ?? "??",
  level: data.level ?? "?",
  techStrength: data.techStrength ?? "?",
  security: data.security ?? "?",
  bank: data.bank ?? "?",
};

*/
const data = allUsersMap.get(otherPlayerId) || {};
const info = {
  playerName: data.playerName ?? otherPlayerId.substring(0, 6),
  health: data.health ?? "??",
  level: data.level ?? "?",
  techStrength: data.techStrength ?? "?",
  security: data.security ?? "?",
  bank: data.bank ?? "?",
};


    modalBody.innerHTML += `
      <p>Player <strong>${info.playerName}</strong> is here.</p>
      <p>Level: ${info.level}</p>
      <p>Bank: ${info.bank}</p>

      <p>Health: ${info.health}</p>
      <p>Tech Strength: ${info.techStrength}</p>
      <p>Security: ${info.security}</p>
    `;

 const hackBtn = createButton({
  text: "Hack",
  className: "btn btn-danger",
  onClick: async () => {
    await handleHackPlayer(playerData, data);
    bootstrap.Modal.getInstance(modalEl)?.hide();
  },
  parent: modalFooter
});
hackBtn.disabled = data.isInCombat;

const talkBtn = createButton({
  text: "Talk",
  className: "btn btn-primary",
  onClick: () => {
    showMessageModal(`Talking to ${info.playerName}...`);
    bootstrap.Modal.getInstance(modalEl)?.hide();
  },
  parent: modalFooter
});
talkBtn.disabled = data.isInCombat;

  }



if (!otherPlayerId && trueType === "land") {
  let landType = level > 1 ? "Property" : "Land";

  createButton({
    text: `Upgrade ${landType}`,
    className: "btn btn-success",
    onClick: async () => {
      await upgradeLand(x, y, "land", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}


if (!otherPlayerId && trueType === "home") {
  let homeType = level > 5 ? "House" : "Appartment";

  createButton({
    text: `Upgrade ${homeType}`,
    className: "btn btn-success",
    onClick: async () => {
      await upgradeHomeBase(x, y, "home", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });

  // üîß New Button: Open Upgrade/Repair Modal
  createButton({
    text: "Manage Home Systems",
    className: "btn btn-warning",
    onClick: () => {
      showManageHomeModal(x, y);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}


if (!otherPlayerId && isUnlocked && (trueType === "zone" || trueType === "empty")) {
  createButton({
    text: `Buy Land $${info.price}`,
    className: "btn btn-success",
    onClick: async () => {
      await purchaseTile(x, y, "land", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });

  const newValue = info.price + playerData.level * 500;
  createButton({
    text: `Move Here (Buy for $${newValue})`,
    className: "btn btn-primary",
    onClick: async () => {
      await purchaseTile(x, y, "home", true);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (!otherPlayerId && isUnlocked && trueType === "company") {
  createButton({
    text: `Buy Company $${info.price}`,
    className: "btn btn-warning",
    onClick: async () => {
      await purchaseTile(x, y, "company", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (trueType === "company") {
  createButton({
    text: "View Employees",
    className: "btn btn-primary",
    onClick: async () => {
      await showEmployeesModal(`${x}_${y}`);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
    parent: modalFooter
  });
}

if (
  info.ownerName &&
  isUnlocked &&
  info.ownerName === playerData.username &&
  info.unlocked &&
  (trueType === "zone" || trueType === "empty")
) {
  createButton({
    text: `Start Company $${info.value}`,
    className: "btn btn-success",
    onClick: () => {
      document.getElementById("confirmStartCompanyBtn").dataset.tile = `${x}_${y}`;
      bootstrap.Modal.getInstance(modalEl)?.hide();
      new bootstrap.Modal(document.getElementById("startCompanyModal")).show();
    },
    parent: modalFooter
  });
}

if (
  //info.ownerName &&
  isUnlocked &&
   info.ownerName != playerData.username &&
  trueType === "company"
) {
  createWorkForCompanyButton(info, playerData, modalFooter, x, y);
  bootstrap.Modal.getInstance(modalEl)?.hide();
}

  new bootstrap.Modal(modalEl).show();
}





const BASE_COST = 1000;
const XP_PER_LEVEL = 50;

function calculateUpgradeStats(currentLevel, statType = "default") {
  let costMultiplier = 1;
  let xpMultiplier = 1;

  // Optional: different stat types could have different multipliers
  switch (statType) {
    case "tech":
      costMultiplier = 1.2;
      xpMultiplier = 1.5;
      break;
    case "security":
      costMultiplier = 1.4;
      xpMultiplier = 1.3;
      break;
    case "health":
      costMultiplier = 1.1;
      xpMultiplier = 1.2;
      break;
    default:
      break;
  }

  const cost = Math.floor(BASE_COST * (currentLevel + 1) * costMultiplier);
  const xpGain = Math.floor(XP_PER_LEVEL * (currentLevel + 1) * xpMultiplier);

  return { cost, xpGain };
}


async function upgradeHomeStat(x, y, stat) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([getDoc(tileRef), getDoc(playerRef)]);
  if (!tileSnap.exists() || !playerSnap.exists()) {
    showMessageModal("Tile or player not found.");
    return;
  }

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData[`${stat}Level`] || 0;

  // üßÆ Use the new logic
  const { cost, xpGain } = calculateUpgradeStats(currentLevel, stat);

const statLabels = {
  tech: "Tech Strength",
  security: "Security",
  health: "Health"
};



  if (player.bank < cost) {
    showMessageModal(`Not enough money to upgrade ${statLabels[stat] || stat}. Cost: $${cost}`);
    return;
  }

  const updates = {};
  updates[`${stat}Level`] = currentLevel + 1;

  await Promise.all([
    updateDoc(tileRef, updates),
    updateDoc(playerRef, {
      bank: player.bank - cost,
      xp: (player.xp || 0) + xpGain,
    }),
  ]);



showMessageModal(`‚úÖ Upgraded ${statLabels[stat] || stat} to level ${currentLevel + 1}. Spent $${cost}, gained ${xpGain} XP.`);
}




async function repairHomeHealth(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([getDoc(tileRef), getDoc(playerRef)]);
  if (!tileSnap.exists() || !playerSnap.exists()) {
    showMessageModal("Tile or player not found.");
    return;
  }

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const maxHealth = 100; // max health cap, adjust if you want
  const currentHealth = tileData.health || maxHealth;
  if (currentHealth >= maxHealth) {
    showMessageModal("Health is already full.");
    return;
  }

  // Repair cost proportional to damage
  const healthToRepair = maxHealth - currentHealth;
  const costPerHealth = 100; // adjust cost per health point repaired
  const repairCost = healthToRepair * costPerHealth;

  if (player.bank < repairCost) {
    showMessageModal(`Not enough money to repair health. Cost: $${repairCost}`);
    return;
  }

  await Promise.all([
    updateDoc(tileRef, { health: maxHealth }),
    updateDoc(playerRef, {
      bank: player.bank - repairCost,
      xp: (player.xp || 0) + Math.floor(healthToRepair / 10), // XP proportional to health repaired
    }),
  ]);

  showMessageModal(`Repaired health to full for $${repairCost}.`);
}


function showManageHomeModal(x, y) {
  const modalEl = document.getElementById("manageHomeModal");
  const modalBody = modalEl.querySelector(".modal-body");
  const modalFooter = modalEl.querySelector(".modal-footer");
  
  modalBody.innerHTML = `
    <p>Upgrade different aspects of your home tile.</p>
    <ul>
      <li><strong>Tech Strength</strong>: Improves hacking defense.</li>
      <li><strong>Security</strong>: Adds guard presence & alert systems.</li>
      <li><strong>Health Repair</strong>: Restores structural integrity.</li>
    </ul>
  `;

  modalFooter.innerHTML = ""; // clear previous buttons

const options = [
  {
    text: "Upgrade Tech Strength",
    onClick: async () => {
      await upgradeHomeStat(x, y, "tech");
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  },
  {
    text: "Upgrade Security",
    onClick: async () => {
      await upgradeHomeStat(x, y, "security");
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  },
  {
    text: "Repair Health",
    onClick: async () => {
      await repairHomeHealth(x, y);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    },
  }
];


  options.forEach(({ text, onClick }) => {
    createButton({
      text,
      className: "btn btn-outline-primary me-2",
      onClick,
      parent: modalFooter
    });
  });

  const modal = new bootstrap.Modal(modalEl);
  modal.show();
}

async function showEmployeesModal(tileId) {
  const modalEl = document.getElementById("employeesModal");
  const modalBody = modalEl.querySelector(".modal-body");
  modalBody.innerHTML = "Loading...";

  // Always try to show the modal
  const bsModal = new bootstrap.Modal(modalEl);
  bsModal.show();

  try {
    const tileRef = doc(db, "tiles", tileId);
    const tileSnap = await getDoc(tileRef);

    if (!tileSnap.exists()) {
      modalBody.innerHTML = "No data found for this tile.";
      return;
    }

    const tileData = tileSnap.data();
    const employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

    if (employsIDs.length === 0) {
      modalBody.innerHTML = "No employees yet.";
      return;
    }

    let html = `<ul class="list-group">`;

    for (const uid of employsIDs) {
      const empRef = doc(db, "players", uid);
      const empSnap = await getDoc(empRef);

      if (empSnap.exists()) {
        const empData = empSnap.data();
        const job = (empData.jobs || []).find(j => j.companyCoords?.join("_") === tileId);
        const startDate = job ? new Date(job.startedOn).toLocaleDateString() : "Unknown";

        html += `
          <li class="list-group-item d-flex align-items-center">
            <img src="${empData.avatarURL || 'default-avatar.png'}" alt="Avatar"
                 class="rounded-circle me-3" style="width: 40px; height: 40px; object-fit: cover;">
            <div>
              <strong>${empData.username || 'Unnamed'}</strong><br>
              <small class="text-muted">Started: ${startDate}</small>
            </div>
          </li>
        `;
      }
    }

    html += `</ul>`;
    modalBody.innerHTML = html;

  } catch (error) {
    modalBody.innerHTML = "An error occurred loading employees.";
    console.error("showEmployeesModal error:", error);
  }
}


async function upgradeLand(x, y, options = {}) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 500;

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 500;

  // Determine land type based on level
  let landType = "Plot";
  if (newLevel > 5) landType = "Farm";
  if (newLevel > 10) landType = "Estate";

  // Allow optional custom label override
  const customLabel = options.getLabel?.(newLevel, tileData) 
                    || `${landType} (Lv ${newLevel})`;

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: customLabel
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost,
      xp: increment(upgradeCost)
    })
  ]);

  showMessageModal(`Land upgraded to ${customLabel}.`);
}

async function upgradeHomeBase(x, y) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 500;

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 500;

  let homeType = "Apartment";
  if (newLevel > 5) homeType = "House";
  if (newLevel > 10) homeType = "Estate";

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: `${homeType} (Lv ${newLevel})`
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost,
      xp: increment(upgradeCost)

    })
  ]);

  showMessageModal(`Home upgraded to ${homeType} level ${newLevel}.`);
}


async function handleHackPlayer(attacker, defender) {
  console.log("üõ†Ô∏è Hacking...", attacker.playerName, "vs", defender.playerName);

    const attackerLocation = attacker.location || [];
  const defenderLocation = defender.location || [];


  
  // üîç Find tile DOM element
  const [dx, dy] = defender.location || [];
  const tile = document.querySelector(`[data-x="${dx}"][data-y="${dy}"]`);
  if (tile) {
    const overlay = document.createElement("div");
    overlay.className = "hack-overlay";
    overlay.style.left = `${tile.offsetLeft}px`;
    overlay.style.top = `${tile.offsetTop}px`;
    overlay.style.position = "absolute";

    tile.parentNode.appendChild(overlay);

    // üßπ Remove after animation ends
    setTimeout(() => overlay.remove(), 700);
  }
  const attackerStrength = attacker.techStrength || 1;
  const defenderSecurity = defender.security || 1;

  const attackerLevel = attacker.level || 1;
  const defenderLevel = defender.level || 1;

  const attackerBank = attacker.bank || 0;
  const defenderBank = defender.bank || 0;

  const damage = 10 + attackerLevel * 2; // Basic formula
  const xpGain = 5 + Math.abs(attackerLevel - defenderLevel);
  const stealAmount = Math.min(defenderBank, 100 + attackerLevel * 20); // max cap

  const attackerRef = doc(db, "players", attacker.playerUid);
  const defenderRef = doc(db, "players", defender.playerUid);

  const attackerWins = attackerStrength >= defenderSecurity;

  // Get the tile DOM element based on defender's location
const tileSelector = `[data-x="${defenderLocation[0]}"][data-y="${defenderLocation[1]}"]`;
const tileEl = document.querySelector(tileSelector);

if (tileEl) {
  tileEl.classList.add("tile-zoom", "electric-shock");

  // Remove classes after animation (1.2s total)
  setTimeout(() => {
    tileEl.classList.remove("tile-zoom", "electric-shock");
  }, 1200);
}

  // Begin updates
  await Promise.all([
    updateDoc(attackerRef, {
      inCombat: true,
      xp: increment(xpGain),
      bank: increment(attackerWins ? stealAmount : -stealAmount / 2),
      attacks: increment(1)
    }),
    updateDoc(defenderRef, {
      inCombat: true,
      health: increment(attackerWins ? -damage : -damage / 2),
      bank: increment(attackerWins ? -stealAmount : -stealAmount / 2),
      attacked: increment(1)
    })
  ]);

  const msg = attackerWins
    ? `üí• Success! You hacked ${defender.playerName} and stole $${stealAmount}.`
    : `‚ùå Hack failed! ${defender.playerName} defended successfully.`;

  showMessageModal(msg);
}



async function createWorkForCompanyButton(info, playerData, modalFooter, x, y) {
  const trueType = info.type;
  const jobLimit = 3;

  if (info.ownerName !== playerData.username && trueType === "company") {
    const currentJobs = Array.isArray(playerData.jobs) ? playerData.jobs.length : 0;

    if (currentJobs < jobLimit) {
      const payPerDay = Math.floor(info.value / 20);

      const workBtn = createButton(
        `Work for company for $${payPerDay} /day`,
        "btn btn-success",
        async () => {
          // Prepare job object
          const job = {
            companyName: info.label || "Unknown Company",
            companyCoords: [x, y],
            pay: payPerDay,
            startedOn: Date.now()
          };

          // Ensure jobs array exists
          if (!Array.isArray(playerData.jobs)) playerData.jobs = [];
          playerData.jobs.push(job);

          // Update player document
          const playerRef = doc(db, "players", playerData.playerUid);
          await updateDoc(playerRef, { jobs: playerData.jobs });

          // Update tile's employsIDs array
          const tileId = `${x}_${y}`;
          const tileRef = doc(db, "tiles", tileId);
          const tileSnap = await getDoc(tileRef);

          if (tileSnap.exists()) {
            const tileData = tileSnap.data();
            let employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

            // Avoid duplicate entry
            if (!employsIDs.includes(playerData.playerUid)) {
              employsIDs.push(playerData.playerUid);
              await updateDoc(tileRef, { employsIDs });
            }
          }

          showMessageModal(`üéâ You‚Äôre now working at ${job.companyName}!`, "success");
         // closeModal();
        }
      );

      modalFooter.appendChild(workBtn);
    } else {
      const msg = createButton(
        "üíº Job limit reached (3)", 
        "btn btn-secondary disabled"
      );
      modalFooter.appendChild(msg);
    }
  }
}


function createButton({ text, className, onClick, parent = document.body, styles = {} }) {
  if (!text) {
    console.trace("createButton called with no text");
    return;
  }

  const button = document.createElement("button");
  button.textContent = text;
  button.className = className;
  button.onclick = onClick;

  Object.assign(button.style, styles);
  parent.appendChild(button);
  return button;
}


async function startCompany(x, y, tileData, uid, sector, name, symbol) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerUid);
  const info = getTileDataAt(x, y);
  const now = Date.now();

  const companyPrice = info.value * 2;
  const min = parseFloat((companyPrice * 0.7).toFixed(2));
  const max = parseFloat((companyPrice * 2).toFixed(2));
  const randomPrice = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  const updatedTile = {
    type: "company",
    name,
    stockSymbol: symbol,
    stockMarketListed: true,
    value: tileData.value * 2,
    level: tileData.level,
    sector,
    employsIDs: [],
    ownerID: uid,
    createdAt: now,
    event: "bigChange",
    eventTimestamp: now,
    stockLastPrice: randomPrice,
    price: companyPrice,
    stockPrice: companyPrice / 10,
    stockMinPrice: min,
    stockMaxPrice: max,
    stockMaxChangePercent: 0.05,
    stockPriceHistory: [companyPrice],
    companyStartedAt: now,
  };

  const newBankValue = playerData.bank - tileData.value;

await Promise.all([
  updateDoc(tileRef, updatedTile),
  updateDoc(playerRef, {
    bank: newBankValue,
    companiesOwned: arrayUnion(tileId),
    xp: increment(tileData.value)

  })
]);

  playerData.bank = newBankValue;
  playerData.companiesOwned = playerData.companiesOwned || [];
  playerData.companiesOwned.push(tileId);

  showMessageModal(`Company '${name}' (${symbol}) started at tile ${tileId} in sector '${sector}'`);
}


document.getElementById("confirmStartCompanyBtn").addEventListener("click", async () => {
  const sector = document.getElementById("sectorSelect").value;
  const name = document.getElementById("companyNameInput").value.trim();
  const symbol = document.getElementById("stockSymbolInput").value.trim().toUpperCase();

  if (!name || !symbol || symbol.length < 3 || symbol.length > 5 || !/^[A-Z]+$/.test(symbol)) {
    showMessageModal("Please enter a valid company name and a stock symbol (3‚Äì5 uppercase letters).");
    return;
  }

  // Replace these with your actual tile context values
  const x = selectedTileX;
  const y = selectedTileY;
  const tileData = await getTileDataAt(x, y);
  const uid = currentUser?.uid;

  if (!uid) return alert("User not logged in.");

  await startCompany(x, y, tileData, uid, sector, name, symbol);

  // Hide the modal
  bootstrap.Modal.getInstance(document.getElementById("startCompanyModal"))?.hide();
});


async function purchaseTile(x, y, overrideType = null, shouldMove = false) {
  try {
    const tileInfo = mapData[y]?.[x] || "empty";
    const info = zoneInfo[tileInfo] || zoneInfo.empty;
    const type = overrideType || info.type;

    const uid = auth.currentUser?.uid;
    if (!uid) throw new Error("User not logged in");

    const tileId = `${x}_${y}`;
    const tileRef = doc(db, "tiles", tileId);
    const tileSnap = await getDoc(tileRef);

    let tileData;
    if (tileSnap.exists()) {
      console.log(`üìÑ Loaded existing tile from Firestore at ${tileId}`);
      tileData = tileSnap.data();
    } else {
      console.log(`üÜï Creating new tile at ${tileId}`);
      tileData = info;
    }

    // Tile already owned by another player
    if (tileData.ownerID && tileData.ownerID !== playerData.playerUid) {
      return showMessageModal("Oops!", "Tile already owned by someone else.");
    }

    // Check if player can afford it
    const cost = tileData?.price ?? info.price;
    if (playerData.bank < cost) {
      return showMessageModal("Insufficient Funds", "You don't have enough funds.");
    }

    // Prepare new tile data
    const newValue = info.price + playerData.level * 500;
    const updatedBank = playerData.bank - cost;

    const newTile = {
      ownerID: playerData.userID,
      ownerName: playerData.playerName || 'Player',
      status: "owned",
      note: 'new',
      tileImage: '',
      color: info.color,
      label: info.label,
      type: type,
      icon: info.icon,
      price: shouldMove ? newValue : info.price,
      originalCost: shouldMove ? newValue : info.price,
      income: info.income,
      taxRate: info.taxRate,
      value: info.value,
      forSale: false,
      unlocked: true,
      level: 1,
      x,
      y,
      tileHistory: info,
    };

    // Firestore updates
    const updates = [
      updateDoc(doc(db, "players", playerData.playerUid), {
        bank: updatedBank,
        ...(shouldMove ? { location: [x, y] } : {}),
        landOwned: arrayUnion(tileId),
        xp: increment(info.value)

      }),
      setDoc(tileRef, newTile, { merge: true })
    ];

    await Promise.all(updates);

    // Update local memory/player state
    if (!playerData.landOwned) playerData.landOwned = [];
    if (!playerData.companiesOwned) playerData.companiesOwned = [];

    if (type === 'zone' && !playerData.landOwned.includes(tileId)) {
      playerData.landOwned.push(tileId);
    }

    if (type === 'company' && !playerData.companiesOwned.includes(tileId)) {
      playerData.companiesOwned.push(tileId);
    }

    playerData.bank = updatedBank;

    if (shouldMove) {
      playerData.location = [x, y];
      playerX = x;
      playerY = y;
      movePlayerSmoothly(scene, x, y);
    }

    updateStatsUI();
    showMessageModal("Success", `You purchased a ${type} tile!`);

  } catch (err) {
    console.error("‚ùå Purchase failed:", err.message);
    showMessageModal("Error", err.message);
  }
}

window.purchaseTile = purchaseTile;



async function getTileDataAt(x, y) {
  try {
    // Get the tile type from mapData
    const tileType = mapData[y]?.[x] || "empty";

    // Get static zone info (default fallback data)
    const defaultInfo = zoneInfo[tileType] || zoneInfo.empty;

    // Get live data from Firestore (tiles collection)
    const tileRef = doc(db, "tiles", `${x}_${y}`);
    const tileSnap = await getDoc(tileRef);

    // If Firestore has data, merge it with static info
    if (tileSnap.exists()) {
      const firestoreData = tileSnap.data();
      return { ...defaultInfo, ...firestoreData, x, y };
    } else {
      // Use default zone info if no Firestore document exists
      return { ...defaultInfo, x, y };
    }

  } catch (error) {
    console.error("Error fetching tile data:", error);
    return { ...zoneInfo.empty, x, y };
  }
}



let ownedTiles = [];///  = [ playerData.companiesOwned playerData.landOwned]; // Loaded from player data

function openOwnedModal() {
  renderOwnedList();
  console.log("Opening owned assets modal");

  const modalEl = document.getElementById("ownedModal");

  // Try to get existing instance
  let modalInstance = bootstrap.Modal.getInstance(modalEl);

  // If no instance, create one
  if (!modalInstance) {
    modalInstance = new bootstrap.Modal(modalEl);
  }

  modalInstance.show();
}

document.getElementById("openOwnedBtn").addEventListener("click", openOwnedModal);

// Expose to global if needed
window.openOwnedModal = openOwnedModal;



document.getElementById("sortFilter").addEventListener("change", renderOwnedList);

function renderOwnedList() {
  const listEl = document.getElementById("ownedList");
  const sortBy = document.getElementById("sortFilter").value;

  let sorted = [...ownedTiles];
  sorted.sort((a, b) => {
    if (sortBy === "value") return b.value - a.value;
    if (sortBy === "tax") return b.taxRate - a.taxRate;
    return 0;
  });

  listEl.innerHTML = "";
  sorted.forEach(tile => {
    const li = document.createElement("li");
    li.innerHTML = `
      <strong>${tile.name}</strong> (${tile.x}, ${tile.y})<br>
      üí∞ Value: $${tile.value} | üìä Tax: ${tile.taxRate}% | üîì ${tile.unlocked ? "Unlocked" : "Locked"}
      <br>
      <button class="view-btn" data-x="${tile.x}" data-y="${tile.y}">View</button>
      <button class="sell-btn" data-id="${tile.id}">Sell</button>
      <button class="upgrade-btn" data-id="${tile.id}">Upgrade</button>
    `;
    listEl.appendChild(li);
  });

  attachOwnedListeners();
}

function attachOwnedListeners() {
  document.querySelectorAll(".view-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const x = parseInt(e.target.dataset.x);
      const y = parseInt(e.target.dataset.y);
      centerCameraOnTile(x, y);
      openTileDetails(x, y);
      highlightTile(x, y);
    });
  });

  document.querySelectorAll(".sell-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await sellTile(tileId);
      showMessageModal("Success","Tile sold!");
      refreshOwnedTiles();
    });
  });

  document.querySelectorAll(".upgrade-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await upgradeTile(tileId);
      showMessageModal("Success","Tile upgraded!");
      refreshOwnedTiles();
    });
  });
}

function highlightTile(x, y) {
  // Optional: remove previous highlights
  document.querySelectorAll(".tile-highlight").forEach(el => el.classList.remove("tile-highlight"));

  const tileEl = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
  if (tileEl) tileEl.classList.add("tile-highlight");
}

function centerCameraOnTile(x, y) {
  playerX = x;
  playerY = y;
  drawBoard();
}

function openTileDetails(x, y) {
  const tile = getTileDataAt(x, y); // implement this based on your tile structure
  showTileModal(tile); // your modal function
}


async function upgradeTile(tileId) {
  // Firebase logic to apply upgrades
  const ref = doc(db, "tiles", tileId);
  await updateDoc(ref, { level: increment(1),  });
}

async function refreshOwnedTiles() {
  // Pull owned tiles again
  const snap = await getDocs(query(collection(db, "tiles"), where("ownerId", "==", playerData.userID)));
  ownedTiles = snap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
  renderOwnedList();
}


async function sellTile(x, y, playerData) {
  const tile = await getTileDataAt(x, y);
  const tileId = tile.tileId;
  const ref = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.userID);

   // Build update payload (merge style)
    const updatePayload = {
      ownerID: null,
      status: "available",
      note: "Sold",
      tileHistory: `${tile.tileHistory || ""} | Sold on ${new Date().toLocaleDateString()}`,
      type: tile.type || "empty",
      ...newData, // allow overrides or additions
    };


  try {
    // Determine which array to remove from
    const isCompany = tile.type === "market" || tile.type === "company"; // adjust types as needed
    const fieldToRemove = isCompany ? "companiesOwned" : "landOwned";

    // Remove from player data and update bank
    await updateDoc(playerRef, {
      [fieldToRemove]: arrayRemove(tileId),
      bank: increment(tile.value || 100), // Default fallback value
      xp: increment(tile.value)

    });

   
    
 
    // Update Firestore
    await updateDoc(ref, updatePayload);
    console.log(`Tile ${x},${y} updated successfully.`);
    console.log(`Tile ${tileId} sold and removed from ${fieldToRemove}`);
  } catch (error) {
    console.error("Error selling tile:", error);
  }
}










  // Realtime sync for player movement and all players
const playerRef = doc(db, "players", uid);
onSnapshot(playerRef, (docSnap) => {
  if (docSnap.exists()) {
    const data = docSnap.data();

    // Update position and move player sprite if position changed
    const pos = data.location;
    if (pos && (pos.x !== playerX || pos.y !== playerY)) {
      playerX = pos.x;
      playerY = pos.y;
      movePlayerSmoothly(scene, playerX, playerY);
    }


console.log(" location   ",pos);

    // Update local playerData object with all fresh data from Firestore
    playerData = {
      ...playerData,  // keep previous keys if any
      ...data         // overwrite with latest from Firestore
    };

    // Refresh UI after updating playerData
    updateStatsUI();
  }
});

const playersRef = collection(db, "players"); // not doc()

onSnapshot(playersRef, (querySnapshot) => {
  console.log("üî• Received Firestore snapshot");

  playerState.clear();
  allUsersMap.clear(); // Clear old data to keep it fresh

  querySnapshot.forEach(doc => {
    const data = doc.data();
    const id = doc.id;

    allUsersMap.set(id, data);

    if (Array.isArray(data.location) && data.location.length === 2) {
      playerState.set(id, {
        x: data.location[0],
        y: data.location[1]
      });
    }
  });

  console.log("üß† Updated playerState:", Array.from(playerState.entries()));
  renderAllPlayers(scene);
});

  updateStatsUI();

}


let moveTween;

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}




// === Stats UI ===
function updateStatsUI() {
  const state = playerState.get(uid);
  if (!state) {
    console.warn("Missing player state UID:", uid);
    return;
  }

  const now = Date.now();
  
  

  document.getElementById("level").textContent = `${state.level ?? 0}`;
  document.getElementById("xp").textContent = `${state.xp ?? 0}`;

  document.getElementById("bank").textContent = `$${state.bank ?? 0}`;
  document.getElementById("trades").textContent = state.trades ?? 0;
  document.getElementById("crypto").textContent = `${state.crypto ?? 5}`;

  document.getElementById("health").textContent = `${state.health ?? 100}%`;
  document.getElementById("security").textContent = `${state.security ?? 1}`;
  document.getElementById("techStrength").textContent = `${state.techStrength ?? 1}`;


  const zoneType = mapData[playerY]?.[playerX] || "empty";
  const label = zoneInfo[zoneType]?.label || "Unknown";
  document.getElementById("zoneName").innerHTML = `üìç Zone: <span>${label}</span>`;


      scene.load.on('complete', () => {
    loadingText.setText('Loading Complete!');


  });
}






async function create() {
   scene = this;

  await initializeMap(scene);
  setupMapMovement(scene);
  setupMapInteraction(scene);
}



function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}





const tileSpriteMap = new Map(); // Similar to otherPlayerSprites
let tileDataMap; 



// Render other players except local player
function renderAllPlayers(scene) {
  console.log("üé® Rendering All Players...");
  console.log("üßç All Player States:", Array.from(playerState.entries()));

  for (const [key, sprite] of otherPlayerSprites) {
    if (!playerState.has(key) || key === uid) {
      console.log(`‚ùå Removing sprite for: ${key}`);
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }

  for (const [playerId, pos] of playerState.entries()) {
    if (playerId === uid) continue;
    if (!pos || pos.x === undefined || pos.y === undefined) {
      console.warn(`‚ö†Ô∏è Invalid pos for ${playerId}:`, pos);
      continue;
    }

    console.log(`üßç Drawing ${playerId} at (${pos.x}, ${pos.y})`);

    let sprite = otherPlayerSprites.get(playerId);

    // Get player data (e.g., from allUsersMap or Firestore cache)
    const playerData = allUsersMap.get(playerId); // Ensure this map exists
    const displayName = playerData?.playerName || "Player";
    const online = playerData?.online || true;

    const security = playerData?.security || 1;
    const techStrength = playerData?.techStrength || 1;
    const health = playerData?.health || 100;
    const inCombat = playerData?.inCombat || false;
    const trainingMode = playerData?.trainingMode || true;


 


    if (!sprite) {
      sprite = scene.add.container(
        pos.x * TILE_SIZE + TILE_SIZE / 2,
        pos.y * TILE_SIZE + TILE_SIZE / 2
      );

        // Optional: Add a white border using graphics
  const border = scene.add.circle(
    pos.x,
    pos.y,
    TILE_SIZE * 0.45,
    0xffffff,
    0.2
  ).setStrokeStyle(2, 0xffffff).setDepth(0);

      // Avatar Image
      const avatarKey = playerData?.avatarImage || "avatar1"; // default
      const avatarImage = scene.add.image(0, -10, avatarKey )
        .setDisplaySize(TILE_SIZE * 0.8, TILE_SIZE * 0.8)
        .setOrigin(0.5);

      // Player name below avatar
      const nameText = scene.add.text(0, TILE_SIZE * 0.4, displayName, {
        fontSize: '12px',
        color: '#ffffff',
        align: 'center',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      sprite.add([avatarImage, nameText]);
      otherPlayerSprites.set(playerId, sprite);
    } else {
      sprite.setPosition(
        pos.x * TILE_SIZE + TILE_SIZE / 2,
        pos.y * TILE_SIZE + TILE_SIZE / 2
      );
    }
  }

// Example use
loadTileData(); // Make sure tileDataMap is populated
renderAllOwnedTiles(scene);

  console.log("‚úÖ Render Complete. Current Sprites:", Array.from(otherPlayerSprites.keys()));
}

async function loadTileData() {
  const tilesSnapshot = await getDocs(collection(db, "tiles"));
  tileDataMap = new Map();

  tilesSnapshot.forEach(doc => {
    const data = doc.data();
    tileDataMap.set(doc.id, data);
  });
}
function renderAllOwnedTiles(scene) {
  console.log("üé® Rendering All Owned Tiles...");
  console.log("üì¶ Tile Map Size:", tileDataMap?.size || 0);

  // Remove outdated tiles
  for (const [tileId, sprite] of tileSpriteMap.entries()) {
    if (!tileDataMap.has(tileId)) {
      console.log(`‚ùå Removing old tile sprite: ${tileId}`);
      sprite.destroy();
      tileSpriteMap.delete(tileId);
    }
  }

  for (const [tileId, tile] of tileDataMap.entries()) {
    const { x, y, icon, level, ownerName, color, label, ownerID } = tile;
    if (x == null || y == null || !ownerID) continue;

    const spriteKey = `${x}_${y}`;

    // Already rendered, just reposition
    if (tileSpriteMap.has(spriteKey)) {
      const existing = tileSpriteMap.get(spriteKey);
      existing.setPosition(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
      continue;
    }

    console.log(`üß± Drawing tile ${label} at (${x}, ${y})`);

    const container = scene.add.container(
      x * TILE_SIZE + TILE_SIZE / 2,
      y * TILE_SIZE + TILE_SIZE / 2
    );

    const border = scene.add.circle(0, 0, TILE_SIZE * 0.4, color || 0x00ff00, 0.2)
      .setStrokeStyle(2, color || 0x00ff00)
      .setDepth(0);

    const iconText = scene.add.text(0, -5, icon || "üè†", {
      fontSize: '16px',
      fontStyle: 'bold',
      color: '#ffffff'
    }).setOrigin(0.5);

    const nameText = scene.add.text(0, TILE_SIZE * 0.25, ownerName || "Owner", {
      fontSize: '10px',
      color: '#cccccc'
    }).setOrigin(0.5);

    container.add([border, iconText, nameText]);
    tileSpriteMap.set(spriteKey, container);
  }

  console.log("‚úÖ Tile Render Complete. Tiles drawn:", tileSpriteMap.size);
  updateStatsUI();
}

function showMessageModal(title, message) {
  document.getElementById("messageModalTitle").textContent = title;
  document.getElementById("messageModalBody").textContent = message;

  const modal = new bootstrap.Modal(document.getElementById('messageModal'));
  modal.show();
    updateStatsUI();
}

</script>

</body>
</html>
