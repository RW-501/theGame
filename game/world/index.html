<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }

    #game-container {
      position: relative;
      margin: auto;
      width: 1000px;
      max-width: 100vw;
      height: 100vh;
      background: #222;
      box-shadow: 0 0 15px #333;
    }

    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }
  </style>
</head>
<body>

<div id="game-container"></div>

<div class="info-box" id="statsBox">
  üí∞ <span id="cash">$0</span> |
  üîÅ Trades Left: <span id="trades">2</span> |
  ‚ù§Ô∏è <span id="health">100%</span>
  <div id="zoneName">Zone: Loading...</div>
</div>

<div id="tileTooltip"></div>

<!-- Market Modal -->
<div class="modal fade" id="marketModal" tabindex="-1" aria-labelledby="marketLabel" aria-hidden="true">
  <div class="modal-dialog"><div class="modal-content">
    <div class="modal-header"><h5 class="modal-title">Market</h5></div>
    <div class="modal-body">
      <p>Buy stocks, check prices, and trade.</p>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </div>
  </div></div>
</div>

<script type="module">
import { initializeFirebase, auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import { collection, doc, getDoc, getDocs, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

initializeFirebase();

const TILE_SIZE = 40;
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;

onAuthStateChanged(auth, async (user) => {
  if (user) {
    uid = user.uid;

    const userRef = doc(db, "users", uid);
    const snap = await getDoc(userRef);
    if (!snap.exists()) {
      await setDoc(userRef, {
        username: "Player" + Math.floor(Math.random() * 1000),
        trainingMode: true,
        cash: 10000,
        level: 1,
        techStrength: 1,
        security: 1,
        health: 100,
        assets: { car: 0, home: 0 },
        safe: true,
        location: [5, 5],
      });
    }
  } else {
    await signInAnonymously(auth);
  }
});

// Zone colors and icons (use emojis for fun)
const zoneInfo = {
  empty: { color: 0xffffff, label: "Wilderness", icon: "üå≤" },
  home: { color: 0x90caf9, label: "Home Base", icon: "üè†" },
  market: { color: 0xa5d6a7, label: "Market", icon: "üõí" },
  training: { color: 0xffcc80, label: "Training Center", icon: "üéØ" },
  safe: { color: 0xce93d8, label: "Safe House", icon: "üõ°Ô∏è" },
  blocked: { color: 0x555555, label: "Blocked Area", icon: "üöß" }
};

let mapData = []; // 2D array [y][x] = zoneType
let playersData = new Map();

const config = {
  type: Phaser.AUTO,
  width: TILE_SIZE * MAP_SIZE,
  height: TILE_SIZE * MAP_SIZE,
  parent: "game-container",
  backgroundColor: "#222222",
  scene: {
    preload,
    create,
    update
  }
};

let playerX = 0, playerY = 0;
let playerSprite;
let graphics;
let cursors;
let otherPlayerSprites = new Map();
let isMoving = false;
let moveTween;
let tileTooltip = document.getElementById("tileTooltip");

const game = new Phaser.Game(config);

function preload() {
  // load any assets here if you want later
}

async function create() {
  graphics = this.add.graphics();

  await loadMapFromFirebase();
  drawMap(this);

  // Player sprite: blue circle with white border
  playerSprite = this.add.circle(playerX * TILE_SIZE + TILE_SIZE/2, playerY * TILE_SIZE + TILE_SIZE/2, TILE_SIZE * 0.4, 0x0000ff);
  playerSprite.setStrokeStyle(3, 0xffffff);

  cursors = this.input.keyboard.createCursorKeys();

  this.input.keyboard.on('keydown', (event) => {
    if (isMoving) return;
    switch(event.code) {
      case 'ArrowLeft': tryMove(-1, 0, this); break;
      case 'ArrowRight': tryMove(1, 0, this); break;
      case 'ArrowUp': tryMove(0, -1, this); break;
      case 'ArrowDown': tryMove(0, 1, this); break;
    }
  });

  // Pointer input: click adjacent tile to move
  this.input.on('pointerdown', pointer => {
    if (isMoving) return;
    const clickedX = Math.floor(pointer.x / TILE_SIZE);
    const clickedY = Math.floor(pointer.y / TILE_SIZE);

    if (clickedX >= 0 && clickedX < MAP_SIZE && clickedY >= 0 && clickedY < MAP_SIZE) {
      if (isAdjacent(playerX, playerY, clickedX, clickedY)) {
        tryMove(clickedX - playerX, clickedY - playerY, this);
      }
    }
  });

  // Show tile tooltip on pointer move
  this.input.on('pointermove', pointer => {
    const x = Math.floor(pointer.x / TILE_SIZE);
    const y = Math.floor(pointer.y / TILE_SIZE);
    if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
      const zoneType = mapData[y]?.[x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;
      tileTooltip.style.left = (pointer.x + 15) + "px";
      tileTooltip.style.top = (pointer.y + 15) + "px";
      tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
      tileTooltip.style.display = "block";
    } else {
      tileTooltip.style.display = "none";
    }
  });

  this.input.on('pointerout', () => {
    tileTooltip.style.display = "none";
  });

  // Listen for own player position changes
  const playerRef = doc(db, "players", uid);
  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const pos = docSnap.data().position;
      if (pos && (pos.x !== playerX || pos.y !== playerY)) {
        playerX = pos.x;
        playerY = pos.y;
        movePlayerSmoothly(this, playerX, playerY);
        updateZoneName();
      }
    }
  });

  // Listen for all players data to show other players
  const playersCollection = collection(db, "players");
  onSnapshot(playersCollection, (querySnapshot) => {
    playersData.clear();
    querySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.position) {
        playersData.set(doc.id, data.position);
      }
    });
    renderAllPlayers(this);
  });

  updateZoneName();
}

function update() {
  // nothing needed here for now
}

function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}

function drawMap(scene) {
  graphics.clear();
  for (let y=0; y < MAP_SIZE; y++) {
    for (let x=0; x < MAP_SIZE; x++) {
      const type = mapData[y]?.[x] || "empty";
      const info = zoneInfo[type] || zoneInfo.empty;

      // draw colored tile
      graphics.fillStyle(info.color, 1);
      graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

      // draw tile border
      graphics.lineStyle(2, 0x999999);
      graphics.strokeRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);

      // draw emoji icon centered
      const iconText = scene.add.text(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, info.icon, {
        fontSize: '24px',
        align: 'center'
      });
      iconText.setOrigin(0.5);
      iconText.setDepth(1);

      // make home tile clickable with pointer cursor and interactive
      if (type === "home") {
        iconText.setInteractive({ useHandCursor: true });
        iconText.on('pointerdown', () => {
          window.location.href = platformURL;
        });
        iconText.on('pointerover', () => {
          iconText.setStyle({ fill: '#0000ff', fontStyle: 'bold' });
        });
        iconText.on('pointerout', () => {
          iconText.setStyle({ fill: '#000000', fontStyle: 'normal' });
        });
      }
    }
  }
}

async function tryMove(dx, dy, scene) {
  const newX = Phaser.Math.Clamp(playerX + dx, 0, MAP_SIZE - 1);
  const newY = Phaser.Math.Clamp(playerY + dy, 0, MAP_SIZE - 1);

  if (mapData[newY]?.[newX] === "blocked") {
    alert("üöß You cannot move there! This area is blocked.");
    return;
  }

  isMoving = true;

  // Smooth move player sprite to new tile with tween
  await movePlayerSmoothly(scene, newX, newY);

  playerX = newX;
  playerY = newY;
  updateZoneName();

  // Handle zone events
  await handleZoneEvent(mapData[playerY]?.[playerX]);

  // Update Firestore with position and timestamp
  await setDoc(doc(db, "players", uid), {
    position: { x: playerX, y: playerY },
    updatedAt: new Date().toISOString()
  }, { merge: true });

  isMoving = false;
}

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}

function updateZoneName() {
  const zoneType = mapData[playerY]?.[playerX] || "empty";
  const label = zoneInfo[zoneType]?.label || "Unknown";
  document.getElementById("zoneName").textContent = `Zone: ${label}`;
}

async function handleZoneEvent(zoneType) {
  if (!zoneType) return;

  switch(zoneType) {
    case "market":
      new bootstrap.Modal(document.getElementById("marketModal")).show();
      break;
    case "training":
      alert("üéØ You have entered the Training Center! Time to improve your skills.");
      break;
    case "safe":
      alert("üõ°Ô∏è You are in a Safe House. Take a moment to rest.");
      break;
    case "home":
      // Redirect on clicking the home tile is handled by icon click, but also do here on arrival:
      if (confirm("Welcome home! Do you want to go to your platform?")) {
        window.location.href = platformURL;
      }
      break;
    default:
      // wilderness or others: no special action
      break;
  }
}

async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  mapData = [];
  for(let y=0; y<MAP_SIZE; y++) {
    const row = [];
    for(let x=0; x<MAP_SIZE; x++) {
      if(x === 5 && y === 5) row.push("home");
      else if(x === 10 && y === 8) row.push("market");
      else if(x === 17 && y === 12) row.push("training");
      else if(x === 22 && y === 20) row.push("safe");
      else if(x >= 15 && x <= 18 && y >= 15 && y <= 18) row.push("blocked");
      else row.push("empty");
    }
    mapData.push(row);
  }
}

// Render other players except local player
function renderAllPlayers(scene) {
  // Remove old sprites no longer in playersData
  for (const [key, sprite] of otherPlayerSprites) {
    if (!playersData.has(key) || key === uid) {
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }

  // Draw other players as red circles with initials
  for (const [playerId, pos] of playersData.entries()) {
    if (playerId === uid) continue;
    if (!pos) continue;

    let sprite = otherPlayerSprites.get(playerId);
    if (!sprite) {
      // Create a container with red circle and initials text
      sprite = scene.add.container(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);

      const circle = scene.add.circle(0, 0, TILE_SIZE * 0.4, 0xff4444);
      circle.setStrokeStyle(2, 0xffffff);

      const initials = scene.add.text(0, 0, playerId.substring(0, 2).toUpperCase(), {
        fontSize: '16px',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      sprite.add([circle, initials]);
      otherPlayerSprites.set(playerId, sprite);
    } else {
      sprite.setPosition(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);
    }
  }
}

</script>

</body>
</html>
