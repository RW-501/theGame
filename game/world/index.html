<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Wars Enhanced World Map</title>
<link rel="icon" type="image/png" href="https://img.icons8.com/external-wanicon-lineal-color-wanicon/64/external-bank-stock-market-wanicon-lineal-color-wanicon.png">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body, html {
      margin: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      overflow: hidden;
    }

#game-container {
  position: relative;
  margin: auto;
  width: fit-content;
  max-width: 100vw;
  max-height: fit-content;
  margin: 5rem;
  /*
 background: #222;
  box-shadow: 0 0 15px #333;
  */

  canvas {
    margin-bottom: 20rem;
}
}


    .info-box {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255 255 255 / 0.85);
      padding: 12px 18px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 16px;
      color: #222;
      z-index: 10;
      user-select: none;
      width: 260px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      user-select: none;

    }

    .stats-row {
  margin-bottom: 6px;
  line-height: 1.4;
}

.stats-row:last-child {
  margin-bottom: 0;
  font-weight: bold;
  color: #ffd700; /* Gold color for zone */
}

.info-box span {
  font-weight: 600;
  color: #90caf9;
  padding: 0 3px;
}
    #zoneName {
      margin-top: 8px;
      font-size: 18px;
      color: #333;
    }

    /* Tooltip for tiles */
    #tileTooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.75);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      user-select: none;
    }

    .damage-popup {
  position: absolute;
  color: red;
  font-weight: bold;
  animation: floatUp 1.2s ease-out;
}

@keyframes floatUp {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}

:root {
  --accent: #28a745;
  --accent-hover: #218838;
  --bg-dark: #fff;
  --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

#userTool {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-end;
}

#userTool button {
  background-color: var(--accent);
  color: var(--bg-dark);
  padding: 10px 14px;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  box-shadow: var(--shadow);
  transition: background-color 0.3s ease, transform 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
}

#userTool button:hover {
  background-color: var(--accent-hover);
  transform: translateY(-2px);
}

#notifBellBtn {
  position: relative;
  background-color: var(--accent);
}

/*
#notifBadge {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: #dc3545;
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 50%;
  display: none;
}

#openChatBtn {
  position: fixed;
  bottom: 90px; 
  right: 20px;
  z-index: 2000;
  padding: 12px 16px;
  border-radius: 50%;
  background: var(--accent);
  color: var(--bg-dark);
  border: none;
  cursor: pointer;
  box-shadow: var(--shadow);
  font-size: 20px;
}

*/


.tile-highlight {
  outline: 3px solid gold;
  z-index: 999;
}



.blink {
  animation: blink-glow 1.2s infinite alternate;
}

@keyframes blink-glow {
  from {
    box-shadow: 0 0 0px transparent;
  }
  to {
    box-shadow: 0 0 8px 3px lime;
  }
}


/* Modal Glassy Background */
#tileActionModal .modal-content {
  background: rgba(20, 20, 30, 0.95);
  border: 2px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 0 12px #4caf50cc;
  font-family: 'Orbitron', sans-serif;
  color: #e0e0e0;
}

/* Header Style */
#tileActionModal .modal-header {
  border-bottom: 1px solid #555;
  background-color: rgba(0, 0, 0, 0.3);
  color: #fff;
}

/* Tile Info Card */
#tileActionModal .card {
  background-color: #1f1f2b;
  border: 1px solid #333;
  border-radius: 10px;
  color: #ddd;
}

/* Card Title */
#tileActionModal .card-title {
  color: #4caf50;
  font-weight: bold;
  font-size: 1.2rem;
}

/* Row Labels */
#tileActionModal .row strong {
  color: #90caf9;
}

/* Modal Footer Buttons */
#tileActionModal .modal-footer .btn {
  border-radius: 8px;
  font-size: 1rem;
  padding: 10px 18px;
  font-weight: 600;
  transition: 0.3s ease;
}

#tileActionModal .btn-success {
  background-color: #4caf50;
  border-color: #4caf50;
}

#tileActionModal .btn-success:hover {
  background-color: #66bb6a;
}

#tileActionModal .text-danger {
  color: #e53935 !important;
}

#tileActionModal .text-success {
  color: #66bb6a !important;
}

  </style>
</head>
<body>

  <main>
<div class="d-flex justify-content-center align-items-center vh-100">
  <div id="game-container"></div>
</div>

<div class="info-box" id="statsBox">
  <div class="stats-row">
    üéñÔ∏è Level: <span id="level">0</span> |
    üí∞ xp: <span id="xp">$0</span> |
    üè¶ Bank: <span id="bank">$0</span> |
    ü™ô Crypto: <span id="crypto">0</span> |
    üîÅ Trades Left: <span id="trades">2</span>
  </div>
  <div class="stats-row">
    ‚ù§Ô∏è Health: <span id="health">100%</span> |
    üõ°Ô∏è Security: <span id="security">0</span> |
    üß† Tech Strength: <span id="techStrength">0</span>
  </div>
  <div class="stats-row" id="zoneName">
    üìç Zone: <span>Loading...</span>
  </div>
</div>

<div id="tileTooltip"></div>


<div id="userTool">
  <button id="returnToLocationBtn">üìç Return to My Location</button>
  <button id="goToPlatformBtn">üåê Go to Platform</button>
  <button id="openOwnedBtn">üì¶ Assets</button>

  <!-- Notification Bell Button -->
  <button id="notifBellBtn">
    üîî
    <span id="notifBadge">!</span>
  </button>

<button id="openChatBtn" title="Open Chat">
  üí¨
</button>
</div>


</main>


<!-- Market Modal -->
<div class="modal fade" id="marketModal" tabindex="-1" aria-labelledby="marketLabel" aria-hidden="true">
  <div class="modal-dialog"><div class="modal-content">
    <div class="modal-header"><h5 class="modal-title">Market</h5></div>
    <div class="modal-body">
      <p>Buy stocks, check prices, and trade.</p>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </div>
  </div></div>
</div>

<!-- Tile Actions Modal -->
<div class="modal fade game-modal" id="tileActionModal" tabindex="-1" aria-labelledby="tileActionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="tileActionLabel">Tile Actions</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="tileActionBody">
        <!-- Dynamic content here -->
      </div>
      <div class="modal-footer" id="tileActionFooter">
        <!-- Buttons added dynamically -->
      </div>
    </div>
  </div>
</div>


<!-- ATTACK Modal -->
<div class="modal fade" id="attackModal" tabindex="-1" aria-labelledby="attackLabel" aria-hidden="true">
  <div class="modal-dialog modal-md modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="attackLabel">üí£ Attack Panel</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <ul id="attackTargets" class="list-group mb-3" style="max-height: 250px; overflow-y: auto;"></ul>
        <div class="mb-3">
          <label for="attackMethod" class="form-label">Attack Method:</label>
          <select id="attackMethod" class="form-select">
            <option value="brute_force">Brute Force</option>
            <option value="social_engineering">Social Engineering</option>
            <option value="bot_attack">Bot Attack</option>
          </select>
        </div>
        <button id="attackBtn" class="btn btn-danger w-100">Launch Attack</button>
        <div id="attackMessage" class="mt-2 fw-semibold text-danger"></div>
      </div>
    </div>
  </div>
</div>

<!-- HACKER Modal -->
<div class="modal fade" id="hackerModal" tabindex="-1" aria-labelledby="hackerLabel" aria-hidden="true">
  <div class="modal-dialog modal-md modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="hackerLabel">üë®‚Äçüíª Hacker Tools</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body text-center">
        <div class="d-grid gap-2 mb-3">
          <button id="spyBtn" class="btn btn-outline-primary">üïµÔ∏è Spy</button>
          <button id="corruptBtn" class="btn btn-outline-warning">üíº Corrupt Trade</button>
          <button id="stealBtn" class="btn btn-outline-danger">üìÇ Steal Data</button>
        </div>
        <div id="hackerStatus" class="fw-bold text-info"></div>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="tileActionModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Tile Action</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="tileActionBody"></div>
      <div class="modal-footer" id="tileActionFooter"></div>
    </div>
  </div>
</div>


<!-- Message Modal -->
<div class="modal fade" id="messageModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="messageModalTitle">Message</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="messageModalBody">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>


<!-- Asset Viewer Modal -->
<!-- Owned Assets Modal -->
<div class="modal fade" id="ownedModal" tabindex="-1" aria-labelledby="ownedModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="ownedModalLabel">Your Owned Land & Companies</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <div class="modal-body">
        <div class="mb-3">
          <label for="sortFilter" class="form-label">Sort By:</label>
          <select class="form-select" id="sortFilter">
            <option value="value">Value</option>
            <option value="taxRate">Tax Rate</option>
          </select>
        </div>

        <ul id="ownedList" class="list-group">
          <!-- Dynamically generated list items will be injected here -->
        </ul>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<div class="modal fade" id="startCompanyModal" tabindex="-1" aria-labelledby="startCompanyLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
    
      <div class="modal-header">
        <h5 class="modal-title" id="startCompanyLabel">Start a Company</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>

      <div class="modal-body">
        <label for="sectorSelect">Choose a Sector:</label>
        <select class="form-select mb-3" id="sectorSelect">
          <option value="tech">Tech</option>
          <option value="energy">Energy</option>
          <option value="healthcare">Healthcare</option>
          <option value="finance">Finance</option>
          <option value="transport">Transportation</option>
        </select>

        <label for="companyNameInput">Company Name:</label>
        <input type="text" id="companyNameInput" class="form-control mb-3" placeholder="e.g., NovaTech Inc.">

        <label for="stockSymbolInput">Stock Symbol (3‚Äì5 uppercase letters):</label>
        <input type="text" id="stockSymbolInput" class="form-control" maxlength="5" placeholder="e.g., NTV">
      </div>

      <div class="modal-footer">
        <button class="btn btn-success" id="confirmStartCompanyBtn">Confirm</button>
      </div>

    </div>
  </div>
</div>



<script type="module">
import {  auth, db , onAuthStateChanged, signInAnonymously } from "https://rw-501.github.io/theGame/firebase/firebase-config.js";
import {   getFirestore,  query,
  where, limit, addDoc ,
  arrayRemove, increment, serverTimestamp, 
  arrayUnion, collection, doc, getDoc, getDocs, onSnapshot, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { initLiveNotifications } from 'https://rw-501.github.io/theGame/game/includes/notifications.js'; // Adjust path as needed
import {  } from 'https://rw-501.github.io/theGame/game/includes/chat.js'; // Adjust path as needed

document.addEventListener("DOMContentLoaded", () => {
  const notifBtn = document.getElementById("notifBellBtn");

  if (notifBtn) {
notifBtn.addEventListener("click", () => {
  // Just show modal
  new bootstrap.Modal(document.getElementById("notifModal")).show();
});
  }
});


// === Game Constants ===
const TILE_SIZE = 64; 
const MAP_SIZE = 25;
const platformURL = "https://rw-501.github.io/theGame/game/platform/";

let uid;
let playerData = {};
let playerSprite;
let isMoving = false;
let playerX = 5, playerY = 5; // Default fallback
let graphics, cursors;
let mapData = [];
let otherPlayerSprites = new Map();


const playerState = new Map();

// === Zone Metadata ===
// === Zone Metadata ===
const zoneInfo = {
  empty: {
    color: 0xffffff,
    label: "Wilderness",
    type: "empty",
    icon: "üå≤",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/trees/tree-small.png', // fixed slashes and removed extra quotes
    price: 1000,
    income: 0,
    taxRate: 0.8,
    value: 500,
    unlocked: true
  },
  playerHome: {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    icon: "üè†",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png', // fixed slashes and removed extra quotes
    price: 0,
    income: 1,
    taxRate: 0.5,
    value: 100,
    unlocked: true
  },
  company: {
    color: 0x90caf9,
    label: "Company",
    type: "company",
    icon: "üè¢",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/industrial/building-0.png', // fixed slashes and removed extra quotes
    price: 1500,
    income: 0,
    taxRate: 10,
    value: 500,
    unlocked: false
  },
  blocked: {
    color: 0x555555,
    label: "Blocked Area",
    type: "blocked",
    icon: "üöß",
    price: 0,
    income: 0,
    taxRate: 0,
    value: 0,
    unlocked: false
  },
  stockMarket: {
    color: 0xffd54f,
    label: "Stock Exchange",
    type: "stockMarket",
    icon: "üìà",
    tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/building.png', // fixed slashes and removed extra quotes
    price: 50000000,
    income: 100000,
    taxRate: 0.25,
    value: 10000000,
    unlocked: false
  },
  // 12 Custom Zones with Incremental Pricing
  ...(() => {
    const zones = {};
    const basePrice = 5000;      // start price at 5000 for Zone 1
    const priceStep = -400;      // negative step to decrease price per zone (adjust as needed)

    const incomeStep = 25;
    const valueStep = 500;
    const baseTax = 0.1;

    const zoneColors = [
      0x9575cd, 0x4fc3f7, 0x4db6ac, 0x81c784, 0xffb74d,
      0xa1887f, 0xe57373, 0xba68c8, 0x64b5f6, 0x81c784,
      0xff8a65, 0xaed581
    ];

    const zoneIcons = [
      "üåÜ", "üèôÔ∏è", "üåÉ", "üèóÔ∏è", "üè¨",
      "üè¢", "üè†", "üèòÔ∏è", "üèöÔ∏è", "üèõÔ∏è",
      "üè®", "üïå"
    ];

    for (let i = 1; i <= 12; i++) {
      const price = basePrice + priceStep * (i - 1);  // decreases price for each subsequent zone
      zones[`zone${i}`] = {
        color: zoneColors[i - 1] || 0xcccccc,
        label: `Zone ${i}`,
        type: "zone",
        icon: zoneIcons[i - 1] || "üèôÔ∏è",
        tileImage: 'https://rw-501.github.io/theGame/game/images/tile_images/commercial/building-0.png', // fixed slashes and removed extra quotes
        price,
        level: 1,
        income: 50 + incomeStep * (i - 1),
        taxRate: parseFloat((baseTax + i * 0.01).toFixed(2)),
        value: price + valueStep * (i - 1),
        unlocked: i <= 3 // unlock first 3 zones by default
      };
    }

    return zones;
  })()
};


async function loadMapFromFirebase() {
  try {
    const snapshot = await getDocs(collection(db, "mapTiles"));
    if (snapshot.empty) {
      setDefaultMapData();
      return;
    }

    mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

    snapshot.forEach(doc => {
      const { x, y, type } = doc.data();
      if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
        mapData[y][x] = type || "empty";
      }
    });
  } catch (e) {
    console.error("Failed to load map from Firebase, using default.", e);
    setDefaultMapData();
  }
}

function setDefaultMapData() {
  mapData = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill("empty"));

  const centerX = 12;
  const centerY = 12;
  mapData[centerY][centerX] = "stockMarket";

  for (let y = centerY - 6; y <= centerY + 6; y++) {
    for (let x = centerX - 6; x <= centerX + 6; x++) {
      if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) continue;
      if (x === centerX && y === centerY) continue;

      const dist = Math.max(Math.abs(x - centerX), Math.abs(y - centerY));
      if (dist >= 1 && dist <= 12) {
        mapData[y][x] = `zone${dist}`;
      }
    }
  }
}

let game;
let scene;
let cam;
let newZoom;
let isPointerDown; 

function getRandomEmptyTile(mapData) {
  const emptyTiles = [];

  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      if (mapData[y][x] === "empty") {
        emptyTiles.push([x, y]);
      }
    }
          //  console.log("emptyTiles   ", emptyTiles);

  }

  if (emptyTiles.length === 0) {
    console.warn("‚ö†Ô∏è No empty tiles found. Defaulting to [5, 5].");
    return [5, 5];
  }

  return emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
}


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// === Firebase Login Check ===
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = 'https://rw-501.github.io/theGame';
    return;
  }

let MapWidth = (TILE_SIZE * MAP_SIZE) / 2;


// === Game Setup ===
const config = {
  type: Phaser.AUTO,

width: MapWidth, // window.innerWidth,
height: MapWidth, //window.innerHeight,


  parent: "game-container",
  backgroundColor: "#222222",
  scene: { preload, create, update }
};

 game = new Phaser.Game(config);

  uid = user.uid;

    
 // Add a 200ms delay before continuing
  await sleep(200);

  try {
 
    setTimeout(async () => {
      /*
console.log("First row:", mapData[0]);         // Logs the first row (an array of 25)
console.log("First tile:", mapData[0][0]);     // Logs the first tile
console.table(mapData);                        // Displays a visual table
      */


      // ‚úÖ Get a random empty tile
  const randomLocation = getRandomEmptyTile(mapData);



  // Query the player with userID === uid and server === "main"
const q = query(
  collection(db, "players"),
  where("userID", "==", uid),
  where("server", "==", "main"),
  limit(1)
);

const querySnapshot = await getDocs(q);

if (!querySnapshot.empty) {
const docSnap = querySnapshot.docs[0];
playerData = docSnap.data();
playerData.id = docSnap.id; // store doc ID
playerData.isNew = false;

const [x, y] = playerData.location;
playerX = x;
playerY = y;

cam.setZoom(newZoom);

// ‚úÖ Center camera on player location
//const TILE_SIZE = 64; // or whatever your tile size is
cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);

  console.log("playerY   ", playerY);

  if (playerData.location === 'start') {

    playerData.location = randomLocation;

  const [x, y] =  randomLocation;
  playerX = x;
  playerY = y;
    // Update the location in Firestore
    const docRef = doc(db, "players", docSnap.id);
    await updateDoc(docRef, { location: randomLocation, playerX, playerY });
  }
 } else {
          // Initialize player location
  const [x, y] =  randomLocation;
    // No player found, create a new one
    const newPlayer = {
      playerUid: "", // will be updated below
      userID: uid,
      playerName: user.displayName || "Player" + Math.floor(Math.random() * 1000),
      avatarImage: 'https://robohash.org/1?size=50x50',
      status: "active",
      lastUpdate: serverTimestamp(),
      online: true,
      server: "main",

      location: randomLocation, // ‚úÖ Assigned here
      playerX: x,
      playerY: y,

      isNew: true,
      trainingMode: true,

      crypto: 5,
      xp: 0,
      level: 1,
      bank: 1000,
      vault: [],
      loans: [],
      health: 100,
      techStrength: 1,
      security: 1,

      landOwned: [],
      jobs: [],
      companiesOwned: [],
      stocks: [],
      trades: 0,
      tradesTotal: 0,
      portfolio: [],
      inCombat: false,
      attacks: 0,
      attacked: 0,
      inventory: [],
      history: [],
      createdAt: serverTimestamp()
    };

    // Create new player document
    const docRef = await addDoc(collection(db, "players"), newPlayer);
    const newId = docRef.id;

    // Update the playerUid in Firestore
    await updateDoc(docRef, { playerUid: newId });

    // Set locally
    newPlayer.id = newId;
    newPlayer.playerUid = newId;
    playerData = newPlayer;
  }

           
const playerRef = doc(db, "players", playerData.playerUid);

// Define the tile ID based on player's current position
const tileId = `${playerX}_${playerY}`;
const tileRef = doc(db, "tiles", tileId);
const tileSnap = await getDoc(tileRef);

if (!tileSnap.exists()) {
  const defaultTileData = {
    color: 0x90caf9,
    label: "Home Base",
    type: "home",
    level: 1,
    icon: "üè†",
    tileImage: "https://rw-501.github.io/theGame/game/images/tile_images/suburban/building-type-0.png",
    price: 0,
    income: 100,
    taxRate: 10,
    value: 1000,
    unlocked: false,
    ownerID: playerData.playerUid,
    ownerName: playerData.playerName,
    createdAt: Date.now(),
  };

  await setDoc(tileRef, defaultTileData);
} else {
  /*
  // Optional: update existing tile with some info (if needed)
  await updateDoc(tileRef, {
    unlocked: true
  });
  */
}




// Example: Update player data if needed
await updateDoc(playerRef, {
  landOwned: [tileId]
});


  // Save player data locally
  localStorage.setItem("theGame_currentPlayerData", JSON.stringify(playerData));

  // Store in playerState map
  playerState.set(uid, playerData);

 

  console.log("‚úÖ Player loaded:", playerData);
  updateStatsUI();
}, 1000);


  } catch (error) {
    console.error("‚ùå Error loading player:", error);
  }

});



const tileTooltip = document.getElementById("tileTooltip");


function centerCameraOnPlayer() {
  cam.setZoom(newZoom);

cam.centerOn(playerX * TILE_SIZE + TILE_SIZE / 2, playerY * TILE_SIZE + TILE_SIZE / 2);
}


async function initializeMap(scene) {
  // Assuming graphics and playerSprite are globals or declared elsewhere
  graphics = scene.add.graphics();
   cam = scene.cameras.main;

  // Await loading map data before drawing
  await loadMapFromFirebase();

  // Draw the map based on loaded data
  drawMap(scene);

  /*
  // Create player sprite at current player position
  playerSprite = scene.add.circle(
    playerX * TILE_SIZE + TILE_SIZE / 2,
    playerY * TILE_SIZE + TILE_SIZE / 2,
    TILE_SIZE * 0.4,
    0x0000ff
  );
  playerSprite.setStrokeStyle(3, 0xffffff);
*/


  const mapWidth = MAP_SIZE * TILE_SIZE;
  const mapHeight = MAP_SIZE * TILE_SIZE;
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  // Calculate zoom to fit entire map inside screen
  const zoomX = screenWidth / mapWidth;
  const zoomY = screenHeight / mapHeight;
  const zoom = Math.min(zoomX, zoomY, 1); // Limit max zoom to 1 (optional)

  // Set camera bounds to map size
  cam.setBounds(0, 0, mapWidth, mapHeight);

  // Set camera zoom to fit map
  cam.setZoom(zoom);

  // Center camera on map
  // This centers by scrollX/Y, not centerOn (better control)
  cam.scrollX = (mapWidth / 2) - (screenWidth / (2 * zoom));
  cam.scrollY = (mapHeight / 2) - (screenHeight / (2 * zoom));

  updateStatsUI();
}

function drawMap(scene) {
  graphics.clear();

  // Load avatar image
scene.load.image('playerAvatar', playerData.avatarImage || 'https://robohash.org/3?size=50x50');

// After load completes
scene.load.once('complete', () => {
  // Create player avatar image sprite
  playerSprite = scene.add.image(
    playerX * TILE_SIZE + TILE_SIZE / 2,
    playerY * TILE_SIZE + TILE_SIZE / 2,
    'playerAvatar'
  ).setDisplaySize(TILE_SIZE * 0.8, TILE_SIZE * 0.8).setDepth(1);

  console.log("Player sprite created:", playerSprite);

  // Optional: Add a white border using graphics
  const border = scene.add.circle(
    playerSprite.x,
    playerSprite.y,
    TILE_SIZE * 0.45,
    0xffffff,
    0.2
  ).setStrokeStyle(2, 0xffffff).setDepth(0);

  // Add player name text below avatar
  const nameText = scene.add.text(
    playerSprite.x,
    playerSprite.y + TILE_SIZE * 0.45,
    state.playerName || 'Player',
    {
      font: '12px Arial',
      fill: '#ffffff',
      align: 'center',
    }
  ).setOrigin(0.5, 0).setDepth(2);

  // ‚ùå Remove tile under player
  const tileX = playerX;
  const tileY = playerY;

  if (mapData[tileY] && mapData[tileY][tileX]) {
    console.log(`Removing tile at [${tileX}, ${tileY}] with value:`, mapData[tileY][tileX]);
    mapData[tileY][tileX] = "empty"; // Or null or undefined based on your system
    renderTile(tileX, tileY); // Call your tile rendering function to visually update
  }
});
function renderTile(x, y) {
  // Logic to clear and re-render that tile (e.g., blank out if set to "empty")
  const tile = mapData[`${x},${y}`];
  if (tile) {
    tile.destroy(); // remove the tile sprite if it exists
    delete mapData[`${x},${y}`];
  }

  // Optionally draw something else (e.g., dirt/grass tile for empty)
}

scene.load.start();





  for (let y = 0; y < MAP_SIZE; y++) {
    for (let x = 0; x < MAP_SIZE; x++) {
      const zoneType = mapData[y][x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;

      // Background fill
      graphics.fillStyle(info.color, 1);
      graphics.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

      // Draw image if available
      if (info.imageKey) {
        scene.add.image(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.imageKey
        ).setDisplaySize(TILE_SIZE, TILE_SIZE).setOrigin(0.5);
      }
      // Fallback to icon if no image
      else if (info.icon) {
        scene.add.text(
          x * TILE_SIZE + TILE_SIZE / 2,
          y * TILE_SIZE + TILE_SIZE / 2,
          info.icon,
          { font: `${TILE_SIZE * 0.3}px Arial`, align: 'center' }
        ).setOrigin(0.5);
      }
    }
  }
}



function returnToPlayerLocation(scene) {
  const cam = scene.cameras.main;
  const targetX = playerX * TILE_SIZE + TILE_SIZE / 2;
  const targetY = playerY * TILE_SIZE + TILE_SIZE / 2;

  cam.pan(targetX, targetY, 500, 'Sine.easeInOut');
}


document.getElementById("returnToLocationBtn").addEventListener("click", () => {
  returnToPlayerLocation(game.scene.scenes[0]); // or pass in your current scene reference
});

document.getElementById("goToPlatformBtn").addEventListener("click", () => {
    window.location.href = "https://rw-501.github.io/theGame/game/platform/";
});


// === Phaser Scene Methods ===
function preload() {
  // Add loading text or a bar
  const loadingText = this.add.text(
    this.cameras.main.centerX,
    this.cameras.main.centerY,
    'Loading...',
    { font: '32px Arial', fill: '#ffffff' }
  ).setOrigin(0.5);

  const usedImages = new Set(); // avoid duplicate loads

  for (const zoneKey in zoneInfo) {
    const tileData = zoneInfo[zoneKey];
    if (tileData.tileImage && !usedImages.has(tileData.tileImage)) {

      const imageKey = zoneKey + "_tile"; // already correct, just confirm uniqueness
      this.load.image(imageKey, tileData.tileImage);
      tileData.imageKey = imageKey; // store it for drawMap()
      usedImages.add(tileData.tileImage);

      console.log("imageKey ",imageKey);
      console.log("zoneKey ",zoneKey);
      console.log("tileData ",tileData);
    }
  }

  // Optional: Simulate longer loading for testing
  for (let i = 0; i < 100; i++) {
   // this.load.image(`dummy${i}`, 'path/to/dummy.png');
  }

  // Display loading progress
  this.load.on('progress', (value) => {
    loadingText.setText(`Loading... ${Math.round(value * 100)}%`);
  });

  this.load.on('complete', () => {
    loadingText.setText('Loading Complete!');
  });
}













function setupMapMovement(scene) {
  const cam = scene.cameras.main;

  // Drag to move camera

let pointer;


scene.input.on("pointermove", pointer => {
  if (pointer.isDown && isPointerDown) {
    cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
    cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;

  }
});

  // Mouse wheel zoom
  scene.input.on("wheel", (pointer, gameObjects, deltaX, deltaY) => {
     newZoom = Phaser.Math.Clamp(cam.zoom - deltaY * 0.001, 0.5, 2);
    cam.setZoom(newZoom);
  });

    cam.setZoom(newZoom);
}

function setupMapInteraction(scene) {
  cursors = scene.input.keyboard.createCursorKeys();

  scene.input.keyboard.on("keydown", event => {
    if (isMoving) return;
    switch (event.code) {
      case "ArrowLeft": tryMove(-1, 0, scene); break;
      case "ArrowRight": tryMove(1, 0, scene); break;
      case "ArrowUp": tryMove(0, -1, scene); break;
      case "ArrowDown": tryMove(0, 1, scene); break;
    }
  });

  isPointerDown = false;
let pointerDownTime = 0;
let initialPointer = null;

scene.input.on("pointerdown", pointer => {
  isPointerDown = true;
  pointerDownTime = Date.now();
  initialPointer = { x: pointer.x, y: pointer.y };
});

scene.input.on("pointerup", pointer => {
  if (!isPointerDown) return;
  isPointerDown = false;

  const timeHeld = Date.now() - pointerDownTime;
  const movedDistance = Phaser.Math.Distance.Between(pointer.x, pointer.y, initialPointer.x, initialPointer.y);

  const maxTapTime = 300;       // max press time in ms
  const maxMoveDistance = 10;   // max movement in px before cancel

  if (timeHeld <= maxTapTime && movedDistance <= maxMoveDistance) {
    const worldPoint = scene.cameras.main.getWorldPoint(pointer.x, pointer.y);
    const clickedX = Math.floor(worldPoint.x / TILE_SIZE);
    const clickedY = Math.floor(worldPoint.y / TILE_SIZE);

    if (clickedX < 0 || clickedX >= MAP_SIZE || clickedY < 0 || clickedY >= MAP_SIZE) return;

    let otherPlayerId = null;
    const entries = playerState instanceof Map
      ? playerState.entries()
      : Object.entries(playerState);

    for (const [pid, pos] of entries) {
      if (pid !== uid && pos.x === clickedX && pos.y === clickedY) {
        otherPlayerId = pid;
        break;
      }
    }

    if (!isPointerDown) {
      const tileType = mapData[clickedY]?.[clickedX] || "empty";
      showTileActionModal(clickedX, clickedY, tileType, otherPlayerId);
    }
  }
});

  scene.input.on("pointermove", pointer => {
     cam = scene.cameras.main;

    const worldPoint = cam.getWorldPoint(pointer.x, pointer.y);
    const x = Math.floor(worldPoint.x / TILE_SIZE);
    const y = Math.floor(worldPoint.y / TILE_SIZE);

    if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
      const zoneType = mapData[y]?.[x] || "empty";
      const info = zoneInfo[zoneType] || zoneInfo.empty;
      tileTooltip.style.left = pointer.x + 15 + "px";
      tileTooltip.style.top = pointer.y + 15 + "px";
      tileTooltip.innerHTML = `${info.icon} <strong>${info.label}</strong> (${x},${y})`;
      tileTooltip.style.display = "block";
    } else {
      tileTooltip.style.display = "none";
    }
  });

  scene.input.on("pointerout", () => {
    tileTooltip.style.display = "none";
  });


async function showTileActionModal(x, y, tileTypeFromCaller, otherPlayerId) {


  const modalEl = document.getElementById("tileActionModal");
  const modalBody = document.getElementById("tileActionBody");
  const modalFooter = document.getElementById("tileActionFooter");

  if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return;

    const dbTileInfo = await getTileDataAt(x, y);

const tileInfo = mapData[y]?.[x] || "empty";
const info = dbTileInfo ? dbTileInfo : zoneInfo[tileInfo] || zoneInfo.empty;

const trueType = info.type;
const now = Date.now();

// Optional checks
const isUnlocked = info.unlocked ?? true; // fallback to true if not specified
const level = info.level ?? 1;
const income = info.income ?? 0;
const value = info.value ?? info.price ?? 0;
const taxRate = info.taxRate ?? 0;

modalBody.innerHTML = `
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h5 class="card-title mb-3">üìç Tile Info</h5>
      <div class="row g-2">
        <div class="col-6"><strong>Coordinates:</strong><br>(${x}, ${y})</div>
        <div class="col-6"><strong>Tile Type:</strong><br>${info.label} ${info.icon ?? ''}</div>
        <div class="col-6"><strong>Price:</strong><br>$${info.price?.toLocaleString() ?? 'N/A'}</div>
        <div class="col-6"><strong>Value:</strong><br>$${value.toLocaleString()}</div>
        <div class="col-6"><strong>Income:</strong><br>$${income.toLocaleString()} / Weekly</div>
        <div class="col-6"><strong>Tax Rate:</strong><br>${taxRate}%</div>
        <div class="col-6"><strong>Level:</strong><br>${level}</div>
        <div class="col-6"><strong>Owner:</strong><br>${info.ownerName || "None"}</div>
        <div class="col-6">
          <strong>Status:</strong><br>
          ${isUnlocked ? `<span class="text-success">Unlocked</span>` : `<span class="text-danger">Locked</span>`}
        </div>
      </div>
    </div>
  </div>
`;


  modalFooter.innerHTML = "";

  if (trueType === "blocked") {
    modalBody.innerHTML += "<p>This area is blocked. No actions available.</p>";
    return new bootstrap.Modal(modalEl).show();
  }

  const isInCombat = playerData?.inCombat ?? false;
  const hasActions = playerData?.actionsLeft > 0;

  function isOnCooldown(action) {
    return playerData?.cooldowns?.[action] && playerData.cooldowns[action] > now;
  }

  function cooldownLeft(action) {
    return isOnCooldown(action) ? Math.ceil((playerData.cooldowns[action] - now) / 1000) : 0;
  }

  // === Player tile interaction ===
  if (otherPlayerId) {
  const playersRef = collection(db, "players");
  const q = query(playersRef, where("userID", "==", otherPlayerId));

  const otherSnap = await getDocs(q);
    const data = otherSnap.exists() ? otherSnap.data() : {};
    const info = {
      playerName: data.playerName ?? otherPlayerId.substring(0, 6),
      health: data.health ?? "??",
      level: data.level ?? "?",
      techStrength: data.techStrength ?? "?",
      security: data.security ?? "?",
      bank: data.bank ?? "?",
    };

    modalBody.innerHTML += `
      <p>Player <strong>${info.playerName}</strong> is here.</p>
      <p>Level: ${info.level}</p>
      <p>Bank: ${info.bank}</p>

      <p>Health: ${info.health}</p>
      <p>Tech Strength: ${info.techStrength}</p>
      <p>Security: ${info.security}</p>
    `;

    const attackBtn = createButton(
      `Attack${isOnCooldown("attack") ? ` (${cooldownLeft("attack")}s)` : ""}`,
      "btn btn-danger",
      async () => {
        if (isInCombat || !hasActions || isOnCooldown("attack")) return;
        await performAttack(otherPlayerId);
        bootstrap.Modal.getInstance(modalEl)?.hide();
      }
    );
    attackBtn.disabled = isInCombat || !hasActions || isOnCooldown("attack");
    modalFooter.appendChild(attackBtn);

    const talkBtn = createButton("Talk", "btn btn-primary", () => {
      showMessageModal(`Talking to ${info.playerName}...`);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    });
    talkBtn.disabled = isInCombat;
    modalFooter.appendChild(talkBtn);
  }


  if (!otherPlayerId && (trueType === "home")) {
    let homeType = 'Appartment';
    if(level > 5 ){
homeType = 'House';
    }
  const upGradeHomeBtn = createButton({
    text: `Upgrade ${homeType} `,
    className: "btn btn-success",
    onClick: async () => {
      await upgradeHomeBase(x, y, "home", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    }
  });
  modalFooter.appendChild(upGradeHomeBtn);
}


    // === Buy Land button ===
if (!otherPlayerId && isUnlocked && (trueType === "zone" || trueType === "empty")) {
  const buyLandBtn = createButton({
    text: `Buy Land $${info.price}`,
    className: "btn btn-success",
    onClick: async () => {
      await purchaseTile(x, y, "zone", false);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    }
  });
  modalFooter.appendChild(buyLandBtn);
}


if (!otherPlayerId  && isUnlocked && trueType === "company") {
  const buyCompanyBtn = createButton(`Buy Company $${info.price}`, "btn btn-warning", async () => {
    await purchaseTile(x, y, "company", false);
    bootstrap.Modal.getInstance(modalEl)?.hide();
  });
  modalFooter.appendChild(buyCompanyBtn);
}

if (!otherPlayerId  && isUnlocked && (trueType === "zone" || trueType === "empty")) {
  
    // New tile level and value
  const newLevel = level || 1;
  const newValue = info.price + 1000 + playerData.level * 200;

  const moveAndBuyBtn = createButton({
    text: `Move Here (Buy for $${newValue})`,
    className: "btn btn-primary",
    onClick: async () => {
      await purchaseTile(x, y, "zone", true);
      bootstrap.Modal.getInstance(modalEl)?.hide();
    }
  });
  modalFooter.appendChild(moveAndBuyBtn);
}

if (trueType === "company") {
  const viewEmployeesBtn = createButton("View Employees", "btn btn-primary", async () => {
    await showEmployeesModal(`${x}_${y}`);
  });
  modalFooter.appendChild(viewEmployeesBtn);
}


if (info.ownerName  && isUnlocked && info.ownerName === playerData.username && info.unlocked && (trueType === "zone" || trueType === "empty")) {
  const startCompanyBtn = createButton(`Start Company $${info.value}`, "btn btn-success", () => {
    // Store coords globally or in a modal data attr
    document.getElementById("confirmStartCompanyBtn").dataset.tile = `${x}_${y}`;
    new bootstrap.Modal(document.getElementById("startCompanyModal")).show();
  });
  modalFooter.appendChild(startCompanyBtn);
}

if (info.ownerName  && isUnlocked && info.ownerName !== playerData.username && trueType === "company") {
  createWorkForCompanyButton(info, playerData, modalFooter, x, y);
}

  new bootstrap.Modal(modalEl).show();
}

async function showEmployeesModal(tileId) {
  const modalEl = document.getElementById("employeesModal");
  const modalBody = modalEl.querySelector(".modal-body");
  modalBody.innerHTML = "Loading...";

  try {
    const tileRef = doc(db, "tiles", tileId);
    const tileSnap = await getDoc(tileRef);

    if (!tileSnap.exists()) {
      modalBody.innerHTML = "No data found for this tile.";
      return;
    }

    const tileData = tileSnap.data();
    const employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

    if (employsIDs.length === 0) {
      modalBody.innerHTML = "No employees yet.";
      return;
    }

    let html = `<ul class="list-group">`;

    for (const uid of employsIDs) {
      const empRef = doc(db, "players", uid);
      const empSnap = await getDoc(empRef);

      if (empSnap.exists()) {
        const empData = empSnap.data();
        const job = (empData.jobs || []).find(j => j.companyCoords?.join("_") === tileId);
        const startDate = job ? new Date(job.startedOn).toLocaleDateString() : "Unknown";

        html += `
          <li class="list-group-item d-flex align-items-center">
            <img src="${empData.avatarURL || 'default-avatar.png'}" alt="Avatar"
                 class="rounded-circle me-3" style="width: 40px; height: 40px; object-fit: cover;">
            <div>
              <strong>${empData.username || 'Unnamed'}</strong><br>
              <small class="text-muted">Started: ${startDate}</small>
            </div>
          </li>
        `;
      }
    }

    html += `</ul>`;
    modalBody.innerHTML = html;
    new bootstrap.Modal(modalEl).show();

  } catch (error) {
    modalBody.innerHTML = "An error occurred loading employees.";
    console.error("showEmployeesModal error:", error);
  }
}


async function upgradeHomeBase(x, y, playerData) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.playerUid);

  const [tileSnap, playerSnap] = await Promise.all([
    getDoc(tileRef),
    getDoc(playerRef)
  ]);

  if (!tileSnap.exists() || !playerSnap.exists()) return;

  const tileData = tileSnap.data();
  const player = playerSnap.data();

  const currentLevel = tileData.level || 1;
  const upgradeCost = (currentLevel + 1) * 1000;

  if (player.bank < upgradeCost) {
    showMessageModal("Not enough money to upgrade.");
    return;
  }

  const newLevel = currentLevel + 1;
  const newValue = tileData.value + newLevel * 500;

  let homeType = "Apartment";
  if (newLevel > 5) homeType = "House";
  if (newLevel > 10) homeType = "Estate";

  await Promise.all([
    updateDoc(tileRef, {
      level: newLevel,
      value: newValue,
      label: `${homeType} (Lv ${newLevel})`
    }),
    updateDoc(playerRef, {
      bank: player.bank - upgradeCost
    })
  ]);

  showMessageModal(`Home upgraded to ${homeType} level ${newLevel}.`);
}

async function createWorkForCompanyButton(info, playerData, modalFooter, x, y) {
  const trueType = info.type;
  const jobLimit = 3;

  if (info.ownerName !== playerData.username && trueType === "company") {
    const currentJobs = Array.isArray(playerData.jobs) ? playerData.jobs.length : 0;

    if (currentJobs < jobLimit) {
      const payPerDay = Math.floor(info.value / 20);

      const workBtn = createButton(
        `Work for company for $${payPerDay} /day`,
        "btn btn-success",
        async () => {
          // Prepare job object
          const job = {
            companyName: info.label || "Unknown Company",
            companyCoords: [x, y],
            pay: payPerDay,
            startedOn: Date.now()
          };

          // Ensure jobs array exists
          if (!Array.isArray(playerData.jobs)) playerData.jobs = [];
          playerData.jobs.push(job);

          // Update player document
          const playerRef = doc(db, "players", playerData.playerUid);
          await updateDoc(playerRef, { jobs: playerData.jobs });

          // Update tile's employsIDs array
          const tileId = `${x}_${y}`;
          const tileRef = doc(db, "tiles", tileId);
          const tileSnap = await getDoc(tileRef);

          if (tileSnap.exists()) {
            const tileData = tileSnap.data();
            let employsIDs = Array.isArray(tileData.employsIDs) ? tileData.employsIDs : [];

            // Avoid duplicate entry
            if (!employsIDs.includes(playerData.playerUid)) {
              employsIDs.push(playerData.playerUid);
              await updateDoc(tileRef, { employsIDs });
            }
          }

          showMessageModal(`üéâ You‚Äôre now working at ${job.companyName}!`, "success");
          closeModal();
        }
      );

      modalFooter.appendChild(workBtn);
    } else {
      const msg = createButton(
        "üíº Job limit reached (3)", 
        "btn btn-secondary disabled"
      );
      modalFooter.appendChild(msg);
    }
  }
}




function createButton({ text, onClick, id, className, parent = document.body, styles = {} }) {
   if(!text){
      console.trace("createButton called from:"); // Logs the call stack

    return;
  }  
  
  const button = document.createElement('button');

  // Set basic properties
  button.textContent = text;
  button.id = id || '';
  button.className = className || 'game-button';

  // Apply custom inline styles if any
  Object.assign(button.style, {
    padding: '8px 16px',
    margin: '4px',
    fontSize: '16px',
    cursor: 'pointer',
    borderRadius: '6px',
    border: 'none',
    backgroundColor: '#4CAF50',
    color: 'white',
    ...styles,
  });

  // Attach the click event
  if (typeof onClick === 'function') {
    button.addEventListener('click', onClick);
  }

  // Append to parent
  parent.appendChild(button);

  return button;
}

async function startCompany(x, y, tileData, uid, sector, name, symbol) {
  const tileId = `${x}_${y}`;
  const tileRef = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerUid);
  const info = getTileDataAt(x, y);
  const now = Date.now();

  const companyPrice = info.value * 2;
  const min = parseFloat((companyPrice * 0.7).toFixed(2));
  const max = parseFloat((companyPrice * 2).toFixed(2));
  const randomPrice = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  const updatedTile = {
    type: "company",
    name,
    stockSymbol: symbol,
    stockMarketListed: true,
    value: tileData.value * 2,
    level: tileData.level,
    sector,
    employsIDs: [],
    ownerID: uid,
    createdAt: now,
    event: "bigChange",
    eventTimestamp: now,
    stockLastPrice: randomPrice,
    price: companyPrice,
    stockPrice: companyPrice / 10,
    stockMinPrice: min,
    stockMaxPrice: max,
    stockMaxChangePercent: 0.05,
    stockPriceHistory: [companyPrice],
    companyStartedAt: now,
  };

  const newBankValue = playerData.bank - tileData.value;

await Promise.all([
  updateDoc(tileRef, updatedTile),
  updateDoc(playerRef, {
    bank: newBankValue,
    companiesOwned: arrayUnion(tileId)
  })
]);

  playerData.bank = newBankValue;
  playerData.companiesOwned = playerData.companiesOwned || [];
  playerData.companiesOwned.push(tileId);

  showMessageModal(`Company '${name}' (${symbol}) started at tile ${tileId} in sector '${sector}'`);
}


document.getElementById("confirmStartCompanyBtn").addEventListener("click", async () => {
  const sector = document.getElementById("sectorSelect").value;
  const name = document.getElementById("companyNameInput").value.trim();
  const symbol = document.getElementById("stockSymbolInput").value.trim().toUpperCase();

  if (!name || !symbol || symbol.length < 3 || symbol.length > 5 || !/^[A-Z]+$/.test(symbol)) {
    showMessageModal("Please enter a valid company name and a stock symbol (3‚Äì5 uppercase letters).");
    return;
  }

  // Replace these with your actual tile context values
  const x = selectedTileX;
  const y = selectedTileY;
  const tileData = await getTileDataAt(x, y);
  const uid = currentUser?.uid;

  if (!uid) return alert("User not logged in.");

  await startCompany(x, y, tileData, uid, sector, name, symbol);

  // Hide the modal
  bootstrap.Modal.getInstance(document.getElementById("startCompanyModal"))?.hide();
});



async function purchaseTile(x, y, overrideType = null, shouldMove = false) {
  try {
    const tileInfo = mapData[y]?.[x] || "empty";
    const info = zoneInfo[tileInfo] || zoneInfo.empty;

    const type = overrideType || info.type;
    const uid = auth.currentUser?.uid;
    if (!uid) throw new Error("User not logged in");

    const tileRef = doc(db, "tiles", `${x}_${y}`);
    const tileSnap = await getDoc(tileRef);
    const tileData = tileSnap.exists() ? tileSnap.data() : info;

    if (tileData.ownerID && tileData.ownerID !== playerData.userID) {
      return showMessageModal("Oops!", "Tile already owned by someone else.");
    }

    const cost = tileData?.price ?? info.price;
    if (playerData.bank < cost) {
      return showMessageModal("Insufficient Funds", "You don't have enough funds.");
    }

    // New tile level and value
  const newLevel = tileData.level || 1;
  const newValue = tileData.price + 1000 + player.level * 200;
    // Deduct money and write tile data
    const updatedBank = playerData.bank - cost;
    const newTile = {
      ownerID: playerData.userID,
      status: "owned",
      note: 'new',
      ownerName: playerData.playerName || 'Player',
      tileImage: '',
      color: info.color,
      label: info.label,
      type: "blocked", // prevent re-buying
      icon:  info.icon,
      price:  shouldMove ? newValue : info.price,
      originalCost: shouldMove ? newValue : info.price,
      income:  info.income,
      taxRate:  info.taxRate,
      value:  info.value,
      forSale: false,
      unlocked: true,
      level: 1,
      x,
      y,
      tileHistory: info,
    };

const tileId = `${x}_${y}`;

// Update Firestore
const updates = [
  updateDoc(doc(db, "players", playerData.userID), {
    bank: updatedBank,
    ...(shouldMove ? { location: [x, y] } : {}),
    landOwned: arrayUnion(tileId)
  }),
  setDoc(tileRef, newTile, { merge: true })
];

await Promise.all(updates);

// Update local playerData
if (!playerData.landOwned) playerData.landOwned = [];
if (!playerData.companiesOwned) playerData.companiesOwned = [];

if (type === 'zone' && !playerData.landOwned.includes(tileId)) {
  playerData.landOwned.push(tileId);
}

if (type === 'company' && !playerData.companiesOwned.includes(tileId)) {
  playerData.companiesOwned.push(tileId);
}

    playerData.bank = updatedBank;
    if (shouldMove) {
      playerData.location = [x, y];
      playerX = x;
      playerY = y;
      movePlayerSmoothly(scene, x, y);
    }

    updateStatsUI();
    showMessageModal("Success", `You purchased a ${type} tile!`);
  } catch (err) {
    console.error("Purchase failed:", err.message);
    showMessageModal("Error", err.message);
  }
}

window.purchaseTile = purchaseTile;



async function getTileDataAt(x, y) {
  try {
    // Get the tile type from mapData
    const tileType = mapData[y]?.[x] || "empty";

    // Get static zone info (default fallback data)
    const defaultInfo = zoneInfo[tileType] || zoneInfo.empty;

    // Get live data from Firestore (tiles collection)
    const tileRef = doc(db, "tiles", `${x}_${y}`);
    const tileSnap = await getDoc(tileRef);

    // If Firestore has data, merge it with static info
    if (tileSnap.exists()) {
      const firestoreData = tileSnap.data();
      return { ...defaultInfo, ...firestoreData, x, y };
    } else {
      // Use default zone info if no Firestore document exists
      return { ...defaultInfo, x, y };
    }

  } catch (error) {
    console.error("Error fetching tile data:", error);
    return { ...zoneInfo.empty, x, y };
  }
}



let ownedTiles = [];///  = [ playerData.companiesOwned playerData.landOwned]; // Loaded from player data

function openOwnedModal() {
  renderOwnedList();
  console.log("Opening owned assets modal");

  const modalEl = document.getElementById("ownedModal");

  // Try to get existing instance
  let modalInstance = bootstrap.Modal.getInstance(modalEl);

  // If no instance, create one
  if (!modalInstance) {
    modalInstance = new bootstrap.Modal(modalEl);
  }

  modalInstance.show();
}

document.getElementById("openOwnedBtn").addEventListener("click", openOwnedModal);

// Expose to global if needed
window.openOwnedModal = openOwnedModal;



document.getElementById("sortFilter").addEventListener("change", renderOwnedList);

function renderOwnedList() {
  const listEl = document.getElementById("ownedList");
  const sortBy = document.getElementById("sortFilter").value;

  let sorted = [...ownedTiles];
  sorted.sort((a, b) => {
    if (sortBy === "value") return b.value - a.value;
    if (sortBy === "tax") return b.taxRate - a.taxRate;
    return 0;
  });

  listEl.innerHTML = "";
  sorted.forEach(tile => {
    const li = document.createElement("li");
    li.innerHTML = `
      <strong>${tile.name}</strong> (${tile.x}, ${tile.y})<br>
      üí∞ Value: $${tile.value} | üìä Tax: ${tile.taxRate}% | üîì ${tile.unlocked ? "Unlocked" : "Locked"}
      <br>
      <button class="view-btn" data-x="${tile.x}" data-y="${tile.y}">View</button>
      <button class="sell-btn" data-id="${tile.id}">Sell</button>
      <button class="upgrade-btn" data-id="${tile.id}">Upgrade</button>
    `;
    listEl.appendChild(li);
  });

  attachOwnedListeners();
}

function attachOwnedListeners() {
  document.querySelectorAll(".view-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const x = parseInt(e.target.dataset.x);
      const y = parseInt(e.target.dataset.y);
      centerCameraOnTile(x, y);
      openTileDetails(x, y);
      highlightTile(x, y);
    });
  });

  document.querySelectorAll(".sell-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await sellTile(tileId);
      showMessageModal("Success","Tile sold!");
      refreshOwnedTiles();
    });
  });

  document.querySelectorAll(".upgrade-btn").forEach(btn => {
    btn.addEventListener("click", async (e) => {
      const tileId = e.target.dataset.id;
      await upgradeTile(tileId);
      showMessageModal("Success","Tile upgraded!");
      refreshOwnedTiles();
    });
  });
}

function highlightTile(x, y) {
  // Optional: remove previous highlights
  document.querySelectorAll(".tile-highlight").forEach(el => el.classList.remove("tile-highlight"));

  const tileEl = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
  if (tileEl) tileEl.classList.add("tile-highlight");
}

function centerCameraOnTile(x, y) {
  playerX = x;
  playerY = y;
  drawBoard();
}

function openTileDetails(x, y) {
  const tile = getTileDataAt(x, y); // implement this based on your tile structure
  showTileModal(tile); // your modal function
}


async function upgradeTile(tileId) {
  // Firebase logic to apply upgrades
  const ref = doc(db, "tiles", tileId);
  await updateDoc(ref, { level: increment(1) });
}

async function refreshOwnedTiles() {
  // Pull owned tiles again
  const snap = await getDocs(query(collection(db, "tiles"), where("ownerId", "==", playerData.userID)));
  ownedTiles = snap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
  renderOwnedList();
}


async function sellTile(x, y, playerData) {
  const tile = await getTileDataAt(x, y);
  const tileId = tile.tileId;
  const ref = doc(db, "tiles", tileId);
  const playerRef = doc(db, "players", playerData.userID);

   // Build update payload (merge style)
    const updatePayload = {
      ownerID: null,
      status: "available",
      note: "Sold",
      tileHistory: `${tile.tileHistory || ""} | Sold on ${new Date().toLocaleDateString()}`,
      type: tile.type || "empty",
      ...newData, // allow overrides or additions
    };


  try {
    // Determine which array to remove from
    const isCompany = tile.type === "market" || tile.type === "company"; // adjust types as needed
    const fieldToRemove = isCompany ? "companiesOwned" : "landOwned";

    // Remove from player data and update bank
    await updateDoc(playerRef, {
      [fieldToRemove]: arrayRemove(tileId),
      bank: increment(tile.value || 100), // Default fallback value
    });

   
    
 
    // Update Firestore
    await updateDoc(ref, updatePayload);
    console.log(`Tile ${x},${y} updated successfully.`);
    console.log(`Tile ${tileId} sold and removed from ${fieldToRemove}`);
  } catch (error) {
    console.error("Error selling tile:", error);
  }
}










  // Realtime sync for player movement and all players
const playerRef = doc(db, "players", uid);
onSnapshot(playerRef, (docSnap) => {
  if (docSnap.exists()) {
    const data = docSnap.data();

    // Update position and move player sprite if position changed
    const pos = data.position;
    if (pos && (pos.x !== playerX || pos.y !== playerY)) {
      playerX = pos.x;
      playerY = pos.y;
      movePlayerSmoothly(scene, playerX, playerY);
    }

    // Update local playerData object with all fresh data from Firestore
    playerData = {
      ...playerData,  // keep previous keys if any
      ...data         // overwrite with latest from Firestore
    };

    // Refresh UI after updating playerData
    updateStatsUI();
  }
});


  const playersCollection = collection(db, "players");
  onSnapshot(playersCollection, (querySnapshot) => {
    playerState.clear();
    querySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.position) {
        playerState.set(doc.id, data.position);
      }
    });
    renderAllPlayers(scene);
  });
}


let moveTween;

function movePlayerSmoothly(scene, x, y) {
  return new Promise(resolve => {
    if (moveTween) moveTween.stop();

    moveTween = scene.tweens.add({
      targets: playerSprite,
      x: x * TILE_SIZE + TILE_SIZE/2,
      y: y * TILE_SIZE + TILE_SIZE/2,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        resolve();
      }
    });
  });
}



// === Stats UI ===
function updateStatsUI() {
  const state = playerState.get(uid);
  if (!state) {
    console.warn("Missing player state UID:", uid);
    return;
  }

  const now = Date.now();
  
  

  document.getElementById("level").textContent = `${state.level ?? 0}`;
  document.getElementById("xp").textContent = `${state.xp ?? 0}`;

  document.getElementById("bank").textContent = `$${state.bank ?? 0}`;
  document.getElementById("trades").textContent = state.trades ?? 0;
  document.getElementById("crypto").textContent = `${state.crypto ?? 5}`;

  document.getElementById("health").textContent = `${state.health ?? 100}%`;
  document.getElementById("security").textContent = `${state.security ?? 1}`;
  document.getElementById("techStrength").textContent = `${state.techStrength ?? 1}`;


  const zoneType = mapData[playerY]?.[playerX] || "empty";
  const label = zoneInfo[zoneType]?.label || "Unknown";
  document.getElementById("zoneName").innerHTML = `üìç Zone: <span>${label}</span>`;
}






async function create() {
   scene = this;

  await initializeMap(scene);
  setupMapMovement(scene);
  setupMapInteraction(scene);
}


async function performAttack(targetPlayerId) {
  if (!playerState.actionsLeft || playerState.inCombat) return;

  playerState.inCombat = true;
  playerState.actionsLeft--;
  playerState.cooldowns.attack = Date.now() + 10000;

  await setDoc(doc(db, "users", uid), {
    inCombat: true,
    actionsLeft: playerState.actionsLeft,
    cooldowns: playerState.cooldowns
  }, { merge: true });

  await handleCombat(uid, targetPlayerId);

  setTimeout(async () => {
    playerState.inCombat = false;
    await setDoc(doc(db, "users", uid), { inCombat: false }, { merge: true });
  }, 15000);
}


async function handleCombat(attackerId, defenderId) {
  const attackerRef = doc(db, "players", attackerId);
  const defenderRef = doc(db, "players", defenderId);

  const [attackerSnap, defenderSnap] = await Promise.all([
    getDoc(attackerRef), getDoc(defenderRef)
  ]);

  if (!attackerSnap.exists() || !defenderSnap.exists()) return;

  const attacker = attackerSnap.data();
  const defender = defenderSnap.data();

  const damage = calculateDamage(attacker, defender);
  const newHp = Math.max((defender.hp ?? 10) - damage, 0);

  await updateDoc(defenderRef, {
    hp: newHp,
    lastDamagedBy: attackerId,
    lastCombat: serverTimestamp()
  });

  showCombatAnimation(attackerId, defenderId, damage);
  updateCombatUI(attacker, { ...defender, hp: newHp });

  if (newHp === 0) {
    await updateDoc(defenderRef, { status: "defeated" });
    alert(`${attacker.name ?? "Player"} defeated ${defender.name ?? "Enemy"}!`);
  }
}


function calculateDamage(attacker, defender) {
  const atk = attacker.attack ?? 5;
  const def = defender.defense ?? 2;
  return Math.max(1, atk - def + Math.floor(Math.random() * 3));
}


function showCombatAnimation(attackerId, defenderId, damage) {
  const scene = game.scene.scenes[0];
  const targetGraphics = scene.add.graphics();
  targetGraphics.lineStyle(3, 0xff0000, 1);
  targetGraphics.strokeRect(playerX * TILE_SIZE, playerY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
  setTimeout(() => targetGraphics.destroy(), 500);

  const tile = document.querySelector(`[data-player-id="${defenderId}"]`);
  if (tile) {
    const dmg = document.createElement("div");
    dmg.className = "damage-popup";
    dmg.innerText = `-${damage} HP`;
    tile.appendChild(dmg);
    setTimeout(() => dmg.remove(), 1200);
  }
}


function updateCombatUI(attacker, defender) {
  const attackerEl = document.getElementById(`${attacker.id}-hp`);
  const defenderEl = document.getElementById(`${defender.id}-hp`);
  if (attackerEl) attackerEl.textContent = attacker.hp;
  if (defenderEl) defenderEl.textContent = defender.hp;

  const isDisabled = attacker.inCombat || attacker.actionsLeft <= 0;
  document.querySelectorAll(".action-button").forEach(btn => {
    btn.disabled = isDisabled;
  });
}


async function performHackAction(action) {
  const hackerStatus = document.getElementById("hackerStatus");
  hackerStatus.textContent = `Performing ${action}...`;

  await new Promise(r => setTimeout(r, 1500)); // Fake delay

  const successChance = playerData.techStrength / (playerData.security + 1);
  const success = Math.random() < successChance;

  if (success) {
    hackerStatus.textContent = `${action} succeeded!`;
    await setDoc(doc(collection(db, "hacks")), {
      user: uid,
      action,
      success,
      timestamp: new Date()
    });
  } else {
    hackerStatus.textContent = `${action} failed. Try again later.`;
  }
}

function setupHackerPanel() {
  document.getElementById("hackerStatus").textContent = "";
}

document.getElementById("spyBtn").addEventListener("click", () => performHackAction("spy"));
document.getElementById("corruptBtn").addEventListener("click", () => performHackAction("corrupt_trade"));
document.getElementById("stealBtn").addEventListener("click", () => performHackAction("steal_data"));


/*

// ====== ATTACK ======
async function loadAttackTargets() {
  document.getElementById("attackMessage").textContent = "";
  const playersSnap = await getDocs(collection(db, "players"));
  playersList = [];
  playersSnap.forEach(doc => {
    const data = doc.data();
    if (doc.id !== uid) { // exclude current player
      playersList.push({ id: doc.id, name: data.name || "Unnamed", security: data.security || 1 });
    }
  });

  renderAttackTargets();
}

function renderAttackTargets() {
  const attackTargetsEl = document.getElementById("attackTargets");
  attackTargetsEl.innerHTML = "";
  playersList.forEach(player => {
    const li = document.createElement("li");
    li.className = "list-group-item d-flex justify-content-between align-items-center";
    li.textContent = `${player.name} (Security: ${player.security})`;
    li.style.cursor = "pointer";
    li.onclick = () => {
      selectedAttackTarget = player;
      // highlight selected
      Array.from(attackTargetsEl.children).forEach(child => child.classList.remove("active"));
      li.classList.add("active");
    };
    attackTargetsEl.appendChild(li);
  });
}


      case "attack":
      loadAttackTargets();
      new bootstrap.Modal(document.getElementById("attackModal")).show();
      break;
    case "hacker":
      setupHackerPanel();
      new bootstrap.Modal(document.getElementById("hackerModal")).show();
      break;
*/

function update() {
  // nothing needed here for now
}

function isAdjacent(x1, y1, x2, y2) {
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  return (dx + dy) === 1;
}






// Render other players except local player
function renderAllPlayers(scene) {
  // Remove old sprites no longer in playerState
  for (const [key, sprite] of otherPlayerSprites) {
    if (!playerState.has(key) || key === uid) {
      sprite.destroy();
      otherPlayerSprites.delete(key);
    }
  }

  // Draw other players as red circles with initials
  for (const [playerId, pos] of playerState.entries()) {
    if (playerId === uid) continue;
    if (!pos) continue;

    let sprite = otherPlayerSprites.get(playerId);
    if (!sprite) {
      // Create a container with red circle and initials text
      sprite = scene.add.container(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);

      const circle = scene.add.circle(0, 0, TILE_SIZE * 0.4, 0xff4444);
      circle.setStrokeStyle(2, 0xffffff);

      const initials = scene.add.text(0, 0, playerId.substring(0, 2).toUpperCase(), {
        fontSize: '16px',
        color: '#fff',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      sprite.add([circle, initials]);
      otherPlayerSprites.set(playerId, sprite);
    } else {
      sprite.setPosition(pos.x * TILE_SIZE + TILE_SIZE/2, pos.y * TILE_SIZE + TILE_SIZE/2);
    }
  }
}





function showMessageModal(title, message) {
  document.getElementById("messageModalTitle").textContent = title;
  document.getElementById("messageModalBody").textContent = message;

  const modal = new bootstrap.Modal(document.getElementById('messageModal'));
  modal.show();
}

</script>

</body>
</html>
