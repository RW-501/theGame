<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deluxe Family Game Board</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style>
    /* Layout */
    body, html {
      margin: 0; padding: 0; height: 100%;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

 
  .modal-content {
    background: #fdfdfd;
    border-radius: 1rem;
  }



    #container {
      display: flex;
      height: 90vh;
      width: 90vw;
      max-width: 1100px;
      max-height: 900px;
      border-radius: 20px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
      background: linear-gradient(135deg, #fefefe, #e7e7e7);
      position: relative;
    }

    /* Canvas styles */
    #gameBoard {
      border-radius: 20px 0 0 20px;
      border: none;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
      background: linear-gradient(135deg, #fefefe, #e7e7e7);
      cursor: pointer;
      flex-shrink: 0;
      width: 800px;
      height: 800px;
    }

    /* Sidebar for tile details */
    #tileDetails {
      width: 280px;
      background: white;
      border-left: 3px solid #4a4a4a;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      user-select: text;
      border-radius: 0 20px 20px 0;
      box-shadow: -5px 0 15px rgba(0,0,0,0.1);
      position: relative;
    }

    #tileDetails.hidden {
      display: none;
    }

    #tileDetails h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.5rem;
      color: #4a4a4a;
    }

    #tileDetails p {
      flex-grow: 1;
      font-size: 1rem;
      color: #333;
      line-height: 1.4;
    }

    #sidebarToggle {
      position: absolute;
      top: 10px;
      left: -25px;
      width: 25px;
      height: 60px;
      background: #4a4a4a;
      color: white;
      font-weight: bold;
      font-size: 20px;
      border-radius: 8px 0 0 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease;
      z-index: 10;
    }

    #sidebarToggle:hover {
      background-color: #333;
    }

    /* Bottom button container */
    #buttonContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 20;
    }

    button {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 12px 22px;
      font-size: 1rem;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
      transition: background-color 0.3s ease;
      user-select: none;
    }

    button:hover {
      background-color: #1769aa;
    }

        .btn-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    /* Status area */
    #statusArea {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255 255 255 / 0.9);
      border-radius: 12px;
      padding: 15px 20px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      font-size: 1rem;
      color: #333;
      user-select: text;
      z-index: 15;
      max-width: 260px;
    }

    /* Card popup */
    #cardPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: white;
      border-radius: 20px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.3);
      padding: 30px 40px;
      width: 320px;
      max-width: 90vw;
      text-align: center;
      z-index: 30;
      transition: transform 0.3s ease;
      user-select: text;
    }

    #cardPopup.show {
      transform: translate(-50%, -50%) scale(1);
    }

    #cardPopup h2 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #2196F3;
    }

    #cardPopup p {
      font-size: 1.1rem;
      color: #444;
      margin-bottom: 20px;
    }

    #cardPopup button.closeBtn {
      background: #e91e63;
      padding: 10px 20px;
      font-size: 1rem;
      border-radius: 12px;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(233, 30, 99, 0.4);
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #cardPopup button.closeBtn:hover {
      background-color: #ad1457;
    }
  </style>
</head>
<body>
  <div id="container">
     <div class="btn-container">
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
    <button onclick="centerBoard()">Center</button>
  </div>

    <canvas id="gameBoard" width="800" height="800" title="Game board"></canvas>


  </div>

  <div id="statusArea" aria-live="polite" role="region">
    <strong>Player Stats</strong>
    <div>Health: <span id="statHealth"></span></div>
    <div>Money: <span id="statMoney"></span></div>
    <div>Engagement: <span id="statEngagement"></span></div>
    <div>Karma: <span id="statKarma"></span></div>
  </div>

  <div id="buttonContainer" role="region" aria-label="Game Controls">
    <button id="rollDiceBtn">Roll Dice</button>
    <button id="viewStatsBtn">View Stats</button>
    <button id="playCardBtn">Play Card</button>
  </div>

  <div id="cardPopup" role="dialog" aria-modal="true" aria-labelledby="cardPopupTitle" aria-describedby="cardPopupDesc" tabindex="-1">
    <h2 id="cardPopupTitle">Card Title</h2>
    <p id="cardPopupDesc">Card description</p>
    <button class="closeBtn" aria-label="Close Card Popup">&times; Close</button>
  </div>

  <!-- Tile Details Modal -->
<div class="modal fade" id="tileDetailsModal" tabindex="-1" aria-labelledby="tileDetailsLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content rounded-4 shadow">
      <div class="modal-header">
        <h5 class="modal-title" id="tileDetailsLabel">Tile Title</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p id="tileDesc">Tile description will appear here.</p>
      </div>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById("gameBoard");
  const ctx = canvas.getContext("2d");
  const tileSize = 70;

  const tileTypes = {
    start: "#4CAF50",
    action: "#2196F3",
    chance: "#FFC107",
    quiz: "#FF5722",
    goal: "#9C27B0",
    story: "#00BCD4",
    family_poll: "#E91E63",
    challenge: "#795548"
  };


      let scale = 1;
    let offsetX = 0;
    let offsetY = 0;

    const gridSize = 5;
    const cellSize = 100;


  // Generate board tiles
  const boardTiles = Array.from({ length: 40 }, (_, i) => {
    const types = Object.keys(tileTypes);
    return {
      id: i,
      label: `Tile ${i}`,
      type: types[i % types.length],
      description: `This is ${types[i % types.length]} tile number ${i}.`,
      cardId: (i % 7 === 0) ? "card001" : null // example: every 7th tile has a card
    };
  });

  // Sample cards
  const cards = {
    card001: {
      id: "card001",
      title: "Go for a Run",
      description: "Improve your health by jogging around the block.",
      effects: { health: +15, money: 0, engagement: -5 },
      category: "activity"
    },
    card002: {
      id: "card002",
      title: "Go Out to Eat",
      description: "Costs $20, lowers health but boosts engagement.",
      effects: { health: -10, money: -20, engagement: +15 },
      category: "activity"
    }
  };

  const player = {
    name: "Player 1",
    position: 0,
    color: "#FF5722",
    stats: { health: 80, money: 100, engagement: 50, karma: 0 },
        name: "Player 2",
    position: 0,
    color: "#DD5722",
    stats: { health: 80, money: 100, engagement: 50, karma: 0 },
        name: "Player 3",
    position: 0,
    color: "#CC5722",
    stats: { health: 80, money: 100, engagement: 50, karma: 0 }
  };

  // Calculate tile coordinates in a square loop (top row left to right, right col top to bottom, bottom row right to left, left col bottom to top)
  function getTileCoordinates() {
    const coords = [];
    for (let i = 0; i < 40; i++) {
      let x = 0, y = 0;
      if (i < 10) {
        x = canvas.width - tileSize - i * tileSize;
        y = canvas.height - tileSize;
      } else if (i < 20) {
        x = 0;
        y = canvas.height - tileSize - (i - 10) * tileSize;
      } else if (i < 30) {
        x = (i - 20) * tileSize;
        y = 0;
      } else {
        x = canvas.width - tileSize;
        y = (i - 30) * tileSize;
      }
      coords.push({ x, y });
    }
    return coords;
  }
  const positions = getTileCoordinates();

  let animating = false;

  // Helpers
  function roundRect(ctx, x, y, w, h, r, fill, stroke, fillStyle) {
    if (typeof r === "number") {
      r = { tl: r, tr: r, br: r, bl: r };
    }
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x + r.bl, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
    if (fill) {
      if (fillStyle) ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (stroke) ctx.stroke();
  }

  function shadeColor(color, percent) {
    let f = parseInt(color.slice(1),16), t = percent < 0 ? 0 : 255, p = percent < 0 ? -percent : percent;
    let R = f >> 16, G = f >> 8 & 0x00FF, B = f & 0x0000FF;
    return "#" + (0x1000000 + (Math.round((t-R)*p/100)+R)*0x10000
      + (Math.round((t-G)*p/100)+G)*0x100
      + (Math.round((t-B)*p/100)+B)).toString(16).slice(1);
  }

  function tileIcon(type) {
    switch(type) {
      case "start": return "🏁";
      case "action": return "🎯";
      case "chance": return "🎲";
      case "quiz": return "❓";
      case "goal": return "🏆";
      case "story": return "📖";
      case "family_poll": return "👪";
      case "challenge": return "⚔️";
      default: return "⬜";
    }
  }

  // Draw functions
  function drawTile(x, y, tile) {
    const radius = 15;
    const color = tileTypes[tile.type] || "#999";
    const gradient = ctx.createLinearGradient(x, y, x + tileSize, y + tileSize);
    gradient.addColorStop(0, shadeColor(color, 20));
    gradient.addColorStop(1, shadeColor(color, -20));
    roundRect(ctx, x, y, tileSize, tileSize, radius, true, false, gradient);

    ctx.strokeStyle = shadeColor(color, -50);
    ctx.lineWidth = 3;
    roundRect(ctx, x, y, tileSize, tileSize, radius, false, true);

    ctx.fillStyle = "#fff";
    ctx.font = "bold 14px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
    ctx.shadowColor = "rgba(0,0,0,0.5)";
    ctx.shadowBlur = 4;
    ctx.fillText(tile.label, x + 10, y + 25);

    const icon = tileIcon(tile.type);
    ctx.shadowBlur = 0;
    ctx.font = "24px Arial";
    ctx.fillText(icon, x + tileSize - 30, y + 35);
  }

  function drawPlayer(x, y, player) {
    const cx = x + tileSize / 2;
    const cy = y + tileSize / 2;
    const radius = 14;

    ctx.shadowColor = player.color;
    ctx.shadowBlur = 12;

    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = player.color;
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(player.name.charAt(0), cx, cy);
  }

  // Main draw board
function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Draw the grid/board
  board.forEach((cell, i) => {
    const x = cell.x * cellSize;
    const y = cell.y * cellSize;

    // Draw tile background
    ctx.fillStyle = "#eee";
    ctx.fillRect(x, y, cellSize, cellSize);

    // Tile border
    ctx.strokeStyle = "#333";
    ctx.strokeRect(x, y, cellSize, cellSize);

    // Tile label
    ctx.fillStyle = "#000";
    ctx.font = "14px sans-serif";
    ctx.fillText(cell.label, x + 10, y + 20);

    // Draw player if on this tile
    if (player.position === i) {
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.arc(x + cellSize / 2, y + cellSize / 2, 10, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  canvas.addEventListener("click", (e) => {
  // Example logic: find which tile was clicked (your own logic may vary)
  const clickedTile = getTileAtClick(e.offsetX, e.offsetY);
  if (clickedTile) {
    showTileDetails(clickedTile.title, clickedTile.description);
  }
});

  ctx.restore();
}


function zoomIn() {
  scale *= 1.2;
  drawBoard();
}

function zoomOut() {
  scale /= 1.2;
  drawBoard();
}

function centerBoard() {
  const boardWidth = gridSize * cellSize * scale;
  const boardHeight = gridSize * cellSize * scale;
  offsetX = (canvas.width - boardWidth) / 2;
  offsetY = (canvas.height - boardHeight) / 2;
  drawBoard();
}

window.onload = centerBoard;

  // Update stats area
  function updateStats() {
    document.getElementById("statHealth").textContent = player.stats.health;
    document.getElementById("statMoney").textContent = player.stats.money;
    document.getElementById("statEngagement").textContent = player.stats.engagement;
    document.getElementById("statKarma").textContent = player.stats.karma;
  }



  // Handle tile clicks on canvas
  canvas.addEventListener("click", (e) => {
    if(animating) return;
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Check which tile was clicked
    for(let i=0; i < positions.length; i++) {
      const pos = positions[i];
      if(clickX >= pos.x && clickX <= pos.x + tileSize &&
         clickY >= pos.y && clickY <= pos.y + tileSize) {
           showTileDetails(boardTiles[i]);
           break;
      }
    }
  });

  // Animate player movement
  function movePlayerBy(steps) {
    if (animating) return;

    animating = true;
    let stepCount = 0;

    function animateStep() {
      if (stepCount < steps) {
        player.position = (player.position + 1) % boardTiles.length;
        drawBoard();
        stepCount++;
        setTimeout(animateStep, 300);
      } else {
        animating = false;
        showTileDetails(boardTiles[player.position]);
        updateStats();
        // If tile has a card and screen width > 900, show card popup
        const tile = boardTiles[player.position];
        if (tile.cardId && cards[tile.cardId]) {
          if (window.innerWidth > 900) {
            showCardPopup(cards[tile.cardId]);
          } else {
            alert(`Card: ${cards[tile.cardId].title}\n${cards[tile.cardId].description}`);
          }
          applyCardEffects(cards[tile.cardId].effects);
          updateStats();
          drawBoard();
        }
      }
    }

    animateStep();
  }

  // Apply card effects to player stats
  function applyCardEffects(effects) {
    Object.entries(effects).forEach(([key, val]) => {
      if (player.stats[key] !== undefined) {
        player.stats[key] += val;
        if (player.stats[key] < 0) player.stats[key] = 0;
        if (player.stats[key] > 100) player.stats[key] = 100;
      }
    });
  }

  // Show card popup
  const cardPopup = document.getElementById("cardPopup");
  const cardPopupTitle = document.getElementById("cardPopupTitle");
  const cardPopupDesc = document.getElementById("cardPopupDesc");
  const cardCloseBtn = cardPopup.querySelector(".closeBtn");

  function showCardPopup(card) {
    cardPopupTitle.textContent = card.title;
    cardPopupDesc.textContent = card.description;
    cardPopup.classList.add("show");
    cardPopup.focus();
  }

  cardCloseBtn.addEventListener("click", () => {
    cardPopup.classList.remove("show");
  });

  // Sidebar toggle
  const sidebar = document.getElementById("tileDetails");
  const sidebarToggle = document.getElementById("sidebarToggle");
  sidebarToggle.addEventListener("click", () => {
    if (sidebar.classList.contains("hidden")) {
      sidebar.classList.remove("hidden");
      sidebarToggle.innerHTML = "&laquo;";
    } else {
      sidebar.classList.add("hidden");
      sidebarToggle.innerHTML = "&raquo;";
    }
  });

  // Buttons
  document.getElementById("rollDiceBtn").addEventListener("click", () => {
    if(animating) return;
    const diceRoll = Math.floor(Math.random() * 6) + 1;
    alert(`You rolled a ${diceRoll}!`);
    movePlayerBy(diceRoll);
  });

  document.getElementById("viewStatsBtn").addEventListener("click", () => {
    alert(`Stats:\nHealth: ${player.stats.health}\nMoney: ${player.stats.money}\nEngagement: ${player.stats.engagement}\nKarma: ${player.stats.karma}`);
  });

  document.getElementById("playCardBtn").addEventListener("click", () => {
    if(animating) return;
    const cardKeys = Object.keys(cards);
    const card = cards[cardKeys[Math.floor(Math.random() * cardKeys.length)]];
    alert(`Playing card: ${card.title}\n${card.description}`);
    applyCardEffects(card.effects);
    updateStats();
    drawBoard();
  });

  // Initial setup
  drawBoard();
  showTileDetails(boardTiles[0]);
  updateStats();

  // Accessibility: close popup with Escape key
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && cardPopup.classList.contains("show")) {
      cardPopup.classList.remove("show");
    }
  });

  // Responsive: redraw board on window resize to keep things sharp
  window.addEventListener("resize", () => {
    drawBoard();
  });


function showTileDetails(title, desc) {
  document.getElementById("tileDetailsLabel").textContent = title;
  document.getElementById("tileDesc").textContent = desc;
    showTileDetails(title, desc);

  const modal = new bootstrap.Modal(document.getElementById('tileDetailsModal'));
  modal.show();
}

</script>
</body>
</html>
