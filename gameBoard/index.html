<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deluxe Family Game Board</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #a8edea, #fed6e3);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      user-select: none;
    }

    canvas {
      border-radius: 20px;
      border: 8px solid #4a4a4a;
      background: linear-gradient(135deg, #fefefe, #e7e7e7);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
    }

    #tileDetails {
      position: fixed;
      right: 20px;
      top: 20px;
      width: 250px;
      padding: 15px;
      background: white;
      border: 2px solid #333;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      border-radius: 12px;
      display: none;
      user-select: text;
    }

    button {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 12px 22px;
      font-size: 1rem;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
      transition: background-color 0.3s ease;
      user-select: none;
    }

    button:hover {
      background-color: #1769aa;
    }

    #buttonContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
    }
  </style>
</head>
<body>
  <canvas id="gameBoard" width="800" height="800"></canvas>

  <div id="tileDetails">
    <h3 id="tileTitle"></h3>
    <p id="tileDesc"></p>
  </div>

  <div id="buttonContainer">
    <button id="rollDiceBtn">Roll Dice</button>
    <button id="viewStatsBtn">View Stats</button>
    <button id="playCardBtn">Play Card</button>
  </div>

  <script>
    const canvas = document.getElementById("gameBoard");
    const ctx = canvas.getContext("2d");

    const tileSize = 70;

    // Tile types and colors
    const tileTypes = {
      start: "#4CAF50",
      action: "#2196F3",
      chance: "#FFC107",
      quiz: "#FF5722",
      goal: "#9C27B0",
      story: "#00BCD4",
      family_poll: "#E91E63",
      challenge: "#795548"
    };

    // Sample board tiles
    const boardTiles = Array.from({length: 40}, (_, i) => {
      const types = Object.keys(tileTypes);
      return {
        id: i,
        label: `Tile ${i}`,
        type: types[i % types.length],
        description: `This is ${types[i % types.length]} tile number ${i}.`
      };
    });

    const player = { 
      name: "Player 1", 
      position: 0, 
      color: "#FF5722", 
      stats: { health: 80, money: 100, engagement: 50, karma: 0 }
    };

    // Coordinates of tiles around the board
    function getTileCoordinates() {
      const coords = [];
      for (let i = 0; i < 40; i++) {
        let x = 0, y = 0;
        if (i < 10) {
          x = canvas.width - tileSize - i * tileSize;
          y = canvas.height - tileSize;
        } else if (i < 20) {
          x = 0;
          y = canvas.height - tileSize - (i - 10) * tileSize;
        } else if (i < 30) {
          x = (i - 20) * tileSize;
          y = 0;
        } else {
          x = canvas.width - tileSize;
          y = (i - 30) * tileSize;
        }
        coords.push({ x, y });
      }
      return coords;
    }

    const positions = getTileCoordinates();
    let animating = false;

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      boardTiles.forEach((tile, i) => {
        const { x, y } = positions[i];
        drawTile(x, y, tile);
        if (player.position === i) drawPlayer(x, y, player);
      });
    }

    // Rounded rect helper
    function roundRect(ctx, x, y, w, h, r, fill, stroke, fillStyle) {
      if (typeof r === "number") {
        r = { tl: r, tr: r, br: r, bl: r };
      }
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      ctx.closePath();
      if (fill) {
        if (fillStyle) ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      if (stroke) ctx.stroke();
    }

    // Shade color helper
    function shadeColor(color, percent) {
      let f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent;
      let R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
      return "#" + (0x1000000 + (Math.round((t-R)*p/100)+R)*0x10000 
        + (Math.round((t-G)*p/100)+G)*0x100 + (Math.round((t-B)*p/100)+B)).toString(16).slice(1);
    }

    // Tile icons
    function tileIcon(type) {
      switch(type) {
        case "start": return "üèÅ";
        case "action": return "üéØ";
        case "chance": return "üé≤";
        case "quiz": return "‚ùì";
        case "goal": return "üèÜ";
        case "story": return "üìñ";
        case "family_poll": return "üë™";
        case "challenge": return "‚öîÔ∏è";
        default: return "‚¨ú";
      }
    }

    function drawTile(x, y, tile) {
      const radius = 15;
      const color = tileTypes[tile.type] || "#999";
      const gradient = ctx.createLinearGradient(x, y, x + tileSize, y + tileSize);
      gradient.addColorStop(0, shadeColor(color, 20));
      gradient.addColorStop(1, shadeColor(color, -20));

      roundRect(ctx, x, y, tileSize, tileSize, radius, true, false, gradient);

      ctx.strokeStyle = shadeColor(color, -50);
      ctx.lineWidth = 3;
      roundRect(ctx, x, y, tileSize, tileSize, radius, false, true);

      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 4;
      ctx.fillText(tile.label, x + 10, y + 25);

      const icon = tileIcon(tile.type);
      ctx.shadowBlur = 0;
      ctx.font = "24px Arial";
      ctx.fillText(icon, x + tileSize - 30, y + 35);
    }

    function drawPlayer(x, y, player) {
      const cx = x + tileSize / 2;
      const cy = y + tileSize / 2;
      const radius = 14;

      ctx.shadowColor = player.color;
      ctx.shadowBlur = 12;

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = player.color;
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 16px 'Segoe UI'";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(player.name.charAt(0), cx, cy);
    }

    function showTileDetails(tile) {
      const details = document.getElementById("tileDetails");
      document.getElementById("tileTitle").textContent = tile.label;
      document.getElementById("tileDesc").textContent = tile.description || "No description";
      details.style.display = "block";
    }

    function movePlayerBy(steps) {
      if (animating) return;

      animating = true;
      let stepCount = 0;
      function animateStep() {
        if (stepCount < steps) {
          player.position = (player.position + 1) % boardTiles.length;
          drawBoard();
          stepCount++;
          setTimeout(animateStep, 300);
        } else {
          animating = false;
          showTileDetails(boardTiles[player.position]);
        }
      }
      animateStep();
    }

    document.getElementById("rollDiceBtn").addEventListener("click", () => {
      if(animating) return;
      const diceRoll = Math.floor(Math.random() * 6) + 1;
      alert(`You rolled a ${diceRoll}!`);
      movePlayerBy(diceRoll);
    });

    document.getElementById("viewStatsBtn").addEventListener("click", () => {
      alert(`Stats:\nHealth: ${player.stats.health}\nMoney: ${player.stats.money}\nEngagement: ${player.stats.engagement}\nKarma: ${player.stats.karma}`);
    });

    // Sample cards for "Play Card" button demo
    const cards = {
      card001: {
        id: "card001",
        title: "Go for a Run",
        description: "Improve your health by jogging around the block.",
        effects: { health: +15, money: 0, engagement: -5 },
        category: "activity"
      },
      card002: {
        id: "card002",
        title: "Go Out to Eat",
        description: "Costs $20, lowers health but boosts engagement.",
        effects: { health: -10, money: -20, engagement: +15 },
        category: "activity"
      },
    };

    document.getElementById("playCardBtn").addEventListener("click", () => {
      if(animating) return;
      const cardKeys = Object.keys(cards);
      const card = cards[cardKeys[Math.floor(Math.random() * cardKeys.length)]];
      alert(`Playing card: ${card.title}\n${card.description}`);
      applyCardEffects(card.effects);
      drawBoard();
    });

    function applyCardEffects(effects) {
      Object.entries(effects).forEach(([key, val]) => {
        if (player.stats[key] !== undefined) {
          player.stats[key] += val;
          if(player.stats[key] < 0) player.stats[key] = 0;
          if(player.stats[key] > 100) player.stats[key] = 100;
        }
      });
    }

    // Initial draw
    drawBoard();
    showTileDetails(boardTiles[0]);
  </script>
</body>
</html>
